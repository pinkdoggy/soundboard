<!--
    é˜¿è¬èˆ‡å‹•ç‰©æœ‹å‹æŒ‰éˆ• - ç²‰è‚è£½ä½œè’é›†é˜¿è¬èˆ‡å‹•ç‰©æœ‹å‹èªéŸ³çš„ç¶²ç«™
    Copyright (C) 2025 by NaN

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->

<!doctype html>
<html lang="zh-Hant">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="assets/favicon.png" type="image/png">

  <title>é˜¿è¬èˆ‡å‹•ç‰©æœ‹å‹æŒ‰éˆ•</title>
  <style>
    /* =============================================================================
       1. CSS è®Šæ•¸ç³»çµ±ï¼ˆCSS Custom Propertiesï¼‰
       
       å®šç¾©å…¨ç«™ä½¿ç”¨çš„è¨­è¨ˆ Tokenï¼ŒåŒ…å«ï¼š
       - è‰²å½©ç³»çµ±ï¼ˆäº®è‰²/æš—è‰²ä¸»é¡Œï¼‰
       - é–“è·ç³»çµ±ï¼ˆ4px åŸºç¤å–®ä½ï¼‰
       - åœ“è§’ç³»çµ±
       - é™°å½±ç³»çµ±
       - å‹•ç•«æ™‚é–“ç³»çµ±
       ============================================================================= */

    /* -----------------------------------------------------------------------------
       1.1 æš—è‰²ä¸»é¡Œè®Šæ•¸ï¼ˆé è¨­ï¼‰
       ----------------------------------------------------------------------------- */
    :root {
      /* --- è‰²å½©ï¼šåŸºç¤ --- */
      --bg: #0b0d10;
      /* é é¢èƒŒæ™¯è‰² */
      --search: #0b0d1000;
      /* æœå°‹åˆ—èƒŒæ™¯ï¼ˆé€æ˜ï¼‰ */
      --fg: #e9eef5;
      /* ä¸»è¦æ–‡å­—è‰² */
      --muted: #a8b3c7;
      /* æ¬¡è¦/è¼”åŠ©æ–‡å­—è‰² */
      --card: #141821;
      /* å¡ç‰‡èƒŒæ™¯è‰² */
      --card-2: #212832;
      /* æ¬¡ç´šå¡ç‰‡/æŒ‰éˆ•èƒŒæ™¯è‰² */
      --border: #202636;
      /* é‚Šæ¡†è‰² */

      /* --- è‰²å½©ï¼šå¼·èª¿è‰² --- */
      --accent: #6aa9ff;
      /* ä¸»å¼·èª¿è‰²ï¼ˆè—ï¼‰ */
      --accent-2: #ff9e6a;
      /* æ¬¡å¼·èª¿è‰²ï¼ˆæ©˜ï¼‰ */
      --heart: #ff5a7a;
      /* æ„›å¿ƒ/æ”¶è—è‰² */
      --chip-fg: #0b0d10;
      /* æ¨™ç±¤æ–‡å­—è‰²ï¼ˆæ·±è‰²èƒŒæ™¯ç”¨ï¼‰ */

      /* --- è‰²å½©ï¼šäº’å‹•ç‹€æ…‹ --- */
      --hover-overlay: rgba(96, 150, 255, 0.20);
      /* æ‡¸åœè¦†è“‹å±¤ */

      /* --- ç»ç’ƒæ“¬æ…‹ --- */
      --glass-bg: rgba(20, 24, 33, 0.8);
      /* ç»ç’ƒèƒŒæ™¯ */
      --glass-border: rgba(255, 255, 255, 0.12);
      /* ç»ç’ƒé‚Šæ¡† */

      /* --- èƒŒæ™¯åœ–å±¤ --- */
      --bg-blend-mode: normal;
      /* èƒŒæ™¯æ··åˆæ¨¡å¼ */
      --bg-opacity: 0.25;
      /* èƒŒæ™¯é€æ˜åº¦ */

      /* --- é–“è·ç³»çµ±ï¼ˆ4px åŸºç¤å–®ä½ï¼‰ --- */
      --space-xs: 4px;
      /* æ¥µå°é–“è· */
      --space-sm: 8px;
      /* å°é–“è· */
      --space-md: 12px;
      /* ä¸­é–“è· */
      --space-lg: 16px;
      /* å¤§é–“è· */
      --space-xl: 20px;
      /* ç‰¹å¤§é–“è· */
      --space-2xl: 24px;
      /* è¶…å¤§é–“è· */

      /* --- åœ“è§’ç³»çµ± --- */
      --radius-sm: 8px;
      /* å°åœ“è§’ï¼ˆå°æŒ‰éˆ•ï¼‰ */
      --radius-md: 10px;
      /* ä¸­åœ“è§’ï¼ˆæŒ‰éˆ•ã€Toastï¼‰ */
      --radius-lg: 12px;
      /* å¤§åœ“è§’ï¼ˆå¡ç‰‡ã€é¸å–®ï¼‰ */
      --radius-xl: 16px;
      /* ç‰¹å¤§åœ“è§’ï¼ˆé¢æ¿ï¼‰ */
      --radius-pill: 999px;
      /* è† å›Šåœ“è§’ */

      /* --- é™°å½±ç³»çµ± --- */
      --shadow-sm: 0 2px 6px rgba(0, 0, 0, 0.18);
      /* å°é™°å½±ï¼ˆæ¨™ç±¤ï¼‰ */
      --shadow-md: 0 6px 24px rgba(0, 0, 0, 0.25);
      /* ä¸­é™°å½±ï¼ˆå¡ç‰‡ï¼‰ */
      --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.35);
      /* å¤§é™°å½±ï¼ˆé ­åƒï¼‰ */
      --shadow: var(--shadow-md);
      /* é è¨­é™°å½±ï¼ˆç›¸å®¹èˆŠä»£ç¢¼ï¼‰ */

      /* --- å‹•ç•«æ™‚é–“ --- */
      --duration-fast: 0.06s;
      /* å¿«é€Ÿå‹•ç•«ï¼ˆé»æ“Šå›é¥‹ï¼‰ */
      --duration-normal: 0.15s;
      /* æ­£å¸¸å‹•ç•«ï¼ˆhoverï¼‰ */
      --duration-slow: 0.3s;
      /* æ…¢é€Ÿå‹•ç•«ï¼ˆè½‰å ´ï¼‰ */

      /* --- æ§åˆ¶é …å°ºå¯¸ --- */
      --control-h: 44px;
      /* æ§åˆ¶é …é«˜åº¦ï¼ˆè§¸æ§å‹å–„ï¼‰ */
    }

    /* -----------------------------------------------------------------------------
       1.2 äº®è‰²ä¸»é¡Œè®Šæ•¸
       ----------------------------------------------------------------------------- */
    :root.light {
      /* --- è‰²å½©ï¼šåŸºç¤ --- */
      --bg: #f8fafc;
      --search: #f8fafc00;
      --fg: #0d1320;
      --muted: #4b5563;
      --card: #ffffff;
      --card-2: #f3f6fb;
      --border: #e5e7eb;

      /* --- è‰²å½©ï¼šå¼·èª¿è‰² --- */
      --accent: #2563eb;
      --accent-2: #eb7b25;
      --heart: #e11d48;
      --chip-fg: #ffffff;

      /* --- ç»ç’ƒæ“¬æ…‹ --- */
      --glass-bg: rgba(255, 255, 255, 0.6);
      --glass-border: rgba(15, 23, 42, 0.12);

      /* --- èƒŒæ™¯åœ–å±¤ --- */
      --bg-blend-mode: normal;
      --bg-opacity: 0.35;

      /* --- é™°å½±ç³»çµ±ï¼ˆäº®è‰²ä¸»é¡Œè¼ƒæ·ºï¼‰ --- */
      --shadow-sm: 0 2px 6px rgba(2, 6, 23, 0.06);
      --shadow-md: 0 4px 18px rgba(2, 6, 23, 0.08);
      --shadow-lg: 0 6px 24px rgba(2, 6, 23, 0.12);
      --shadow: var(--shadow-md);
    }

    /* =============================================================================
       2. CSS Reset / åŸºç¤æ¨£å¼
       
       åŒ…å«ï¼š
       - Box-sizing é‡è¨­
       - Body åŸºç¤æ¨£å¼
       - èƒŒæ™¯åœ–å±¤
       - åŸºç¤å…ƒç´ æ¨£å¼
       ============================================================================= */

    /* --- å…¨åŸŸ Box-sizing --- */
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    /* --- HTML/Body åŸºç¤ --- */
    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background-color: var(--bg);
      color: var(--fg);
      font: medium ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Noto Sans, "Helvetica Neue", Arial;
      position: relative;
      z-index: 1;
      /* å°‡æ‰€æœ‰å…§å®¹æå‡åˆ°èƒŒæ™¯åœ–ä¹‹ä¸Š */
    }

    /* --- è‡ªè¨‚æ²è»¸æ¨£å¼ (Webkit) --- */
    ::-webkit-scrollbar {
      width: 14px;
      height: 14px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--muted);
      border-radius: var(--radius-pill);
      border: 3px solid var(--bg); /* å‰µé€ é–“è·æ„Ÿ */
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--accent);
      border-width: 2px; /* hover æ™‚è®“æ²è»¸çœ‹èµ·ä¾†æ›´ç²—ä¸€é» */
    }

    ::-webkit-scrollbar-corner {
      background: transparent;
    }

    /* --- èƒŒæ™¯åœ–å±¤ï¼ˆå½å…ƒç´ å¯¦ç¾å›ºå®šèƒŒæ™¯ï¼‰ --- */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('assets/background-by-jia.avif');
      background-size: auto 90%;
      background-repeat: repeat;
      background-attachment: fixed;
      background-position: var(--bg-x, 0px) 0;
      transition: background-position 1s ease-out;
      mix-blend-mode: var(--bg-blend-mode);
      opacity: var(--bg-opacity);
      z-index: -1;
      pointer-events: none;
    }

    /* --- é€£çµåŸºç¤ --- */
    a {
      color: inherit;
    }

    /* =============================================================================
       3. å…±ç”¨å…ƒä»¶æ¨£å¼
       
       å¯é‡ç”¨çš„ UI å…ƒä»¶ï¼ŒåŒ…å«ï¼š
       - .glassï¼šç»ç’ƒæ“¬æ…‹åŸºç¤
       - .btnï¼šæŒ‰éˆ•ç³»åˆ—
       - .chipï¼šæ¨™ç±¤è† å›Š
       - .tagï¼šéŸ³æ•ˆæ¨™ç±¤
       - .gridï¼šéŸ¿æ‡‰å¼ç¶²æ ¼
       ============================================================================= */

    /* -----------------------------------------------------------------------------
       3.1 ç»ç’ƒæ“¬æ…‹æ¨£å¼
       
       çµ±ä¸€å¥—ç”¨åŠé€æ˜æ¨¡ç³ŠèƒŒæ™¯æ•ˆæœçš„å…ƒä»¶
       ----------------------------------------------------------------------------- */

    /* å¥—ç”¨ç»ç’ƒæ¨£å¼çš„å…ƒä»¶ */
    .searchbar,
    .sound,
    .menu,
    #page-about .about-content,
    .bg-credit,
    .cg-header,
    .cg-board,
    .cg-result,
    .cg-rules {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: saturate(1.8) blur(12px);
      -webkit-backdrop-filter: saturate(1.8) blur(12px);
      box-shadow: var(--shadow);
    }

    /* -----------------------------------------------------------------------------
       3.2 æŒ‰éˆ•ç³»çµ±
       ----------------------------------------------------------------------------- */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-xs);
      padding: var(--space-sm) var(--space-md);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      background: linear-gradient(to bottom, var(--card), var(--card-2));
      color: var(--fg);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--duration-normal) ease;
      box-shadow: var(--shadow-sm);
    }

    .btn:hover {
      background: linear-gradient(to bottom, var(--card-2), var(--border));
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: var(--shadow-sm);
    }

    /* å°å‹æŒ‰éˆ•è®Šé«” */
    .btn--small,
    .small-btn {
      padding: var(--space-xs) var(--space-sm);
      font-size: 12px;
      border-radius: var(--radius-sm);
    }

    /* åœ–ç¤ºæŒ‰éˆ•è®Šé«” */
    .btn--icon {
      min-width: 32px;
      padding: 6px;
    }

    /* -----------------------------------------------------------------------------
       3.3 æ¨™ç±¤è† å›Šï¼ˆChipï¼‰
       
       ç”¨æ–¼æœå°‹åˆ—ä¸­çš„å·²é¸æ¨™ç±¤
       ----------------------------------------------------------------------------- */
    .chip {
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-pill);
      font-size: 12px;
      color: var(--chip-fg);
      box-shadow: var(--shadow-sm);
      cursor: pointer;
    }

    .chip button {
      appearance: none;
      border: 0;
      background: transparent;
      color: inherit;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      padding: 0 0 0 2px;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-xs);
      margin-top: var(--space-xs);
    }

    /* -----------------------------------------------------------------------------
       3.4 éŸ³æ•ˆæ¨™ç±¤ï¼ˆTagï¼‰
       
       ç”¨æ–¼éŸ³æ•ˆå¡ç‰‡ä¸Šçš„åˆ†é¡æ¨™ç±¤
       ----------------------------------------------------------------------------- */
    .tag {
      display: inline-block;
      padding: 3px 6px;
      border-radius: var(--radius-pill);
      font-size: small;
      color: var(--chip-fg);
      white-space: nowrap;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
    }

    .tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    /* æ¨™ç±¤ä¸€è¦½å€åŸŸ */
    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px var(--space-sm);
      margin: var(--space-sm) 0;
    }

    /* -----------------------------------------------------------------------------
       3.5 éŸ¿æ‡‰å¼ç¶²æ ¼ç³»çµ±
       
       éŸ³æ•ˆå¡ç‰‡çš„ç¶²æ ¼ä½ˆå±€ï¼Œæ ¹æ“šè¢å¹•å¯¬åº¦è‡ªå‹•èª¿æ•´æ¬„æ•¸
       ----------------------------------------------------------------------------- */
    .grid {
      display: grid;
      gap: var(--space-xs);
      grid-template-columns: repeat(6, minmax(0, 1fr));
    }

    /* =============================================================================
       4. ä½ˆå±€å…ƒä»¶
       
       é é¢çµæ§‹ç›¸é—œçš„ä½ˆå±€å…ƒä»¶ï¼š
       - .wrapï¼šä¸»å®¹å™¨
       - headerï¼šé é¦–
       - .section-headerï¼šå€å¡Šæ¨™é¡Œåˆ—
       ============================================================================= */

    /* -----------------------------------------------------------------------------
       4.1 ä¸»å®¹å™¨
       ----------------------------------------------------------------------------- */
    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: var(--space-xl);
    }

    /* -----------------------------------------------------------------------------
       4.2 é é¦–ï¼ˆHeaderï¼‰
       ----------------------------------------------------------------------------- */
    header {
      display: flex;
      align-items: center;
      flex-wrap: nowrap;
      /* ä¿æŒæ¨™é¡Œèˆ‡é¸å–®åœ¨åŒä¸€è¡Œ */
      gap: var(--space-md);
      margin-bottom: 14px;
    }

    header h1 {
      white-space: normal;
      min-width: 0;
      overflow-wrap: anywhere;
      margin-right: auto;
      /* å°‡å¾Œæ–¹å…ƒç´ æ¨åˆ°å³å´ */
    }

    h1 {
      font-size: 1.4rem;
      margin: 0 var(--space-sm) 0 0;
      letter-spacing: 0.5px;
    }

    /* ä¸»é¡Œåˆ‡æ›æŒ‰éˆ•ï¼ˆä½¿ç”¨é€šç”¨æŒ‰éˆ•æ¨£å¼ï¼‰ */
    .theme-toggle {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--fg);
      border-radius: var(--radius-md);
      padding: var(--space-sm) var(--space-md);
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    /* -----------------------------------------------------------------------------
       4.3 å°è¦½åˆ†é ï¼ˆTabsï¼‰
       ----------------------------------------------------------------------------- */
    .tabs {
      display: flex;
      gap: var(--space-sm);
      align-items: center;
      flex-wrap: wrap;
    }

    .tab {
      display: inline-block;
      padding: 6px var(--space-lg);
      font-size: 14px;
      border: 1px solid var(--border);
      border-radius: var(--radius-pill);
      background: var(--card-2);
      color: var(--fg);
      cursor: pointer;
      transition: background var(--duration-normal) ease, color var(--duration-normal) ease;
    }

    .tab:hover {
      background: var(--card);
    }

    .tab.active {
      background: var(--accent);
      border-color: var(--accent);
      color: var(--chip-fg);
    }

    /* æ‰‹æ©Ÿç‰ˆæ¼¢å ¡é¸å–®æŒ‰éˆ• */
    .nav-toggle {
      display: none;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--fg);
      border-radius: var(--radius-md);
      padding: var(--space-sm);
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    /* -----------------------------------------------------------------------------
       4.4 å€å¡Šæ¨™é¡Œåˆ—ï¼ˆSection Headerï¼‰
       ----------------------------------------------------------------------------- */
    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 14px 0 var(--space-sm);
    }

    .section-header h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.2px;
    }

    .section-header .actions {
      display: flex;
      gap: 3px;
    }

    .section-title {
      margin: 18px 0 10px;
      font-weight: 700;
      letter-spacing: 0.3px;
    }

    /* =============================================================================
       5. åŠŸèƒ½æ¨¡çµ„æ¨£å¼
       
       å„åŠŸèƒ½å€å¡Šçš„å°ˆå±¬æ¨£å¼
       ============================================================================= */

    /* -----------------------------------------------------------------------------
       5.1 æœå°‹åˆ—æ¨¡çµ„
       ----------------------------------------------------------------------------- */
    .anniversary-zone {
      width: 100%;
      margin-bottom: var(--space-sm);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
      /* é ç•™ç©ºé–“çµ¦æœªä¾†çš„é ­åƒèˆ‡å‹•ç•« */
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .anniversary-content {
      width: 100%;
      height: 100%;
      padding: var(--space-md);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform var(--duration-fast);
      z-index: 1;
    }
    
    .anniversary-content:active {
      transform: scale(0.98);
    }

    .anniversary-text {
      color: #fff;
      font-weight: 900;
      font-size: 1.5rem;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      user-select: none;
      letter-spacing: 1px;
    }

    .search-row {
      display: flex;
      flex-wrap: nowrap;
      gap: 0;
      align-items: stretch;
      position: sticky;
      top: 0;
      background: var(--search);
      padding: var(--space-sm) 0 var(--space-md);
      z-index: 5;
    }

    .searchbar {
      flex: 1 1 auto;
      min-width: 0;
      display: flex;
      align-items: center;
      gap: 6px;
      border-radius: var(--radius-lg) 0 0 var(--radius-lg);
      border-right: 0;
      padding: 6px var(--space-sm);
      position: relative;
      height: var(--control-h);
      transition: box-shadow var(--duration-normal) ease, border-color var(--duration-normal) ease;
    }

    .searchbar:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(106, 169, 255, 0.25);
      z-index: 1;
    }

    .searchbar input {
      flex: 1;
      min-width: 0;
      background: transparent;
      border: 0;
      outline: 0;
      color: var(--fg);
      font-size: 16px;
      height: 100%;
      line-height: var(--control-h);
      padding: 0 6px;
    }

    /* æ¸…é™¤æŒ‰éˆ•ï¼ˆæœå°‹åˆ—å³å´ï¼‰ */
    .search-row #clearBtn {
      flex: 0 0 auto;
      white-space: nowrap;
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
      border-left: 1px solid var(--glass-border);
      background: var(--glass-bg);
      backdrop-filter: saturate(1.5) blur(8px);
      -webkit-backdrop-filter: saturate(1.5) blur(8px);
      height: var(--control-h);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 14px;

      /* è¦†è“‹ .btn çš„é è¨­äº’å‹•æ¨£å¼ */
      box-shadow: none;
      transition: color var(--duration-normal) ease;
    }

    .search-row #clearBtn:hover {
      background: var(--glass-bg);
      /* ä¿æŒåŸé‚Šæ¡†è‰²ï¼Œä¸éš¨ .btn:hover è®Šè‰² */
      border-top-color: var(--border);
      border-right-color: var(--border);
      border-bottom-color: var(--border);
      border-left-color: var(--glass-border);
      transform: none;
      box-shadow: none;
      color: var(--accent);
    }

    .search-row #clearBtn:active {
      transform: none;
      box-shadow: none;
    }

    /* -----------------------------------------------------------------------------
       5.2 éŸ³æ•ˆå¡ç‰‡æ¨¡çµ„
       ----------------------------------------------------------------------------- */
    .sound {
      border-radius: var(--radius-lg);
      padding: var(--space-sm);
      display: flex;
      flex-direction: column;
      gap: 5px 2px;
      user-select: none;
      cursor: pointer;
      transition: transform var(--duration-normal) cubic-bezier(0.34, 1.56, 0.64, 1), 
                  box-shadow var(--duration-normal) ease,
                  border-color var(--duration-normal) ease;
    }

    .sound:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
      border-color: var(--accent);
      z-index: 10;
    }

    .sound:active {
      transform: scale(0.98);
      transition: transform var(--duration-fast) ease;
    }

    .sound-top {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .title {
      font-weight: 600;
      font-size: smaller;
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* æ„›å¿ƒæŒ‰éˆ• */
    .heart {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      background: var(--card-2);
      cursor: pointer;
      flex: 0 0 auto;
      padding: 0;
    }

    .heart svg {
      width: 14px;
      height: 14px;
      display: block;
      flex-shrink: 0;
    }

    .heart[aria-pressed="true"] svg path {
      fill: var(--heart);
    }

    /* -----------------------------------------------------------------------------
       5.3 æ’­æ”¾èˆå°æ¨¡çµ„ï¼ˆé ­åƒå‹•ç•«ï¼‰
       ----------------------------------------------------------------------------- */
    .stage {
      position: fixed;
      left: 0;
      right: 0;
      bottom: var(--space-md);
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-md) 14px;
      justify-content: center;
      pointer-events: none;
      z-index: 40;
      padding: 0 var(--space-md);
    }

    .group {
      display: inline-flex;
      gap: var(--space-sm);
      align-items: flex-end;
    }

    .avatar {
      width: 75px;
      height: 75px;
      border-radius: var(--radius-pill);
      background: transparent;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.8);
      box-shadow: var(--shadow-lg);
      transform-origin: 50% 100%;
    }

    .avatar>img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* -----------------------------------------------------------------------------
       5.4 å³éµé¸å–®æ¨¡çµ„
       ----------------------------------------------------------------------------- */
    .menu {
      position: fixed;
      z-index: 9999;
      min-width: 180px;
      border-radius: var(--radius-lg);
      overflow: hidden;
    }

    .menu.hidden {
      display: none;
    }

    .menu-item {
      padding: 10px var(--space-md);
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      transition: background var(--duration-normal) ease;
    }

    .menu-item:last-child {
      border-bottom: 0;
    }

    .menu-item:hover {
      background: var(--hover-overlay);
    }

    /* -----------------------------------------------------------------------------
       5.5 Toast é€šçŸ¥æ¨¡çµ„
       ----------------------------------------------------------------------------- */
    .toast {
      position: fixed;
      left: 50%;
      bottom: 80px;
      transform: translateX(-50%);
      background: var(--card);
      border: 1px solid var(--border);
      padding: 10px 14px;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow);
      z-index: 70;
    }

    .toast.hidden {
      display: none;
    }

    /* -----------------------------------------------------------------------------
       5.6 Modal å°è©±æ¡†æ¨¡çµ„
       ----------------------------------------------------------------------------- */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.45);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 120;
    }

    .modal-backdrop.hidden {
      display: none;
    }

    .modal {
      background: var(--bg);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      padding: var(--space-md);
      max-width: 320px;
      box-shadow: var(--shadow);
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: var(--space-lg);
    }


    /* -----------------------------------------------------------------------------
      5.7 é€±å¹´æ…¶ç¥è³€é¢æ¿
    ----------------------------------------------------------------------------- */

    .gradient-r1-background {
        background: linear-gradient(180deg,
          #ffc0ab, #ff893d, #ffde82, #b2f4c7,
          #60cfff, #2d7eff, #b5b1ff);
        background-size: 1400% 1400%;
        -webkit-animation: gradient-key-r1 30s ease infinite;
        -moz-animation: gradient-key-r1 30s ease infinite;
        animation: gradient-key-r1 30s ease infinite;
    }

    @-webkit-keyframes gradient-key-r1 {
        0%{background-position:50% 0%}
        50%{background-position:50% 100%}
        100%{background-position:50% 0%}
    }
    @-moz-keyframes gradient-key-r1 {
        0%{background-position:50% 0%}
        50%{background-position:50% 100%}
        100%{background-position:50% 0%}
    }
    @keyframes gradient-key-r1 {
        0%{background-position:50% 0%}
        50%{background-position:50% 100%}
        100%{background-position:50% 0%}
    }

    /* =============================================================================
       6. é é¢å°ˆå±¬æ¨£å¼
       ============================================================================= */

    /* -----------------------------------------------------------------------------
       6.1 é—œæ–¼é é¢
       ----------------------------------------------------------------------------- */
    #page-about .about-content {
      border-radius: 14px;
      padding: 14px var(--space-lg);
    }

    /* èƒŒæ™¯åœ–ç½²å */
    .bg-credit {
      position: fixed;
      right: var(--space-lg);
      bottom: var(--space-lg);
      font-size: large;
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-md);
      font-weight: 800;
      z-index: 60;
    }

    .bg-credit a {
      text-decoration: underline;
    }

    /* èƒŒæ™¯æ»¿ç‰ˆæ¨¡å¼ */
    body.bg-full {
      --bg-opacity: 1 !important;
    }

    /* =============================================================================
       7. å‹•ç•«ç³»çµ±ï¼ˆKeyframesï¼‰
       ============================================================================= */

    /* å½ˆå…¥å‹•ç•«ï¼šç”¨æ–¼é ­åƒé€²å ´ */
    @keyframes popIn {
      0% {
        transform: translateY(20px) scale(0.7);
        opacity: 0;
      }

      100% {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }

    /* æŠ–å‹•å‹•ç•«ï¼šç”¨æ–¼æ’­æ”¾ä¸­çš„é ­åƒ */
    @keyframes jitter {

      0%,
      100% {
        transform: translateY(0) rotate(0deg);
      }

      20% {
        transform: translateY(-2px) rotate(-1deg);
      }

      40% {
        transform: translateY(1px) rotate(1deg);
      }

      60% {
        transform: translateY(-1px) rotate(0.6deg);
      }

      80% {
        transform: translateY(1px) rotate(-0.6deg);
      }
    }

    /* è·³å‡ºå‹•ç•«ï¼šç”¨æ–¼é ­åƒé›¢å ´ */
    @keyframes hopOut {
      0% {
        transform: translateY(0);
        opacity: 1;
      }

      22% {
        transform: translateY(-12px);
        opacity: 1;
      }

      100% {
        transform: translateY(60px);
        opacity: 0;
      }
    }

    /* å‹•ç•«é¡åˆ¥ */
    .pop-in {
      animation: popIn 0.28s cubic-bezier(0.2, 0.9, 0.18, 1) both;
    }

    .jit {
      animation: jitter 0.9s ease-in-out infinite;
    }

    .hop-out {
      animation: hopOut 0.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
    }

    /* =============================================================================
       8. éŸ¿æ‡‰å¼æ¨£å¼ï¼ˆMedia Queriesï¼‰
       
       çµ±ä¸€ç®¡ç†æ‰€æœ‰æ–·é»èª¿æ•´ï¼Œå¾å¤§åˆ°å°æ’åˆ—
       ============================================================================= */

    /* --- ä¸­ç­‰è¢å¹•ï¼ˆâ‰¤1000pxï¼‰ï¼š5æ¬„ç¶²æ ¼ --- */
    @media (max-width: 1000px) {
      .grid {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }
    }

    /* --- å¹³æ¿ï¼ˆâ‰¤800pxï¼‰ï¼š4æ¬„ç¶²æ ¼ --- */
    @media (max-width: 800px) {
      .grid {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    }

    /* --- å°å‹å¹³æ¿/æ‰‹æ©Ÿæ©«å‘ï¼ˆâ‰¤760pxï¼‰ï¼šæ¼¢å ¡é¸å–® --- */
    @media (max-width: 760px) {
      .nav-toggle {
        display: inline-flex;
      }

      header .tabs {
        display: none;
        position: absolute;
        right: 0;
        top: 100%;
        padding: var(--space-sm);
        border-radius: var(--radius-lg);
        gap: 6px;
        flex-direction: column;
        align-items: stretch;
        min-width: 180px;
        z-index: 120;
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        backdrop-filter: saturate(1.8) blur(12px);
        -webkit-backdrop-filter: saturate(1.8) blur(12px);
        box-shadow: var(--shadow);
      }

      body.nav-open header .tabs {
        display: flex;
      }
    }

    /* --- å¤§å‹æ‰‹æ©Ÿï¼ˆâ‰¤600pxï¼‰ï¼š3æ¬„ç¶²æ ¼ --- */
    @media (max-width: 600px) {
      .grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      header .tabs {
        margin-top: var(--space-sm);
      }

      header .theme-toggle {
        margin-top: var(--space-sm);
      }
    }

    /* --- å°å‹æ‰‹æ©Ÿï¼ˆâ‰¤400pxï¼‰ï¼š2æ¬„ç¶²æ ¼ --- */
    @media (max-width: 400px) {
      .grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    /* =============================================================================
       9. å·¥å…·é¡åˆ¥ï¼ˆUtility Classesï¼‰
       
       åŒ…å«ï¼š
       - 9.0 é€šç”¨å·¥å…·é¡åˆ¥
       - 9.1 è¨˜æ†¶éŠæˆ²é é¢
       - 9.2 ç¥¨é¸çµæœé é¢
       ============================================================================= */

    /* éš±è—å…ƒç´  */
    .hidden {
      display: none;
    }

    /* åœç”¨éæ¸¡å‹•ç•«ï¼ˆç”¨æ–¼ä¸»é¡Œåˆ‡æ›æ™‚é¿å… lagï¼‰ */
    .no-transition,
    .no-transition * {
      transition: none !important;
    }

    /* æè¿°æ–‡å­— */
    .desc {
      color: var(--muted);
      font-size: 14px;
      margin: 0 0 6px;
    }

    /* ç©ºç‹€æ…‹æç¤º */
    .empty {
      color: var(--muted);
      padding: var(--space-md) 0;
    }

    /* æŒçºŒç™¼å…‰æ•ˆæœï¼ˆç”¨æ–¼é«˜äº®å¡ç‰‡ã€å„²å­˜æŒ‰éˆ•ç­‰ï¼‰ */
    .glow-persistent {
      box-shadow: 0 0 0 4px rgba(106, 169, 255, 0.5), 0 0 12px rgba(106, 169, 255, 0.75);
      transition: box-shadow var(--duration-slow) ease;
    }

    /* SortableJS æ‹–æ”¾æ¨£å¼ */
    .drag-ghost {
      opacity: 0.6;
      transform: scale(0.98);
    }

    .drag-chosen {
      outline: 2px dashed var(--accent);
    }

    .dragging {
      cursor: grabbing;
    }

    body.sorting #favGrid .card {
      cursor: grab;
    }

    /* Header ç›¸å°å®šä½ï¼ˆç”¨æ–¼ä¸‹æ‹‰é¸å–®ï¼‰ */
    header {
      position: relative;
    }

    /* -----------------------------------------------------------------------------
       9.1 è¨˜æ†¶éŠæˆ²é é¢
       ----------------------------------------------------------------------------- */
    .cg-board {
      display: grid;
      grid-template-columns: repeat(4, 70px);
      grid-template-rows: repeat(4, 70px);
      gap: var(--space-sm);
      justify-content: center;
      margin: 12px auto;
      width: min(720px, 96%);
      padding: 12px;
      border-radius: var(--radius-lg);
      justify-items: center;
    }

    .cg-card {
      width: 70px;
      height: 70px;
      background: #888;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      perspective: 600px;
      will-change: transform;
      transition: transform var(--duration-normal) ease, box-shadow var(--duration-normal) ease;
      user-select: none;
    }

    .cg-card.matched {
      opacity: 0.5;
      pointer-events: none;
    }

    .cg-card-inner {
      width: 100%;
      height: 100%;
      transition: transform 0.4s cubic-bezier(.4, 2, .6, 1);
      transform-style: preserve-3d;
      position: relative;
    }

    .cg-card.flipped .cg-card-inner {
      transform: rotateY(180deg);
    }

    .cg-card-front,
    .cg-card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .cg-card-front {
      background: #888;
    }

    .cg-card:active,
    .cg-card.clicked {
      transform: scale(1.06);
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.28);
    }

    .cg-card-back {
      background: #fff;
      transform: rotateY(180deg);
      overflow: hidden;
    }

    .cg-card-back img {
      width: 80%;
      height: 80%;
      object-fit: contain;
      border-radius: var(--radius-sm);
    }

    .cg-lock {
      position: absolute;
      right: 6px;
      top: 6px;
      background: rgba(0, 0, 0, 0.4);
      color: white;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-pill);
      font-weight: 700;
      font-size: 14px;
    }

    .cg-header {
      display: flex;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
      margin: var(--space-xs) auto;
      padding: var(--space-sm) 12px;
      width: min(720px, 96%);
      border-radius: var(--radius-lg);
      position: sticky;
      top: 12px;
      z-index: 60;
      flex-wrap: wrap;
    }

    #cg-timer {
      font-size: 1.0rem;
      font-weight: 700;
      color: var(--fg);
      letter-spacing: 0.6px;
      min-width: 25px;
      text-align: left;
    }

    #cg-timer.cg-running {
      color: #34d399;
    }

    #cg-accuracy {
      color: var(--muted);
      font-weight: 600;
      margin-left: var(--space-sm);
    }

    .cg-stats {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      flex: 1 1 auto;
      min-width: 0;
    }

    .cg-controls {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      flex: 0 0 auto;
    }

    .cg-header button {
      margin-left: var(--space-sm);
      flex: 0 0 auto;
    }

    .cg-result {
      text-align: center;
      font-size: 1.05rem;
      border-radius: 14px;
      padding: 14px var(--space-lg);
      max-width: 480px;
      margin: 18px auto 0;
    }

    .cg-result h3 {
      margin: 0 0 6px;
      font-size: 1.15rem;
    }

    .cg-result .stats {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
      color: var(--muted);
      font-weight: 600;
    }

    .cg-result .big-num {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--fg);
    }

    .cg-rules {
      width: min(720px, 96%);
      margin: 14px auto 28px;
      border-radius: var(--radius-lg);
      padding: 12px var(--space-lg);
      color: var(--fg);
    }

    .cg-rules h4 {
      margin: 0 0 var(--space-sm);
      font-size: 1.05rem;
    }

    .cg-rules ul {
      margin: 0;
      padding-left: 18px;
      color: var(--muted);
    }

    /* éŠæˆ²é é¢éŸ¿æ‡‰å¼èª¿æ•´ */
    @media (max-width: 420px) {
      .cg-header {
        gap: var(--space-sm);
        padding: var(--space-sm);
      }

      #cg-timer {
        font-size: 1rem;
      }

      .cg-board {
        grid-template-columns: repeat(4, 56px);
        grid-template-rows: repeat(4, 56px);
        gap: var(--space-xs);
        padding: 10px;
      }

      .cg-card {
        width: 56px;
        height: 56px;
      }
    }

    /* -----------------------------------------------------------------------------
       9.2 ç¥¨é¸çµæœé é¢
       ----------------------------------------------------------------------------- */
    #page-awards .awards-grid {
      display: grid;
      gap: var(--space-xs);
      grid-template-columns: repeat(4, minmax(120px, 240px));
      align-items: center;
      justify-items: center;
      justify-content: center;
    }

    #page-awards .awards-grid img {
      width: 100%;
      height: auto;
      display: block;
      max-width: 100%;
      object-fit: cover;
    }

    #page-awards .grid .title {
      text-align: left;
    }

    @media (max-width: 700px) {
      #page-awards .awards-grid {
        grid-template-columns: repeat(2, minmax(120px, 240px));
        justify-content: center;
      }
    }

    /* =============================================================================
       10. demaPanel å¤šè»ŒéŸ³è¨Šç·¨è¼¯å™¨
       ============================================================================= */

    /* -----------------------------------------------------------------------------
       10.1 é¢æ¿å®¹å™¨
       ----------------------------------------------------------------------------- */
    .dema-panel {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 100;
      background: var(--glass-bg);
      border-top: 1px solid var(--glass-border);
      backdrop-filter: saturate(1.8) blur(16px);
      -webkit-backdrop-filter: saturate(1.8) blur(16px);
      box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.25);
      transform: translateY(100%);
      transition: transform var(--duration-slow) cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      max-height: 280px;
    }

    .dema-panel.open {
      transform: translateY(0);
    }

    /* -----------------------------------------------------------------------------
       10.2 æ§åˆ¶åˆ—
       ----------------------------------------------------------------------------- */
    .dema-controls {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-xs) var(--space-sm);
      margin: var(--space-xs) var(--space-sm);
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap;
      min-height: 45px;
      position: relative;
    }

    .dema-controls--bottom {
      border-bottom: none;
      border-top: 1px solid var(--border);
      justify-content: center;
      min-height: 28px;
      padding: 4px var(--space-sm);
    }

    .dema-controls-left {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      z-index: 1;
    }

    .dema-controls-center {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .dema-controls-right {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-left: auto;
      z-index: 1;
    }

    .dema-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 28px;
      height: 28px;
      padding: 0 var(--space-xs);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--card);
      color: var(--fg);
      font-size: 12px;
      cursor: pointer;
      transition: all var(--duration-normal) ease;
    }

    .dema-btn:hover {
      background: var(--card-2);
      border-color: var(--accent);
    }

    .dema-btn:active {
      transform: scale(0.96);
    }

    .dema-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .dema-btn--icon {
      padding: 0;
      width: 28px;
    }

    .dema-btn--play {
      width: 32px;
      height: 32px;
      border-radius: var(--radius-pill);
      background: var(--accent);
      border-color: var(--accent);
      color: var(--chip-fg);
    }

    .dema-btn--play:hover {
      filter: brightness(1.1);
      border-color: var(--accent);
    }

    .dema-time {
      font-family: ui-monospace, 'SF Mono', monospace;
      font-size: 12px;
      color: var(--muted);
      min-width: 100px;
      text-align: center;
    }

    .dema-zoom-wrap,
    .dema-volume-wrap {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .dema-zoom-label,
    .dema-volume-label {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      width: 70px;
      text-align: right;
    }

    .dema-zoom-slider,
    .dema-volume-slider {
      width: 120px;
      flex: 0 0 120px;
      height: 4px;
      accent-color: var(--accent);
      margin: 0;
      cursor: pointer;
    }

    /* -----------------------------------------------------------------------------
       10.3 éŸ³è»Œå€åŸŸ
       ----------------------------------------------------------------------------- */
    .dema-tracks-wrap {
      flex: 1;
      overflow-x: scroll;
      overflow-y: hidden;
      position: relative;
      cursor: grab;
      /* éš±è—æ»¾å‹•è»¸ */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }

    .dema-tracks-wrap::-webkit-scrollbar {
      display: none; /* Chrome/Safari/Opera */
    }

    .dema-tracks-wrap.dragging {
      cursor: grabbing;
      user-select: none;
    }

    .dema-tracks-scroll {
      display: flex;
      flex-direction: column;
      min-width: 100%;
      position: relative;
    }

    /* æ™‚é–“åˆ»åº¦å°º */
    .dema-timeline {
      height: 25px;
      background: var(--card-2);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 5;
    }

    .dema-timeline-canvas {
      width: 100%;
      height: 100%;
    }

    /* å–®ä¸€éŸ³è»Œ */
    .dema-track {
      height: 35px;
      position: relative;
      border-bottom: 1px solid var(--border);
      background: var(--card);
    }

    .dema-track:nth-child(odd) {
      background: var(--card-2);
    }

    .dema-track-label {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      background: inherit;
      border-right: 1px solid var(--border);
      z-index: 3;
    }

    .dema-track-content {
      position: absolute;
      left: 32px;
      top: 0;
      right: 0;
      bottom: 0;
      overflow: visible;
    }

    /* -----------------------------------------------------------------------------
       10.4 éŸ³è¨Šç‰‡æ®µ (Clip)
       ----------------------------------------------------------------------------- */
    .dema-clip {
      position: absolute;
      top: 2px;
      height: calc(100% - 4px);
      min-width: 20px;
      border-radius: var(--radius-sm);
      cursor: grab;
      display: flex;
      align-items: center;
      overflow: hidden;
      box-shadow: var(--shadow-sm);
      border: 1px solid rgba(255, 255, 255, 0.15);
      transition: box-shadow var(--duration-normal) ease, transform var(--duration-fast) ease;
      user-select: none;
      touch-action: none;
    }

    .dema-clip:hover {
      box-shadow: var(--shadow-md);
      z-index: 10;
    }

    .dema-clip.selected {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
      z-index: 20;
    }

    .dema-clip.dragging {
      cursor: grabbing;
      opacity: 0.85;
      z-index: 30;
      transform: scale(1.02);
    }

    .dema-clip-label {
      position: relative;
      z-index: 1;
      padding: 0 4px;
      font-size: 15px;
      font-weight: 700;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans TC', 'Microsoft JhengHei', sans-serif;
      color: rgba(0, 0, 0, 0.6);
      text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    /* Trim handles */
    .dema-clip-handle {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 20px;
      cursor: ew-resize;
      z-index: 10;
      opacity: 0;
      transition: opacity var(--duration-normal) ease;
      background: transparent;
    }

    .dema-clip-handle::after {
      content: '';
      position: absolute;
      top: 4px;
      bottom: 4px;
      width: 4px;
      background: var(--accent);
      border-radius: 2px;
    }

    .dema-clip-handle--left {
      left: -8px;
    }

    .dema-clip-handle--left::after {
      left: 8px;
    }

    .dema-clip-handle--right {
      right: -8px;
    }

    .dema-clip-handle--right::after {
      right: 8px;
    }

    /* PC: hover é¡¯ç¤º handle */
    .dema-clip:hover .dema-clip-handle {
      opacity: 1;
    }

    /* ç§»å‹•ç«¯: é¸ä¸­æ™‚é¡¯ç¤º handle */
    .dema-clip.selected .dema-clip-handle {
      opacity: 1;
    }

    /* æ³¢å‹ Canvas */
    .dema-clip-wave {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .dema-clip-wave canvas {
      width: 100%;
      height: 100%;
      opacity: 0.9;
    }

    /* -----------------------------------------------------------------------------
       10.5 Playheadï¼ˆæ’­æ”¾é ­ï¼‰
       ----------------------------------------------------------------------------- */
    .dema-playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--accent-2);
      z-index: 50;
      pointer-events: none;
      transform: translateX(-1px);
    }

    .dema-playhead::before {
      content: '';
      position: absolute;
      top: -2px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 8px solid var(--accent-2);
    }

    /* -----------------------------------------------------------------------------
       10.6 ç©ºç‹€æ…‹
       ----------------------------------------------------------------------------- */
    .dema-empty {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 13px;
      pointer-events: none;
    }

    /* -----------------------------------------------------------------------------
       10.7 éŸ¿æ‡‰å¼èª¿æ•´
       ----------------------------------------------------------------------------- */
    @media (max-width: 600px) {
      .dema-panel {
        max-height: 260px;
      }

      .dema-controls {
        padding: var(--space-xs) var(--space-sm);
        gap: var(--space-sm) var(--space-xs);
      }

      /* æ‰‹æ©Ÿç«¯ï¼šå–æ¶ˆçµ•å°å®šä½ï¼Œæ”¹ç‚ºæ­£å¸¸æµå¼æ’ç‰ˆ */
      .dema-controls-center {
        position: static;
        transform: none;
        order: 1;
        flex-basis: 100%;
        justify-content: center;
        padding-top: 4px;
      }

      /* left å’Œ right å¹³åˆ†ç¬¬ä¸€è¡Œ */
      .dema-controls-left,
      .dema-controls-right {
        flex: 1;
        min-width: 0;
      }

      .dema-controls-right {
        justify-content: flex-end;
      }

      .dema-time { display: none; }

      /* wrap å…è¨±æŠ˜è¡Œï¼šæ»‘æ¡¿ä¸€è¡Œï¼Œlabel ä¸€è¡Œ */
      .dema-zoom-wrap,
      .dema-volume-wrap {
        flex-wrap: wrap;
        justify-content: center;
        gap: 2px;
      }

      /* æ»‘æ¡¿å›ºå®šé•·åº¦ï¼Œä¸éš¨å®¹å™¨ä¼¸ç¸® */
      .dema-zoom-slider,
      .dema-volume-slider {
        width: 100px;
        flex: 0 0 100px;
      }

      /* æ›´å°è¢å¹•é©é… */
      @media (max-width: 380px) {
        .dema-zoom-slider,
        .dema-volume-slider {
          width: 80px;
          flex: 0 0 80px;
        }
      }

      /* label æŠ˜åˆ°ç¬¬äºŒè¡Œç½®ä¸­ */
      .dema-zoom-label,
      .dema-volume-label {
        font-size: 10px;
        text-align: center;
        width: auto;
      }

      .dema-track-content {
        left: 24px;
      }
    }

    @media (max-width: 400px) {
      /* æ›´å°è¢å¹•ï¼šæ»‘æ¡¿åŠ é•· */
      .dema-zoom-slider,
      .dema-volume-slider {
        width: 100px;
      }
    }

    /* -----------------------------------------------------------------------------
       10.8 ç‚ºé¢æ¿é–‹å•Ÿæ™‚èª¿æ•´é é¢åº•éƒ¨é–“è·
       ----------------------------------------------------------------------------- */
    body.dema-open .stage {
      bottom: 220px;
    }

    body.dema-open .bg-credit {
      bottom: 230px;
    }

    /* äº®è‰²ä¸»é¡Œå¾®èª¿ */
    :root.light .dema-clip {
      border-color: rgba(0, 0, 0, 0.1);
    }

    :root.light .dema-clip-label {
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <h1>é˜¿è¬èˆ‡å‹•ç‰©æœ‹å‹æŒ‰éˆ•2686</h1>
      <button id="navToggle" class="nav-toggle" aria-label="æ‰“é–‹é¸å–®" aria-expanded="false" aria-controls="primaryNav"
        title="é¸å–®">
        <svg width="22" height="22" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M3 6h18M3 12h18M3 18h18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
        </svg>
      </button>

      <!-- å°è¦½åˆ†é ï¼šæ”¾ç½®æ–¼æ¨™é¡Œèˆ‡ä¸»é¡Œåˆ‡æ›æŒ‰éˆ•ä¹‹é–“ï¼Œé å³æ’ç‰ˆ -->
      <nav id="primaryNav" class="tabs" role="tablist" aria-label="ä¸»é¸å–®">
        <button id="tab-home" class="tab active" data-page="home" role="tab" aria-selected="true"
          aria-controls="page-home">ä¸»é </button>
        <button id="tab-game" class="tab" data-page="game" role="tab" aria-selected="false"
          aria-controls="page-game">å°éŠæˆ²</button>
        <button id="tab-about" class="tab" data-page="about" role="tab" aria-selected="false"
          aria-controls="page-about">é—œæ–¼</button>
        <button id="tab-awards" class="tab" data-page="awards" role="tab" aria-selected="false"
          aria-controls="page-awards">ç¥¨é¸çµæœ</button>
        <button id="settingsBtn" class="tab" aria-label="é–‹å•Ÿè¨­å®šé¢æ¿" aria-haspopup="dialog">è¨­å®š</button>
      </nav>

    </header>

    <!-- é¦–é å…§å®¹ï¼šéŸ³æ•ˆåˆ—è¡¨ -->
    <main id="page-home" role="tabpanel" aria-labelledby="tab-home">
      <!-- ä¸‰é€±å¹´æ…¶ç¥å°ˆå€ -->
      <div id="anniversaryZone" class="anniversary-zone gradient-r1-background">
        <div class="anniversary-content" role="button" aria-label="æ…¶ç¥ä¸‰é€±å¹´">
           <div class="anniversary-text">ğŸ‰ä¸‰é€±å¹´å¿«æ¨‚ğŸ‰</div>
        </div>
      </div>
      <!-- æœå°‹åˆ—ï¼ˆç¨ç«‹æˆ rowï¼‰ -->
      <div class="search-row">
        <div class="searchbar" role="search">
          <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
            <path fill="currentColor"
              d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16a6.471 6.471 0 0 0 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14" />
          </svg>
          <input id="q" placeholder="æœå°‹æ¨™é¡Œæˆ– #æ¨™ç±¤ï¼ˆå¯å¤šå€‹ï¼Œç”¨ç©ºç™½åˆ†éš”ï¼‰" autocomplete="off" aria-label="æœå°‹éŸ³æ•ˆ" />
          <div id="activeChips" class="chips" role="list" aria-label="å·²é¸å–çš„æœå°‹æ¨™ç±¤"></div>
        </div>
        <button id="clearBtn" class="btn" aria-label="æ¸…é™¤æœå°‹">æ¸…é™¤</button>
      </div>
      <!-- æ¨™ç±¤ä¸€è¦½ -->
      <div id="tagList" class="tag-list" role="list" aria-label="å¯é»é¸çš„éŸ³æ•ˆæ¨™ç±¤"></div>
      <!-- æœ€æ„›å€ -->
      <section aria-labelledby="fav-section-title">
        <div class="section-header">
          <h3 id="fav-section-title">æœ€æ„›éŸ³æ•ˆ</h3>
          <div class="actions">
            <button id="sortFavBtn" class="btn small-btn" aria-label="é–‹å•Ÿæ‰‹å‹•æ’åˆ—æ¨¡å¼">æ‰‹å‹•æ’åˆ—</button>
            <button id="doneSortBtn" class="btn small-btn glow-persistent hidden" aria-label="å„²å­˜ç›®å‰æ’åˆ—é †åº">å„²å­˜æ’åˆ—</button>
            <button id="shareFavBtn" class="btn small-btn" aria-label="åˆ†äº«æœ€æ„›åˆ—è¡¨">åˆ†äº«</button>
          </div>
        </div>
        <div id="favGrid" class="grid" role="list" aria-label="æœ€æ„›éŸ³æ•ˆåˆ—è¡¨"></div>
        <div id="favEmpty" class="empty hidden" role="status">é‚„æ²’æœ‰æœ€æ„›ã€‚é»éŸ³æ•ˆå³ä¸Šçš„ â¤ï¸ åŠ å…¥æœ€æ„›ã€‚</div>
      </section>
      <!-- æ”¶åˆ°çš„åˆ—è¡¨ï¼šåƒ…ç•¶ URL åŒ…å« list åƒæ•¸æ™‚é¡¯ç¤º -->
      <section id="receivedSection" class="hidden" aria-labelledby="received-section-title">
        <div id="receivedHeader" class="section-header">
          <h3 id="received-section-title">æ”¶åˆ°çš„åˆ—è¡¨</h3>
        </div>
        <div id="receivedGrid" class="grid" role="list" aria-label="æ”¶åˆ°çš„éŸ³æ•ˆåˆ—è¡¨"></div>
      </section>
      <!-- å…¨éƒ¨éŸ³æ•ˆ -->
      <section aria-labelledby="all-sounds-title">
        <div class="section-header">
          <h3 id="all-sounds-title">å…¨éƒ¨éŸ³æ•ˆ</h3>
          <div class="actions">
            <button id="openDemaBtn" class="btn small-btn" aria-label="é–‹å•Ÿå¤šè»Œæ··éŸ³ç·¨è¼¯å™¨">æ··éŸ³</button>
            <button id="shuffleBtn" class="btn small-btn" aria-label="éš¨æ©Ÿæ’åˆ—éŸ³æ•ˆé †åº">æ´—ç‰Œ</button>
            <button id="resetOrderBtn" class="btn small-btn" aria-label="æ¢å¾©é è¨­æ’åˆ—é †åº">é è¨­é †åº</button>
          </div>
        </div>
        <p class="desc">æç¤ºï¼šé»éŸ³æ•ˆå³å¯æ’­æ”¾ï¼›å³éµï¼ˆæˆ–è¡Œå‹•è£ç½®é•·æŒ‰ï¼‰å¯åˆ†äº«/ä¸‹è¼‰ã€‚</p>
        <div id="grid" class="grid" role="list" aria-label="å…¨éƒ¨éŸ³æ•ˆåˆ—è¡¨"></div>
        <div id="empty" class="empty hidden" role="status">æ²’æœ‰ç¬¦åˆæœå°‹çš„éŸ³æ•ˆã€‚</div>
      </section>
    </main>
    <!-- å°éŠæˆ²åˆ†é  -->
    <div id="page-game" class="hidden" role="tabpanel" aria-labelledby="tab-game">
      <div id="concentration-game" role="application" aria-label="è¨˜æ†¶å°éŠæˆ²">
        <div class="cg-header">
          <div class="cg-stats" aria-live="polite">
            <span id="cg-timer" aria-label="éŠæˆ²æ™‚é–“">00:00</span>
            <span id="cg-accuracy" aria-label="æº–ç¢ºç‡">æº–ç¢ºç‡ï¼š--%</span>
          </div>
          <div class="cg-controls">
            <button id="cg-restart" class="btn small-btn" aria-label="é‡æ–°é–‹å§‹éŠæˆ²">é‡é–‹ä¸€å±€</button>
          </div>
        </div>
        <div id="cg-board" class="cg-board" role="grid" aria-label="è¨˜æ†¶å¡ç‰Œé¢æ¿"></div>
        <div id="cg-result" class="cg-result hidden" role="alert" aria-live="assertive"></div>
        <!-- è¦å‰‡èªªæ˜å¡ï¼šèˆ‡å…¶ä»–éŠæˆ²å€å¡ŠåŒå¯¬ä¸¦ç½®æ–¼ä¸‹æ–¹ -->
        <div id="cg-rules" class="cg-rules" aria-labelledby="cg-rules-title">
          <h4 id="cg-rules-title">è¨˜æ†¶å°éŠæˆ²è¦å‰‡</h4>
          <ul>
            <li>ç¬¬ä¸€æ¬¡ç¿»é–‹çš„ç‰Œä¸å°è¨ˆåˆ†é€ æˆå½±éŸ¿ï¼Œå±¬æ–¼è¨˜æ†¶æç¤ºã€‚</li>
            <li>æ¯ç¿»é–‹å…©å¼µå¡ï¼Œè‹¥ç‚ºç›¸åŒä¸»æ’­çš„ç›¸åŒéŸ³æ•ˆå³ç‚ºé…å°ï¼Œå…±æœ‰ 8 å°é…å°ã€‚</li>
            <li>ï¼ˆä¸æœƒå‡ºç¾å¸¶æœ‰ã€Œé«’è©±ã€æˆ–ã€ŒSUSã€æ¨™ç±¤çš„èªéŸ³ï¼Œä½†æ˜¯æœƒæœ‰å°–å«ï¼Œè«‹å°å¿ƒè€³è†œã€‚ï¼‰</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- é—œæ–¼åˆ†é  -->
    <div id="page-about" class="hidden" role="tabpanel" aria-labelledby="tab-about">
      <div class="about-content">
        <p>æœ¬ç«™ç”±ç²‰è‚è£½ä½œï¼Œä¸¦éç”±å­ä¸–é†«å¸«é˜¿è¬å®˜æ–¹ç¶“ç‡Ÿã€‚éŸ³æ•ˆå…§å®¹çš†æ˜¯ç²‰è‚å»è„ˆçµ¡å¼ã€æ–·ç« å–ç¾©çš„å‰ªè¼¯ï¼Œåƒ…ä¾›å¨›æ¨‚ã€‚æœ¬ç«™çš„éŸ³æ•ˆçš†å±¬æ–¼åŸä½œè€…å­ä¸–é†«å¸«é˜¿è¬ï¼Œä½¿ç”¨æ™‚é ˆéµå®ˆå­ä¸–é†«å¸«é˜¿è¬çš„äºŒæ¬¡å‰µä½œæ¢ä¾‹ã€‚</p>
        <p>æœ€å¾Œæ›´æ–°æ™‚é–“ï¼š2025/12/7ã€‚</p>

        <p>é˜¿è¬æœ¬å®¶â†’ <a href="https://x.com/drlifesucks" target="_blank">å­ä¸–é†«å¸«é˜¿è¬X</a>ã€<a
            href="https://www.youtube.com/@Dr.lifesucks" target="_blank">å­ä¸–é†«å¸«é˜¿è¬Youtube</a> </p>
        <p><a href="https://discord.gg/e6ch4VbRB4" target="_blank">éŸ³æ•ˆæ¿å•é¡Œå›å ±èˆ‡å»ºè­°å€</a></p>
        <p>SNS Hashtagï¼š#è¬ç±Ÿèšé›†</p>
        <img src="assets/art-by-sigh.png" alt=""
          style="margin: 0 auto; max-width:100%; max-height: 250px; display: block; object-fit: cover;" />
        <p style="text-align: right;">æ’ç•«ï¼š<a href="https://x.com/sigh121212" target="_blank">Minie(Sigh)</a></p>
        <h2>å¤§å¾·èŠ³åéŒ„</h2>
        <p>æ„Ÿè¬53ã€Kieåœ¨DCå¼„äº†ä¸€å †éŸ³æ•ˆï¼Œè®“å—æƒ³åˆ°å¯ä»¥åšé€™å€‹ç¶²ç«™ï¼Œä¸¦åœ¨æå‡ºé€™å€‹æƒ³æ³•çš„ä¸€é–‹å§‹å°±å¼„äº†ä¸€å †éŸ³æ•ˆéä¾†ã€‚é‚„æœ‰åŒæ¨£æ„Ÿè¬åœ¨åŸå‹éšæ®µå°±å¹«å¿™æ”¶é›†éŸ³æ•ˆçš„ç±³ç³•è·Ÿè–°è–°è‰ã€‚
          <br />æ„Ÿè¬Jiaç¹ªè£½è¶…å¯æ„›çš„èƒŒæ™¯åœ–è·Ÿæ”¶é›†äº†å¾ˆå¤šéŸ³æ•ˆã€‚
          <br />
          <br />æ„Ÿè¬ç²‰è‚å€‘æ”¶é›†å¾ˆå¤šéŸ³æ•ˆï¼Œè±å¯Œäº†é€™å€‹ç¶²ç«™ï¼ˆWordç­†åŠƒé †ï¼‰ï¼š
          <br />AmBinBongã€CZã€HUIã€Lococco de
          suzuranã€Nokimi07ã€Sighã€TENNã€Yichenæ²‰æ²‰ã€ğŸŒ™ğŸ°æœˆæ¡‚è‘‰é¦™åŒ…â™ğŸµã€å¸ƒä¸(25:00)ã€å¹¸ç¦æŸ´æŸ´ã€é’æœ«æã€å‡Œä¼ŠLingYiï¼ˆ01ï¼‰ã€å¤ç™½è¡«ã€æ¾â–½ç±³ç²‰ è‚‰å¹²ã€è²“è²“é›¨ã€‚
          ä»¥åŠå…¶ä»–å›å ±å•é¡Œã€æå‡ºå»ºè­°çš„ç²‰è‚å€‘ï¼Œä½ å€‘è®“é€™å€‹ç¶²ç«™çš„åŠŸèƒ½æ›´å®Œå–„ã€‚
        </p>
      </div>
      <div class="bg-credit"><a href="https://x.com/jiauwu_0730" target="_blank" rel="noopener">èƒŒæ™¯æ’ç•«ç”± Jia ç¹ªè£½</a></div>

    </div>

    <!-- ç¥¨é¸çµæœåˆ†é  -->
    <div id="page-awards" class="hidden" role="tabpanel" aria-labelledby="tab-awards">
      <div style="max-width:1100px;margin:0 auto;padding:18px;">
        <h2 style="text-align:center">ç¬¬ä¸€å±†éŸ³æ•ˆæ¿çˆ­éœ¸æˆ°</h2>
        <div style="text-align:center;margin:12px 0">
          <div class="awards-grid" role="img" aria-label="ç¬¬ä¸€å±†ç²çè€…åœ–ç‰‡">
            <img src="assets/award1-1.jpg" alt="ç¬¬ä¸€å±†è²“ä¸‹å»" />
            <img src="assets/award1-2.jpg" alt="ç¬¬ä¸€å±†Matsuko" />
            <img src="assets/award1-3.jpg" alt="ç¬¬ä¸€å±†è±¹å­é ­" />
            <img src="assets/award1-4.jpg" alt="ç¬¬ä¸€å±†ç“¦å“ˆ" />
          </div>
          <h3 id="awards-top10-title">ç²çå€ï¼ˆå‰ååï¼‰</h3>
          <div id="awards-top10" class="grid" role="list" aria-labelledby="awards-top10-title"></div>
          <h3 id="awards-next20-title" style="margin-top:18px">å…¥åœçï¼ˆå¾Œ20åï¼‰</h3>
          <div id="awards-next20" class="grid" role="list" aria-labelledby="awards-next20-title"></div>
        </div>
      </div>
    </div>

    <!-- è¨­å®š Modalï¼ˆç«™å…§æ‰€æœ‰è¨­å®šï¼šéŸ³é‡ / ä¸»é¡Œé–‹é—œ ç­‰ï¼‰ -->
    <div id="settingsModal" class="modal-backdrop hidden" role="dialog" aria-modal="true"
      aria-labelledby="settingsTitle">
      <div class="modal">
        <h3 id="settingsTitle" style="margin-top: 0px;margin-bottom: 12px;">è¨­å®š</h3>
        <div style="display:flex;flex-direction:column;gap:8px;">
          <button id="themeBtn" class="btn" type="button" aria-label="åˆ‡æ›äº®è‰²/æš—è‰²ä¸»é¡Œ">é›»ç‡ˆé–‹é—œ</button>
          <label for="settingsVolume">æ’­æ”¾éŸ³é‡ï¼š <span id="settingsVolumeValue" aria-live="polite">100%</span></label>
          <input id="settingsVolume" type="range" min="0" max="100" step="1" value="100"
            aria-describedby="settingsVolumeValue" />
          <div style="display:flex;justify-content:flex-end;margin-top:6px;gap:8px;">
            <button id="settingsClose" class="btn" type="button" aria-label="é—œé–‰è¨­å®šé¢æ¿">é—œé–‰</button>
          </div>
        </div>
      </div>
    </div>

    <!-- æ’­æ”¾å½©è›‹èˆå° -->
    <div id="stage" class="stage" aria-hidden="true"></div>
    <!-- å³éµ/é•·æŒ‰é¸å–® -->
    <div id="menu" class="menu hidden" role="menu" aria-label="éŸ³æ•ˆé¸å–®"></div>
    <!-- Toastæç¤º -->
    <div id="toast" class="toast hidden" role="status" aria-live="polite"></div>

    <!-- demaPanel å¤šè»Œæ··éŸ³é¢æ¿ -->
    <div id="demaPanel" class="dema-panel" role="dialog" aria-label="å¤šè»Œæ··éŸ³ç·¨è¼¯å™¨" aria-hidden="true">
      <!-- æ§åˆ¶åˆ— -->
      <div class="dema-controls">
        <div class="dema-controls-left">
          <div class="dema-volume-wrap" id="demaClipVolumeWrap" style="display: none;">
            <input id="demaClipVolume" type="range" class="dema-volume-slider" min="0" max="150" value="100" step="5">
            <span class="dema-volume-label">ç‰‡æ®µéŸ³é‡ <span id="demaClipVolumeValue">100%</span></span>
          </div>
        </div>
        <div class="dema-controls-center">
          <button id="demaSkipBack" class="dema-btn dema-btn--icon" title="å›åˆ°ç‰‡æ®µé–‹é ­">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6 8.5 6V6z"/></svg>
          </button>
          <button id="demaPlayPause" class="dema-btn dema-btn--play" title="æ’­æ”¾/æš«åœ">
            <svg id="demaPlayIcon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
            <svg id="demaPauseIcon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="display:none"><path d="M6 4h4v16H6zM14 4h4v16h-4z"/></svg>
          </button>
          <button id="demaSkipNext" class="dema-btn dema-btn--icon" title="è·³åˆ°ä¸‹å€‹ç‰‡æ®µ">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
          </button>
        </div>
        <div class="dema-controls-right">
          <div class="dema-zoom-wrap">
            <span class="dema-zoom-label">æ™‚é–“è»¸ç¸®æ”¾</span>
            <input id="demaZoom" type="range" class="dema-zoom-slider" min="50" max="800" value="200" step="10">
          </div>
        </div>
      </div>
      <!-- éŸ³è»Œå€åŸŸ -->
      <div class="dema-tracks-wrap">
        <div id="demaTracksScroll" class="dema-tracks-scroll">
          <!-- æ™‚é–“åˆ»åº¦å°º -->
          <div class="dema-timeline">
            <canvas id="demaTimelineCanvas" class="dema-timeline-canvas"></canvas>
          </div>
          <!-- éŸ³è»Œ 1 -->
          <div class="dema-track" data-track="0">
            <div class="dema-track-label">1</div>
            <div class="dema-track-content" data-track-content="0"></div>
          </div>
          <!-- éŸ³è»Œ 2 -->
          <div class="dema-track" data-track="1">
            <div class="dema-track-label">2</div>
            <div class="dema-track-content" data-track-content="1"></div>
          </div>
          <!-- éŸ³è»Œ 3 -->
          <div class="dema-track" data-track="2">
            <div class="dema-track-label">3</div>
            <div class="dema-track-content" data-track-content="2"></div>
          </div>
          <!-- Playhead -->
          <div id="demaPlayhead" class="dema-playhead" style="left: 32px;"></div>
        </div>
        <!-- ç©ºç‹€æ…‹æç¤º -->
        <div id="demaEmpty" class="dema-empty">å³éµé»æ“ŠéŸ³æ•ˆå¡ç‰‡ï¼Œé¸æ“‡ã€ŒåŠ åˆ°éŸ³è»Œã€ä¾†é–‹å§‹æ··éŸ³</div>
      </div>
      <!-- åº•éƒ¨æ§åˆ¶åˆ— -->
      <div class="dema-controls dema-controls--bottom">
        <div class="dema-controls-left">
          <button id="demaUndo" class="dema-btn dema-btn--icon" title="å¾©åŸ (Ctrl+Z)" disabled>
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 10h10a5 5 0 0 1 5 5v2M3 10l5-5M3 10l5 5"/></svg>
          </button>
          <button id="demaRedo" class="dema-btn dema-btn--icon" title="é‡åš (Ctrl+Y)" disabled>
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10H11a5 5 0 0 0-5 5v2M21 10l-5-5M21 10l-5 5"/></svg>
          </button>
          <button id="demaClear" class="dema-btn" title="é‡ç½®æ‰€æœ‰éŸ³è»Œèˆ‡æ­¥é©Ÿç´€éŒ„">é‡ç½®</button>
          <button id="demaRemoveSelected" class="dema-btn" title="ç§»é™¤é¸å–çš„ç‰‡æ®µ (Delete)" disabled>ç§»é™¤é¸æ“‡</button>
        </div>
        <div class="dema-controls-center">
          <span id="demaTime" class="dema-time">00:00.00 / 00:00.00</span>
        </div>
        <div class="dema-controls-right">
          <button id="demaClose" class="dema-btn dema-btn--icon" title="é—œé–‰é¢æ¿">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6 6 18M6 6l12 12"/></svg>
          </button>
        </div>
      </div>
    </div>

    <script src="scripts/Sortable.min.js"></script>
    <script>
      /**
       * =============================================================================
       * é˜¿è¬èˆ‡å‹•ç‰©æœ‹å‹æŒ‰éˆ• - ä¸»æ‡‰ç”¨ç¨‹å¼
       * =============================================================================
       * 
       * å–®æª”æ¡ˆæ‡‰ç”¨æ¶æ§‹ï¼Œä½¿ç”¨ IIFE æ¨¡å¼å°è£ä»¥é¿å…å…¨åŸŸå‘½åç©ºé–“æ±¡æŸ“ã€‚
       * ä¸»è¦åŠŸèƒ½ï¼šéŸ³æ•ˆæœå°‹èˆ‡æ’­æ”¾ã€æœ€æ„›æ”¶è—ã€è¨˜æ†¶å°éŠæˆ²ã€å¤šè»Œæ··éŸ³ç·¨è¼¯ã€‚
       * 
       * ç›¸ä¾å¥—ä»¶ï¼š
       * - SortableJSï¼šæœ€æ„›æ’åºæ‹–æ”¾åŠŸèƒ½
       * 
       * æ¨¡çµ„çµæ§‹ç´¢å¼•ï¼š
       * 1. å¸¸æ•¸èˆ‡è¨­å®š
       * 2. å·¥å…·å‡½å¼
       * 3. DOM å…ƒç´ å¼•ç”¨
       * 4. æ‡‰ç”¨ç¨‹å¼ç‹€æ…‹
       * 5. éŸ³é »æ’­æ”¾æ ¸å¿ƒ
       * 6. DOM å»ºæ§‹å·¥å…·
       * 7. é€šç”¨å·¥å…·å‡½å¼
       * 8. è·¯ç”±èˆ‡ URL ç®¡ç†
       * 9. UI äº’å‹•èˆ‡äº‹ä»¶è™•ç†
       * 10. UI æ¸²æŸ“å‡½å¼
       * 11. åˆå§‹åŒ–æµç¨‹
       * 12. è¨˜æ†¶å°éŠæˆ²
       * 13. demaPanel å¤šè»Œæ··éŸ³ç·¨è¼¯å™¨
       * =============================================================================
       */
      (function () {
        'use strict';

        /* =======================================================================
           1. å¸¸æ•¸èˆ‡è¨­å®š
           ======================================================================= */

        /**
         * æª”æ¡ˆç‰ˆæœ¬å­—ä¸²ï¼šæ¯æ¬¡éƒ¨ç½²è®Šæ›´æ­¤å€¼ï¼Œå¯ç¢ºä¿æŠ“å–æœ€æ–°è³‡æ–™ä¸¦å¼·åˆ¶ CDN/ç€è¦½å™¨é‡æ–°è¼‰å…¥ã€‚
         * @const {string}
         */
        const VERSION = 'ver2025-12-7';

        /**
         * æ‡‰ç”¨ç¨‹å¼è¨­å®šï¼šé›†ä¸­ç®¡ç†å¯èª¿æ•´çš„è¨­å®šå€¼ã€‚
         * @const {Object}
         */
        const CONFIG = {
          // è³‡æ–™ä¾†æºè·¯å¾‘
          paths: {
            tags: 'config/tags.json',
            sounds: 'config/sounds.json',
            voteResults: 'config/vote-results.json'
          },

          // localStorage éµå
          storage: {
            favorites: 'favorites',
            favoritesVersion: 'favorites_version',
            favoritesBackup: 'favorites_legacy_backup',
            theme: 'theme',
            globalVolume: 'globalVolume'
          },

          // UI æ™‚é–“è¨­å®šï¼ˆæ¯«ç§’ï¼‰
          timing: {
            toastDuration: 2500,           // Toast é¡¯ç¤ºæ™‚é•·
            longPressDelay: 400,           // é•·æŒ‰è§¸ç™¼é¸å–®å»¶é²
            searchDebounce: 180,           // æœå°‹é˜²æŠ–å»¶é²
            animationDelay: 60,            // é ­åƒå‹•ç•«å»¶é²é–“éš”
            hopOutDelay: 90                // é ­åƒé›¢å ´å‹•ç•«å»¶é²
          },

          // UI æ¸²æŸ“è¨­å®š
          ui: {
            batchSize: 72                  // æ¯æ¬¡æ¸²æŸ“çš„å¡ç‰‡æ•¸é‡ (6æ¬„ x 12åˆ—)
          },

          // ç¥¨é¸ç›¸é—œ
          awards: {
            topRankCount: 30,              // è®€å–å‰ N å
            top10Count: 10,                // é¡¯ç¤ºç‚ºå‰ 10 å
            next20Count: 20                // é¡¯ç¤ºç‚ºå…¥åœç
          },

          // è¨˜æ†¶éŠæˆ²ç›¸é—œ
          game: {
            pairCount: 8,                  // é…å°æ•¸é‡
            cardFlipDelay: 500,            // ç¿»ç‰Œæª¢æŸ¥å»¶é²
            rewardAccuracy: 90,            // è§¸ç™¼çå‹µçš„æº–ç¢ºç‡é–€æª»
            rewardSoundIds: ['c4B1fg', 'Hv3yFA', 'JkJ9-A', '5VHtAg']
          },

          // é è¨­é¡è‰²
          colors: {
            defaultTag: '#94a3b8'          // é è¨­æ¨™ç±¤è‰²
          }
        };

        /**
         * UI è¨Šæ¯æ–‡å­—ï¼šé›†ä¸­ç®¡ç†é¡¯ç¤ºçµ¦ä½¿ç”¨è€…çš„æ–‡å­—ã€‚
         * @const {Object}
         */
        const MESSAGES = {
          // Toast è¨Šæ¯
          toast: {
            linkCopied: 'å·²è¤‡è£½åˆ†äº«é€£çµ',
            listLinkCopied: 'å·²è¤‡è£½åˆ†äº«æœ€æ„›åˆ—è¡¨é€£çµ',
            noFavorites: 'æ²’æœ‰æœ€æ„›å¯åˆ†äº«',
            sortingSaved: 'å·²å„²å­˜æœ€æ„›æ’åº',
            sortingBlocked: 'æ­£åœ¨ç·¨è¼¯æœ€æ„›æ’åºï¼Œç„¡æ³•è®Šæ›´æœ€æ„›',
            favMigrated: (count, missing) => `å·²å‡ç´šæœ€æ„›æ ¼å¼ï¼Œå…± ${count} ç­†${missing ? `ï¼›æœªåŒ¹é… ${missing} ç­†` : ''}ã€‚`,
            gameReward: 'ä½ æ˜¯è¨˜æ†¶çŒ›è‚'
          },

          // éŒ¯èª¤è¨Šæ¯
          errors: {
            configLoadFailed: 'è¼‰å…¥è¨­å®šæª”å¤±æ•—ï¼Œè«‹ç¢ºèª <code>config/</code> è·¯å¾‘æ˜¯å¦æ­£ç¢ºã€‚',
            gameNoSounds: 'ç›®å‰æ²’æœ‰è¶³å¤ çš„éŸ³æ•ˆå¯ä¾›é…å°ï¼ˆéœ€è‡³å°‘ 1 çµ„ï¼‰ã€‚è«‹å›åˆ°ä¸»é æˆ–ç¨å¾Œå†è©¦ã€‚'
          },

          // ç©ºç‹€æ…‹æç¤º
          empty: {
            noFavorites: 'é‚„æ²’æœ‰æœ€æ„›ã€‚é»éŸ³æ•ˆå³ä¸Šçš„ â¤ï¸ åŠ å…¥æœ€æ„›ã€‚',
            noResults: 'æ²’æœ‰ç¬¦åˆæœå°‹çš„éŸ³æ•ˆã€‚'
          }
        };

        /* =======================================================================
           2. å·¥å…·å‡½å¼
           ======================================================================= */

        /** ç‚º URL é™„åŠ ç‰ˆæœ¬å­—ä¸² */
        const withV = url => url + (url.includes('?') ? '&' : '?') + 'v=' + encodeURIComponent(VERSION);

        /** Fisher-Yates æ´—ç‰Œæ¼”ç®—æ³• */
        function shuffleInPlace(arr, rng = Math.random) {
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(rng() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr;
        }

        /* =======================================================================
           3. DOM å…ƒç´ å¼•ç”¨
           ======================================================================= */

        /** DOM å…ƒç´ å¿«å–ç‰©ä»¶ */
        const els = {
          q: document.getElementById('q'),
          activeChips: document.getElementById('activeChips'),
          clearBtn: document.getElementById('clearBtn'),
          tagList: document.getElementById('tagList'),
          grid: document.getElementById('grid'),
          favGrid: document.getElementById('favGrid'),
          empty: document.getElementById('empty'),
          favEmpty: document.getElementById('favEmpty'),
          settingsBtn: document.getElementById('settingsBtn'),
          themeBtn: document.getElementById('themeBtn'),
          stage: document.getElementById('stage'),
          navToggle: document.getElementById('navToggle'),
          get menu() { return document.getElementById('menu'); },
          get toast() { return document.getElementById('toast'); },
          get navTabs() { return document.querySelectorAll('.tab[data-page]'); },
          // åˆ†é èˆ‡è¨­å®š
          pageHome: document.getElementById('page-home'),
          pageGame: document.getElementById('page-game'),
          pageAbout: document.getElementById('page-about'),
          pageawards: document.getElementById('page-awards'),
          settingsModal: document.getElementById('settingsModal'),
          settingsClose: document.getElementById('settingsClose'),
          settingsVolume: document.getElementById('settingsVolume'),
          settingsVolumeValue: document.getElementById('settingsVolumeValue'),
          receivedSection: document.getElementById('receivedSection'),
          receivedGrid: document.getElementById('receivedGrid'),
          awardsTop10: document.getElementById('awards-top10'),
          awardsNext20: document.getElementById('awards-next20'),
          sortFavBtn: document.getElementById('sortFavBtn'),
          doneSortBtn: document.getElementById('doneSortBtn'),
          shareFavBtn: document.getElementById('shareFavBtn'),
          shuffleBtn: document.getElementById('shuffleBtn'),
          resetOrderBtn: document.getElementById('resetOrderBtn'),
          openDemaBtn: document.getElementById('openDemaBtn'),
          // demaPanel å…ƒç´ 
          demaPanel: document.getElementById('demaPanel'),
          demaUndo: document.getElementById('demaUndo'),
          demaRedo: document.getElementById('demaRedo'),
          demaPlayPause: document.getElementById('demaPlayPause'),
          demaPlayIcon: document.getElementById('demaPlayIcon'),
          demaPauseIcon: document.getElementById('demaPauseIcon'),
          demaSkipBack: document.getElementById('demaSkipBack'),
          demaSkipNext: document.getElementById('demaSkipNext'),
          demaTime: document.getElementById('demaTime'),
          demaZoom: document.getElementById('demaZoom'),
          demaClear: document.getElementById('demaClear'),
          demaRemoveSelected: document.getElementById('demaRemoveSelected'),
          demaClose: document.getElementById('demaClose'),
          demaTracksScroll: document.getElementById('demaTracksScroll'),
          demaTimelineCanvas: document.getElementById('demaTimelineCanvas'),
          demaPlayhead: document.getElementById('demaPlayhead'),
          demaEmpty: document.getElementById('demaEmpty'),
          get demaTrackContents() { return document.querySelectorAll('[data-track-content]'); },
          // ç‰‡æ®µéŸ³é‡æ§åˆ¶
          demaClipVolumeWrap: document.getElementById('demaClipVolumeWrap'),
          demaClipVolume: document.getElementById('demaClipVolume'),
          demaClipVolumeValue: document.getElementById('demaClipVolumeValue')
        };

        /* =======================================================================
           4. æ‡‰ç”¨ç¨‹å¼ç‹€æ…‹
           ======================================================================= */

        /** å…¨åŸŸæ‡‰ç”¨ç¨‹å¼ç‹€æ…‹ç‰©ä»¶ */
        const state = {
          tags: {},
          tagList: [],
          usedTagList: [],
          sounds: [],
          soundMap: new Map(),
          defaultSoundsSnapshot: [],
          favorites: JSON.parse(localStorage.getItem(CONFIG.storage.favorites) || '[]'),
          favSet: new Set(),
          isSorting: false,
          sortable: null,
          queryText: '',
          queryTags: new Set(),
          page: 'home',
          contextTimer: null,
          toastTimer: null,
          highlightedCardId: '',
          receivedList: [],
          cgRunning: false,
          // è™›æ“¬æ»¾å‹•/åˆ†æ‰¹æ¸²æŸ“ç‹€æ…‹
          displayList: [],
          renderedCount: 0,
          observer: null
        };

        state.favSet = new Set(state.favorites);
        state.globalVolume = (() => {
          const v = localStorage.getItem(CONFIG.storage.globalVolume);
          const n = Number(v);
          return (v !== null && !isNaN(n) && n >= 0 && n <= 1) ? n : 1.0;
        })();

        let cgCleanup = null;

        /* =======================================================================
           5. éŸ³é »æ’­æ”¾æ ¸å¿ƒ
           ======================================================================= */

        /** å°‡å…¨åŸŸéŸ³é‡è¨­å®šå¥—ç”¨åˆ° Audio å…ƒç´  */
        const applyVolumeToAudio = a => {
          try {
            a && (a.volume = state.globalVolume);
          } catch (e) {
            console.warn('[applyVolumeToAudio] è¨­å®šéŸ³é‡å¤±æ•—', e);
          }
        };

        /** å»ºç«‹ Audio æ’­æ”¾å™¨ä¸¦å•Ÿå‹•æ’­æ”¾ */
        function createPlayer(src, opts = {}) {
          const { snd, onPlay, onEnded, preload = 'auto', loop = false, autoplay = true } = opts;
          try {
            const audio = new Audio(src);
            Object.assign(audio, { preload, loop });
            onPlay && audio.addEventListener('play', () => onPlay(snd, audio));
            onEnded && audio.addEventListener('ended', () => onEnded(snd, audio));
            applyVolumeToAudio(audio);
            // è‡ªå‹•æ’­æ”¾å¯èƒ½è¢«ç€è¦½å™¨æ”¿ç­–é˜»æ“‹ï¼ˆå¦‚ç„¡ä½¿ç”¨è€…äº’å‹•ï¼‰ï¼Œéœé»˜è™•ç†
            autoplay && audio.play().catch(() => { /* é æœŸè¡Œç‚ºï¼šç€è¦½å™¨è‡ªå‹•æ’­æ”¾æ”¿ç­– */ });
            return audio;
          } catch (e) {
            console.warn('[createPlayer] failed', e);
            return null;
          }
        }

        /** ä»¥ Sound ç‰©ä»¶æ’­æ”¾éŸ³æ•ˆï¼ŒåŒæ™‚è§¸ç™¼èˆå°é ­åƒå‹•ç•« */
        const playSoundObject = snd => snd?.src ? createPlayer(snd.src, { snd, onPlay: onPlayStart, onEnded: onPlayEnd }) : null;

        /* =======================================================================
           6. DOM å»ºæ§‹å·¥å…·
           ======================================================================= */

        /**
         * DOM å…ƒç´ å»ºæ§‹å·¥å…·é›†
         */
        const dom = {
          /**
           * å»ºç«‹ DOM å…ƒç´ ã€‚
           * @param {string} tag - æ¨™ç±¤åç¨±
           * @param {Object} attrs - å±¬æ€§ç‰©ä»¶
           * @param {Array|string} children - å­ç¯€é»
           * @returns {HTMLElement}
           */
          el(tag, attrs = {}, children = []) {
            const e = document.createElement(tag);
            for (const [k, v] of Object.entries(attrs)) {
              if (k === 'class') e.className = v;
              else if (k === 'style') Object.assign(e.style, v);
              else if (k.startsWith('on') && typeof v === 'function') e.addEventListener(k.slice(2), v);
              else if (v != null) e.setAttribute(k, v);
            }
            for (const c of [].concat(children).filter(Boolean)) {
              e.append(c);
            }
            return e;
          },

          /** å»ºç«‹æ„›å¿ƒ SVG åœ–ç¤º */
          svgHeart() {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.innerHTML = '<path d="M12 21s-6.716-4.438-9.428-7.15C.59 11.868.59 8.608 2.57 6.627 4.55 4.647 7.81 4.647 9.79 6.627L12 8.838l2.21-2.21c1.98-1.98 5.24-1.98 7.22 0 1.98 1.98 1.98 5.24 0 7.223C18.716 16.562 12 21 12 21z" fill="none" stroke="currentColor" stroke-width="1.5"/>';
            return svg;
          }
        };

        /* =======================================================================
           7. é€šç”¨å·¥å…·å‡½å¼
           ======================================================================= */

        /**
         * é€šç”¨å·¥å…·å‡½å¼é›†åˆ
         */
        const utils = {
          /** æ­£è¦åŒ–å­—ä¸²ï¼šUnicode NFKC */
          slug: s => s.normalize('NFKC').trim(),

          /** æ ¹æ“š ID å–å¾— DOM å…ƒç´  */
          byId: id => document.getElementById(id),

          /** å„²å­˜æœ€æ„›åˆ—è¡¨åˆ° localStorage */
          saveFav: () => localStorage.setItem(CONFIG.storage.favorites, JSON.stringify(state.favorites)),

          /** æª¢æŸ¥éŸ³æ•ˆæ˜¯å¦åœ¨æœ€æ„›åˆ—è¡¨ä¸­ */
          inFav: id => state.favSet.has(id),

          /** è§¸ç™¼æª”æ¡ˆä¸‹è¼‰ */
          download(url, filename) {
            const a = Object.assign(document.createElement('a'), { href: url, download: filename || '' });
            document.body.appendChild(a);
            a.click();
            a.remove();
          },

          /**
           * è§£ææœå°‹æŸ¥è©¢å­—ä¸²ç‚ºçµæ§‹åŒ–ç‰©ä»¶ã€‚
           * 
           * @returns {Object} { terms: Array<string>, tags: Set<string> }
           */
          parseQuery() {
            const parts = state.queryText.trim().split(/\s+/).filter(Boolean);
            const tags = new Set([...state.queryTags]); // ä¿ç•™å·²é¸æ¨™ç±¤
            const terms = [];
            for (const p of parts) {
              if (p.startsWith('#')) {
                // æå– #ç¬¦è™Ÿå¾Œçš„æ¨™ç±¤ keyï¼Œä¸¦ slug åŒ–
                tags.add(utils.slug(p.slice(1)));
              } else {
                // ä¸€èˆ¬æœå°‹è©
                terms.push(utils.slug(p));
              }
            }
            return { terms, tags };
          },

          /**
           * åˆ¤æ–·å–®å€‹éŸ³æ•ˆæ˜¯å¦ç¬¦åˆæœå°‹æ¢ä»¶ã€‚
           * 
           * è¦å‰‡ï¼š
           * 1. tags éæ¿¾ï¼šéŸ³æ•ˆå¿…é ˆåŒ…å«æ‰€æœ‰å·²é¸æ¨™ç±¤ï¼ˆsubset checkï¼‰
           * 2. text éæ¿¾ï¼šéŸ³æ•ˆæ¨™é¡Œæˆ–æ¨™ç±¤å¿…é ˆåŒ…å«æ‰€æœ‰æœå°‹è©ï¼ˆcase-insensitiveï¼‰
           * 
           * @param {Object} sound - éŸ³æ•ˆç‰©ä»¶
           * @param {Array<string>} terms - æœå°‹è©é™£åˆ—ï¼ˆå·²æå–çš„æ–‡å­—éƒ¨ä»½ï¼‰
           * @param {Set<string>} tags - å·²é¸æ¨™ç±¤çš„ keyï¼ˆå·² slug åŒ–ï¼‰
           * @returns {boolean} æ˜¯å¦ç¬¦åˆæ¢ä»¶
           */
          match(sound, terms, tags) {
            const lowerTitle = sound.title.toLowerCase();
            const sluggedTags = sound.tags.map(t => utils.slug(t));
            // tags éæ¿¾ï¼šæª¢æŸ¥æ‰€æœ‰å·²é¸æ¨™ç±¤æ˜¯å¦éƒ½åœ¨éŸ³æ•ˆçš„æ¨™ç±¤æ¸…å–®ä¸­
            for (const t of tags) if (!sluggedTags.includes(t)) return false;
            // terms éæ¿¾ï¼šæª¢æŸ¥æ‰€æœ‰æœå°‹è©æ˜¯å¦éƒ½èƒ½åœ¨æ¨™é¡Œæˆ–æ¨™ç±¤ä¸­æ‰¾åˆ°
            for (const term of terms) {
              const lower = term.toLowerCase();
              if (!lowerTitle.includes(lower) && !sound.tags.some(t => t.toLowerCase().includes(lower))) return false;
            }
            return true;
          },

          /** å»ºç«‹é˜²æŠ–å‡½å¼ */
          debounce(fn, wait = 200) {
            let t;
            return (...args) => {
              clearTimeout(t);
              t = setTimeout(() => fn(...args), wait);
            };
          }
        };

        /* =======================================================================
           8. è·¯ç”±èˆ‡ URL ç®¡ç†
           
           è™•ç†ç€è¦½å™¨æ­·å²ã€æ·±é€£çµåˆ†äº«ã€æœå°‹æ¢ä»¶åŒæ­¥ã€‚
           ======================================================================= */

        /**
         * å°‡ç•¶å‰æœå°‹æ¢ä»¶å°è£ç‚º URLSearchParamsã€‚
         * @returns {URLSearchParams}
         */
        function buildSearchParams() {
          const { terms, tags } = utils.parseQuery();
          const params = new URLSearchParams(window.location.search);
          if (terms.length) params.set('q', terms.join(' ')); else params.delete('q');
          if (tags.size) params.set('tags', [...tags].join(',')); else params.delete('tags');
          params.delete('sound'); // ä¿®æ”¹æœå°‹æ™‚æ¸…é™¤éŸ³æ•ˆæ·±é€£çµ
          return params;
        }

        /**
         * å°‡ç‹€æ…‹å¯«å› URLã€‚
         * @param {boolean} push - è‹¥ç‚º true å‰‡ä½¿ç”¨ history.pushStateï¼Œå¦å‰‡ä½¿ç”¨ replaceState
         */
        function updateURLFromState(push = false) {
          const params = buildSearchParams();
          // ä¿ç•™ list åƒæ•¸ï¼ˆåˆ†äº«æ”¶åˆ°çš„åˆ—è¡¨ï¼‰è‹¥å­˜åœ¨
          const current = new URLSearchParams(location.search);
          if (current.has('list')) params.set('list', current.get('list'));
          // ä¿ç•™ sound åƒæ•¸ä»¥ç¢ºä¿åˆ†äº«é€£çµæ­£å¸¸é‹ä½œ
          if (current.has('sound')) params.set('sound', current.get('sound'));
          // åŠ ä¸Š page åƒæ•¸ï¼ˆéé¦–é æ‰å¯«å…¥ï¼‰
          if (state.page && state.page !== 'home') params.set('page', state.page); else params.delete('page');
          const qs = params.toString();
          const url = `${location.pathname}${qs ? '?' + qs : ''}`;
          (push ? history.pushState : history.replaceState).call(history, null, '', url);
        }

        /**
         * å¾ç¾æœ‰ URL è®€å–æœå°‹æ¢ä»¶ä¸¦å¥—ç”¨åˆ°ç‹€æ…‹èˆ‡è¼¸å…¥æ¡†ã€‚
         */
        function applyURLToState() {
          const params = new URLSearchParams(location.search);
          const q = params.get('q') || '';
          const tagsParam = params.get('tags') || '';
          state.queryTags.clear();
          const keys = tagsParam.split(',').map(k => utils.slug(k)).filter(Boolean);
          keys.forEach(k => state.queryTags.add(k));
          state.queryText = q;
          // åŒæ­¥è¼¸å…¥æ¡†æ–‡å­—
          const tagTokens = keys.map(k => '#' + (state.tags[k]?.name || k));
          els.q.value = [q, ...tagTokens].filter(Boolean).join(' ');
          // åˆ†é ï¼šè®€å– page åƒæ•¸
          const pageParam = params.get('page');
          state.page = ['game', 'about', 'awards'].includes(pageParam) ? pageParam : 'home';
          // åˆ†äº«åˆ—è¡¨ï¼šè®€å– list åƒæ•¸
          state.receivedList = params.get('list')?.split(',').filter(Boolean) ?? [];
        }

        /**
         * è‹¥ URL æœ‰ ?sound=<id>ï¼Œå‰‡èšç„¦ä¸¦é«˜äº®è©²å¡ç‰‡ã€‚
         */
        function focusSoundFromURL() {
          const id = new URLSearchParams(location.search).get('sound');
          if (!id) return;
          const card = utils.byId('snd-' + id);
          if (!card) return;
          card.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // ç§»é™¤èˆŠçš„é«˜äº®
          if (state.highlightedCardId) utils.byId('snd-' + state.highlightedCardId)?.classList.remove('glow-persistent');
          state.highlightedCardId = id;
          card.classList.add('glow-persistent');
        }

        // popstate äº‹ä»¶ï¼šè¿”å›/å‰é€²æ™‚è¼‰å…¥ URL æ¢ä»¶
        window.addEventListener('popstate', () => {
          applyURLToState();
          render();
          focusSoundFromURL();
        });

        /** å»ºç«‹åƒ…åŒ…å« sound id çš„åˆ†äº«é€£çµ */
        function buildSoundURL(id) {
          const base = location.href.replace(/[?#].*$/, '');
          return `${base}?sound=${encodeURIComponent(id)}`;
        }

        /** å»ºç«‹åˆ†äº«åˆ—è¡¨çš„ URLï¼šåŠ å…¥ list åƒæ•¸ï¼Œä½¿ç”¨é€—è™Ÿåˆ†éš”çš„ id åˆ—è¡¨ã€‚ */
        function buildListURL(ids) {
          const params = buildSearchParams();
          ids?.length ? params.set('list', ids.join(',')) : params.delete('list');
          params.delete('sound');
          const qs = params.toString();
          return `${location.origin}${location.pathname}${qs ? '?' + qs : ''}`;
        }

        /* =======================================================================
           9. UI äº’å‹•èˆ‡äº‹ä»¶è™•ç†
           
           é é¢åˆ‡æ›ã€é¸å–®æ“ä½œã€ä¸»é¡Œåˆ‡æ›ã€ä½¿ç”¨è€…äº’å‹•ã€‚
           ======================================================================= */

        /** æ ¹æ“š ID æ’­æ”¾éŸ³æ•ˆ */
        const playSoundById = id => { const snd = state.soundMap.get(id); snd && playSoundObject(snd); };

        /**
         * åˆ‡æ›é é¢ï¼šæ ¹æ“š page åç¨±é¡¯ç¤ºä¸åŒå…§å®¹ï¼Œä¸¦æ›´æ–°ç¶²å€åƒæ•¸èˆ‡å°è¦½æ¨£å¼
         * @param {'home'|'game'|'about'} pg
         */
        const pageMap = { home: 'pageHome', game: 'pageGame', about: 'pageAbout', awards: 'pageawards' };
        /** è§¸ç™¼é é¢åˆ‡æ›äº‹ä»¶ */
        const dispatchPageEvent = (pg, prevPage, phase) => {
          try {
            document.dispatchEvent(new CustomEvent('pageChange', { detail: { page: pg, prevPage, phase } }));
          } catch (e) {
            console.warn('[dispatchPageEvent] äº‹ä»¶æ´¾ç™¼å¤±æ•—', e);
          }
        };
        function showPage(pg) {
          const prevPage = state.page;
          dispatchPageEvent(pg, prevPage, 'before');
          state.page = pg;
          // éš±è—æ‰€æœ‰åˆ†é ï¼Œé¡¯ç¤ºç›®æ¨™åˆ†é 
          for (const [key, elKey] of Object.entries(pageMap)) els[elKey]?.classList.toggle('hidden', key !== pg);
          // æ›´æ–°å°è¦½æ¨™ç±¤ active æ¨£å¼èˆ‡ ARIA ç‹€æ…‹
          els.navTabs.forEach(tab => {
            const isActive = tab.getAttribute('data-page') === pg;
            tab.classList.toggle('active', isActive);
            if (tab.getAttribute('role') === 'tab') tab.setAttribute('aria-selected', String(isActive));
          });
          document.body.classList.toggle('bg-full', pg === 'about');
          document.body.classList.remove('nav-open');
          els.navToggle?.setAttribute('aria-expanded', 'false');
          updateURLFromState(true);
          dispatchPageEvent(pg, prevPage, 'after');
        }

        /**
         * æ¸²æŸ“æ¨™ç±¤ä¸€è¦½ï¼šåˆ—å‡ºæ‰€æœ‰ä½¿ç”¨åˆ°çš„æ¨™ç±¤
         */
        function renderTagList() {
          const container = els.tagList;
          if (!container) return;
          container.innerHTML = '';
          state.usedTagList.forEach(t => {
            const el = dom.el('span', { class: 'tag', style: { background: t.color || '#94a3b8' } }, t.name);
            el.addEventListener('click', () => addTagToQuery(t.key));
            container.appendChild(el);
          });
        }

        /** è¤‡è£½æ–‡å­—åˆ°å‰ªè²¼ç°¿ */
        const copyToClipboard = text => navigator.clipboard?.writeText(text).catch(() => legacyCopy(text)) ?? legacyCopy(text);
        function legacyCopy(text) {
          const ta = Object.assign(document.createElement('textarea'), { value: text, style: 'position:fixed;left:-9999px' });
          document.body.appendChild(ta); ta.select();
          try {
            document.execCommand('copy');
          } catch {
            // execCommand å·²æ£„ç”¨ï¼ŒæŸäº›ç€è¦½å™¨å¯èƒ½ä¸æ”¯æ´
            console.warn('[legacyCopy] execCommand ä¸æ”¯æ´');
          }
          ta.remove();
          return Promise.resolve();
        }

        /** Toast æç¤ºé¡¯ç¤ºå°è³‡è¨Š */
        function toast(msg, duration = CONFIG.timing.toastDuration) {
          const t = els.toast;
          if (!t) return;
          clearTimeout(state.toastTimer);
          t.textContent = msg;
          t.classList.remove('hidden');
          if (duration > 0) state.toastTimer = setTimeout(() => t.classList.add('hidden'), duration);
        }

        /** æ‰“é–‹éŸ³æ•ˆçš„å³éµ/é•·æŒ‰é¸å–® */
        function openMenuForSound(snd, x, y) {
          const m = els.menu;
          if (!m) return;
          m.innerHTML = '';
          // åŠ åˆ°éŸ³è»Œé …ç›®
          const addTrack = dom.el('div', { class: 'menu-item', role: 'menuitem', tabindex: '0' }, 'åŠ åˆ°éŸ³è»Œ');
          addTrack.addEventListener('click', () => {
            closeMenu();
            if (typeof demaPanel !== 'undefined' && demaPanel.addSoundToTrack) {
              demaPanel.addSoundToTrack(snd);
            }
          });
          // åˆ†äº«ç¶²å€é …ç›®
          const share = dom.el('div', { class: 'menu-item', role: 'menuitem', tabindex: '0' }, 'åˆ†äº«ç¶²å€');
          share.addEventListener('click', async () => {
            await copyToClipboard(buildSoundURL(snd.id));
            closeMenu();
            toast(MESSAGES.toast.linkCopied);
          });
          // ä¸‹è¼‰éŸ³æª”é …ç›®
          const dl = dom.el('div', { class: 'menu-item', role: 'menuitem', tabindex: '0' }, 'ä¸‹è¼‰éŸ³æª”');
          dl.addEventListener('click', () => { closeMenu(); utils.download(snd.src, snd.file); });
          m.append(addTrack, share, dl);
          m.classList.remove('hidden');
          // å®šä½é¸å–®ï¼šç¢ºä¿å…ƒç´ æœ‰å°ºå¯¸å¾Œå†è¨ˆç®—
          requestAnimationFrame(() => positionMenu(x, y));
        }

        /** å®šä½é¸å–®åœ¨è¦–çª—å…§ */
        function positionMenu(x, y) {
          const m = els.menu;
          if (!m) return;
          const pad = 6;
          const w = m.offsetWidth || 180;
          const h = m.offsetHeight || 100;
          const vw = window.innerWidth, vh = window.innerHeight;
          m.style.left = Math.min(Math.max(0, x), vw - w - pad) + 'px';
          m.style.top = Math.min(Math.max(0, y), vh - h - pad) + 'px';
        }

        /** é—œé–‰é¸å–® */
        const closeMenu = () => { const m = els.menu; if (m) { m.classList.add('hidden'); m.innerHTML = ''; } };
        // é»æ“Šå¤–éƒ¨æˆ–æŒ‰ ESC é—œé–‰é¸å–®
        document.addEventListener('click', e => { if (els.menu && !els.menu.classList.contains('hidden') && !els.menu.contains(e.target)) closeMenu(); });
        document.addEventListener('keydown', e => { if (e.key === 'Escape') closeMenu(); });
        window.addEventListener('resize', closeMenu);

        /** åˆ‡æ›ä¸»é¡Œ */
        /** å¥—ç”¨ä¸»é¡Œæ¨£å¼ï¼Œæš«æ™‚åœç”¨ transition ä»¥é¿å…åˆ‡æ›æ™‚çš„ lag */
        const applyTheme = theme => {
          document.body.classList.add('no-transition');
          document.documentElement.classList.toggle('light', theme === 'light');
          // å¼·åˆ¶ reflow å¾Œæ¢å¾© transition
          document.body.offsetHeight;
          document.body.classList.remove('no-transition');
        };
        const savedTheme = localStorage.getItem(CONFIG.storage.theme) || (matchMedia('(prefers-color-scheme:light)').matches ? 'light' : 'dark');
        applyTheme(savedTheme);
        els.themeBtn.addEventListener('click', () => {
          const next = document.documentElement.classList.contains('light') ? 'dark' : 'light';
          if (next === 'dark') playSoundById('oNTWqg'); // ç“¦å“ˆéŸ³æ•ˆï¼šé–‹ç‡ˆå•Š
          localStorage.setItem(CONFIG.storage.theme, next);
          applyTheme(next);
        });

        // è¨­å®š Modal è¡Œç‚º
        
        /** é¡¯ç¤º/éš±è— Modal ä¸¦è¨­å®šç„¦é» */
        const setModalVisible = (modal, visible, focusEl) => {
          if (!modal) return;
          modal.classList.toggle('hidden', !visible);
          modal.setAttribute('aria-hidden', String(!visible));
          if (focusEl) {
            try {
              focusEl.focus();
            } catch {
              // ç„¦é»è¨­å®šå¤±æ•—ä¸å½±éŸ¿åŠŸèƒ½ï¼Œå¯èƒ½æ˜¯å…ƒç´ ä¸å¯è¦‹æˆ–å·²ç§»é™¤
            }
          }
        };

        /** éš±è—è¨­å®šé¢æ¿ */
        const hideSettings = () => setModalVisible(els.settingsModal, false);
        /** æª¢æŸ¥è¨­å®šé¢æ¿æ˜¯å¦é–‹å•Ÿ */
        const isSettingsOpen = () => els.settingsModal && !els.settingsModal.classList.contains('hidden');

        /** æ›´æ–°æ··éŸ³ä¸»éŸ³é‡ */
        const updateMixMasterGain = norm => {
          const gain = mixAudio?.masterGain?.gain;
          if (!gain) return;
          try {
            gain.value = norm;
          } catch (e) {
            console.warn('[updateMixMasterGain] ç›´æ¥è¨­å®šå¤±æ•—ï¼Œå˜—è©¦ rampTo', e);
            gain.rampTo?.(norm, 0.02);
          }
        };

        els.settingsBtn?.addEventListener('click', e => {
          e.preventDefault();
          setModalVisible(els.settingsModal, true);
          const vol = Math.round((state.globalVolume ?? 1) * 100);
          if (els.settingsVolume) els.settingsVolume.value = String(vol);
          if (els.settingsVolumeValue) els.settingsVolumeValue.textContent = `${vol}%`;
        });

        els.settingsClose?.addEventListener('click', hideSettings);
        document.addEventListener('click', e => { if (isSettingsOpen() && e.target === els.settingsModal) hideSettings(); });
        document.addEventListener('keydown', e => { if (e.key === 'Escape' && isSettingsOpen()) hideSettings(); });

        els.settingsVolume?.addEventListener('input', () => {
          const norm = Math.max(0, Math.min(100, Number(els.settingsVolume.value) || 0)) / 100;
          state.globalVolume = norm;
          try {
            localStorage.setItem(CONFIG.storage.globalVolume, String(norm));
          } catch (e) {
            console.warn('[settings] å„²å­˜éŸ³é‡è¨­å®šå¤±æ•—', e);
          }
          if (els.settingsVolumeValue) els.settingsVolumeValue.textContent = `${Math.round(norm * 100)}%`;
          updateMixMasterGain(norm);
        });

        /** æ’­æ”¾å½©è›‹ï¼šéŸ³æ•ˆé–‹å§‹æ™‚é¡¯ç¤ºä¸»æ’­é ­åƒ */
        const activeGroups = new Set();
        function onPlayStart(snd, audio) {
          const streamerTags = snd.tags.map(k => state.tags[utils.slug(k)]).filter(t => t?.role === 'streamer' && t.avatar);
          if (!streamerTags.length) return;
          const group = dom.el('div', { class: 'group' });
          activeGroups.add(group);
          streamerTags.forEach((t, i) => {
            const avatar = dom.el('div', { class: 'avatar pop-in jit', style: { animationDelay: `${i * 60}ms` } }, [
              dom.el('img', { src: withV(t.avatar), alt: t.name })
            ]);
            group.appendChild(avatar);
          });
          els.stage.appendChild(group);
          audio.__group = group;
        }
        /** æ’­æ”¾å½©è›‹ï¼šéŸ³æ•ˆçµæŸæ™‚æ’­æ”¾é ­åƒé›¢å ´å‹•ç•« */
        function onPlayEnd(_snd, audio) {
          const group = audio.__group;
          if (!group) return;
          [...group.children].forEach((av, i) => {
            av.classList.remove('jit');
            setTimeout(() => {
              av.classList.add('hop-out');
              av.onanimationend = () => { av.remove(); group.childElementCount === 0 && (group.remove(), activeGroups.delete(group)); };
            }, i * CONFIG.timing.hopOutDelay);
          });
        }

        /** ===== Favorites schema migration: file -> id (v1 -> v2) ===== */
        const ID_REGEX = /^[A-Za-z0-9_-]{6}$/;

        /** è§£æèˆŠç‰ˆæœ€æ„›è³‡æ–™ç‚ºå­—ä¸²é™£åˆ— */
        function parseLegacyFavorites(raw) {
          if (!raw) return [];
          try {
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) return parsed.map(String);
            if (parsed && typeof parsed === 'object') return Object.keys(parsed).filter(k => parsed[k]).map(String);
          } catch {
            // é æœŸè¡Œç‚ºï¼šé JSON æ ¼å¼ï¼Œæ”¯æ´ç”¨é€—è™Ÿ/ç©ºç™½åˆ†éš”çš„èˆŠæ ¼å¼
            return typeof raw === 'string' ? raw.split(/[,\s]+/).map(s => s.trim()).filter(Boolean) : [];
          }
          return [];
        }

        /** æ­£è¦åŒ–æª”æ¡ˆè·¯å¾‘ä½œç‚ºæŸ¥æ‰¾éµå€¼ */
        const canonFileKey = s => {
          if (!s) return '';
          let k = String(s).split('?')[0].replace(/^\.?\//, '');
          try {
            k = decodeURIComponent(k);
          } catch {
            // é æœŸè¡Œç‚ºï¼šæŸäº›å­—ä¸²ç„¡æ³•è§£ç¢¼ï¼ˆå¦‚éæ³• % åºåˆ—ï¼‰ï¼Œä½¿ç”¨åŸå§‹å€¼
          }
          return k;
        };

        /** ç”± sounds.json å»ºç«‹å°ç…§è¡¨ï¼šfile/basename/å¤§å°å¯«é¬†å¼› -> id */
        /**
         * å¾ sounds.json å»ºç«‹å°ç…§è¡¨ç”¨æ–¼æª”æ¡ˆåç¨±è½‰ ID çš„å°æ‡‰ã€‚
         * 
         * æ”¯æ´å¤šç¨®è¼¸å…¥æ ¼å¼ä¸¦é€²è¡Œæ­£è¦åŒ–ï¼š
         * 1. å®Œæ•´è·¯å¾‘ï¼ˆe.g. `sounds/subfolder/file.mp3`ï¼‰
         * 2. åŸºç¤æª”åï¼ˆe.g. `file.mp3`ï¼‰
         * 3. å¤§å°å¯«ä¸æ•æ„ŸæŸ¥è©¢
         * 
         * è¿”å›å…©å¼µ Mapï¼š
         * - exactï¼šç²¾ç¢ºé…å°ï¼ˆå€åˆ†å¤§å°å¯«ï¼‰
         * - lowerï¼šå¯¬é¬†é…å°ï¼ˆä¸å€åˆ†å¤§å°å¯«ï¼‰
         * 
         * @param {Array} soundsJson - sounds.json é™£åˆ—ï¼Œæ¯é …åŒ…å« file èˆ‡ id
         * @returns {Object} { exact: Map, lower: Map }
         */
        function buildFileMapsFromConfig(soundsJson) {
          const exact = new Map(), lower = new Map();
          for (const s of soundsJson) {
            // æå–æª”æ¡ˆè·¯å¾‘çš„åŸºæœ¬å½¢å¼
            const file = canonFileKey(s.file), base = file.split('/').pop(), id = s.id || base;
            // é‡å°å¤šç¨®è·¯å¾‘è®Šé«”å»ºç«‹å°æ‡‰ï¼šå®Œæ•´è·¯å¾‘ã€åŸºæª”åã€å¸¶/ä¸å¸¶ sounds å‰ç¶´
            [file, base, `sounds/${file}`, `sounds/${base}`].forEach(k => { 
              exact.set(k, id); 
              lower.set(k.toLowerCase(), id); 
            });
          }
          return { exact, lower };
        }

        /** æª¢æŸ¥æœ€æ„›æ˜¯å¦éœ€è¦é·ç§» */
        const favoritesNeedMigration = raw => {
          const list = parseLegacyFavorites(raw);
          return list.length > 0 && !list.every(x => ID_REGEX.test(x));
        };

        /** åŸ·è¡Œæœ€æ„›å¾æª”ååˆ° ID çš„é·ç§» */
        function migrateFavoritesFromFilesToIds(soundsJson) {
          try {
            const raw = localStorage.getItem(CONFIG.storage.favorites);
            if (!favoritesNeedMigration(raw)) {
              localStorage.setItem(CONFIG.storage.favoritesVersion, '2');
              return;
            }
            const legacy = parseLegacyFavorites(raw);
            const { exact, lower } = buildFileMapsFromConfig(soundsJson);

            const out = [];
            const seen = new Set();
            const missing = [];

            legacy.forEach(k => {
              const c = canonFileKey(k);
              const base = c.split('/').pop();
              const candidates = [c, c.replace(/^sounds\//, ''), base, 'sounds/' + c, 'sounds/' + base];
              const id = candidates.map(cand => exact.get(cand) || lower.get(cand.toLowerCase())).find(Boolean);
              if (!id) { missing.push(k); return; }
              if (!seen.has(id)) { seen.add(id); out.push(id); }
            });

            // å¯«å…¥æ–°ç‰ˆ + å‚™ä»½èˆŠç‰ˆ
            localStorage.setItem(CONFIG.storage.favoritesBackup, raw);
            localStorage.setItem(CONFIG.storage.favorites, JSON.stringify(out));
            localStorage.setItem(CONFIG.storage.favoritesVersion, '2');

            // åŒæ­¥åˆ° runtimeï¼ˆæœ¬æ¬¡è¼‰å…¥ç«‹å³ç”Ÿæ•ˆï¼‰
            state.favorites = out;
            state.favSet = new Set(out);
            toast(`å·²å‡ç´šæœ€æ„›æ ¼å¼ï¼Œå…± ${out.length} ç­†${missing.length ? `ï¼›æœªåŒ¹é… ${missing.length} ç­†` : ''}ã€‚`);
            console.info('[favorites migration] done:', { converted: out.length, missing });
          } catch (err) {
            console.warn('[favorites migration] error:', err);
          }
        }

        /** å¾ç¥¨é¸çµæœé‡æ–°æ’åºéŸ³æ•ˆåˆ—è¡¨ */
        async function applyVoteResultsOrdering() {
          try {
            const resp = await fetch(withV(CONFIG.paths.voteResults), { cache: 'no-store' });
            if (!resp.ok) { console.warn('[vote load] resp not ok', resp.status); return false; }
            const voteData = await resp.json();
            const topIds = voteData.slice(0, CONFIG.awards.topRankCount).map(v => v.id).filter(Boolean);
            if (!topIds.length) return false;
            // ä¾ç¥¨é¸é †åºæ”¶é›†å·²åŒ¹é…çš„éŸ³æ•ˆ
            const seen = new Set();
            const matchedList = topIds.map(id => state.soundMap.get(id)).filter(s => s && !seen.has(s.id) && (seen.add(s.id), true));
            // é‡çµ„ï¼šå·²åŒ¹é…çš„å„ªå…ˆï¼Œå…¶é¤˜ä¿æŒåŸåº
            state.sounds = [...matchedList, ...state.sounds.filter(s => !seen.has(s.id))];
            state.soundMap = new Map(state.sounds.map(s => [s.id, s]));
            state.defaultSoundsSnapshot = state.sounds.map(s => ({ ...s }));
            state.voteResults = {
              matchedList,
              top10: matchedList.slice(0, CONFIG.awards.top10Count),
              next20: matchedList.slice(CONFIG.awards.top10Count, CONFIG.awards.topRankCount)
            };
            console.info('[vote reorder] applied ordering, matched:', matchedList.length, '/', topIds.length);
            return true;
          } catch (e) { console.warn('[vote load] failed', e); return false; }
        }

        /** è¼‰å…¥è¨­å®šæª”ä¸¦åˆå§‹åŒ–ç‹€æ…‹ */
        async function loadConfig() {
          const [tagsJson, soundsJson] = await Promise.all([
            fetch(withV(CONFIG.paths.tags), { cache: 'no-store' }).then(r => r.json()),
            fetch(withV(CONFIG.paths.sounds), { cache: 'no-store' }).then(r => r.json())
          ]);
          // è®€å–æ¨™ç±¤
          migrateFavoritesFromFilesToIds(soundsJson);
          state.tags = {};
          state.tagList = tagsJson.map(t => ({ key: utils.slug(t.key), name: t.name, color: t.color, role: t.role, avatar: t.avatar }));
          state.tagList.forEach(t => { state.tags[t.key] = t; });
          // è®€å–éŸ³æ•ˆã€‚è‹¥é…ç½®æª”ä¸­åŒ…å« idï¼Œå‰‡ä½¿ç”¨è©² idï¼›å¦å‰‡ fallback åˆ°æª”åã€‚åŠ ä¸Šç‰ˆæœ¬å­—ä¸²ã€‚
          state.sounds = soundsJson.map(s => {
            const id = s.id || s.file.replace(/^.*[\\\/]/, '');
            return { id, src: withV(`sounds/${s.file}`), file: s.file, title: s.title, tags: s.tags.slice() };
          });
          state.soundMap = new Map(state.sounds.map(s => [s.id, s]));
          // ä¿å­˜ä¸€ä»½åŸå§‹è¼‰å…¥é †åºçš„æ·ºæ‹·è²ï¼Œä¾›ã€Œé è¨­é †åºã€é‚„åŸä½¿ç”¨
          state.defaultSoundsSnapshot = state.sounds.map(s => ({ ...s }));
          // è¼‰å…¥ç¥¨é¸çµæœ JSONï¼Œå°‡å‰ N åä¾ç¥¨é¸é †åºç§»åˆ°æœ€å‰é¢
          await applyVoteResultsOrdering();
          // è¨ˆç®—å“ªäº›æ¨™ç±¤è¢«ä½¿ç”¨åˆ°ï¼Œä»¥ä¾›æ¨™ç±¤ä¸€è¦½
          const usedKeys = new Set();
          state.sounds.forEach(snd => snd.tags.forEach(t => usedKeys.add(utils.slug(t))));
          state.usedTagList = state.tagList.filter(t => usedKeys.has(t.key));
        }

        /* =======================================================================
           10. UI æ¸²æŸ“å‡½å¼
           
           éŸ³æ•ˆå¡ç‰‡ã€ç¶²æ ¼ã€æ¨™ç±¤ã€åˆ†é ç­‰ UI å…ƒç´ çš„æ¸²æŸ“é‚è¼¯ã€‚
           ======================================================================= */

        /**
         * ä¸»æ¸²æŸ“å‡½å¼ï¼šæ ¹æ“šæœå°‹æ¢ä»¶ç¯©é¸ã€åˆ†é¡ã€æ’åºéŸ³æ•ˆï¼Œä¸¦æ›´æ–° UIã€‚
         * 
         * é‚è¼¯æµç¨‹ï¼š
         * 1. è§£ææœå°‹æ¢ä»¶ï¼ˆè©å½™ + æ¨™ç±¤ï¼‰
         * 2. ç¯©é¸ç¬¦åˆæ¢ä»¶çš„éŸ³æ•ˆ
         * 3. åˆ†é¡è‡³ä¸‰å€‹å€å¡Šï¼ˆæŒ‰å„ªå…ˆç´šï¼‰ï¼š
         *    - æœ€æ„›å€ï¼ˆæ”¶è—çš„éŸ³æ•ˆï¼‰
         *    - æ”¶åˆ°çš„åˆ—è¡¨ï¼ˆåˆ†äº«é€£çµå«æœ‰çš„éŸ³æ•ˆï¼Œéæœ€æ„›ï¼‰
         *    - ä¸€èˆ¬å€ï¼ˆå…¶ä»–ç¯©é¸çµæœï¼‰
         * 4. æ›´æ–° UIï¼šæ¸²æŸ“å¡ç‰‡ç¶²æ ¼ã€ç©ºç‹€æ…‹æç¤ºã€æ´»èºæœå°‹æ¨™ç±¤
         */
        function render() {
          const { terms, tags } = utils.parseQuery();
          // æ­¥é©Ÿ 1 & 2ï¼šç¯©é¸ç¬¦åˆæ¢ä»¶çš„éŸ³æ•ˆ
          const filtered = state.sounds.filter(s => utils.match(s, terms, tags));
          // è§£æåˆ†äº«åˆ—è¡¨åƒæ•¸ï¼ˆå¾ URLï¼‰
          const received = state.receivedList.map(id => state.soundMap.get(id)).filter(Boolean);
          const allowedIds = new Set(filtered.map(s => s.id)); // ç¯©é¸çµæœçš„ ID é›†åˆ
          
          // æ­¥é©Ÿ 3ï¼šåˆ†é¡å€å¡Š
          // æœ€æ„›å€ï¼šåœ¨ç¯©é¸çµæœä¸­çš„æ”¶è—éŸ³æ•ˆ
          const fav = state.favorites.map(id => state.soundMap.get(id)).filter(s => s && allowedIds.has(s.id));
          // æ”¶åˆ°çš„åˆ—è¡¨ï¼šåœ¨ç¯©é¸çµæœä¸­ã€éæœ€æ„›çš„åˆ†äº«éŸ³æ•ˆ
          const rec = received.filter(s => allowedIds.has(s.id) && !state.favSet.has(s.id));
          // ä¸€èˆ¬å€ï¼šç¯©é¸çµæœä¸­æ—¢éæœ€æ„›ä¹Ÿæœªåœ¨åˆ†äº«åˆ—è¡¨çš„éŸ³æ•ˆ
          const rest = filtered.filter(s => !state.favSet.has(s.id) && !rec.includes(s));
          
          // æ­¥é©Ÿ 4ï¼šæ›´æ–° UI
          // æœ€æ„›å€åªåœ¨éç·¨è¼¯æ¨¡å¼ä¸‹æ¸²æŸ“ï¼ˆé¿å…æ‹–æ”¾æ™‚é‡æ–°æ’åºå¡ç‰‡ï¼‰
          if (!state.isSorting) renderGrid(els.favGrid, fav, { inFav: true });
          renderGrid(els.receivedGrid, rec);
          
          // ä¸€èˆ¬å€æ”¹ç”¨åˆ†æ‰¹æ¸²æŸ“ï¼ˆè™›æ“¬æ»¾å‹•å„ªåŒ–ï¼‰
          state.displayList = rest;
          state.renderedCount = 0;
          els.grid.innerHTML = ''; // æ¸…ç©ºå®¹å™¨
          
          // åˆå§‹åŒ– IntersectionObserverï¼ˆå¦‚æœå°šæœªå»ºç«‹ï¼‰
          if (!state.observer) {
            state.observer = new IntersectionObserver(entries => {
              if (entries[0].isIntersecting) renderNextBatch();
            }, { rootMargin: '400px' }); // ææ—© 400px è§¸ç™¼è¼‰å…¥
          } else {
            state.observer.disconnect();
          }
          
          renderNextBatch();

          // ç©ºç‹€æ…‹æç¤º
          els.favEmpty.classList.toggle('hidden', fav.length > 0);
          els.empty.classList.toggle('hidden', filtered.length > 0);
          els.receivedSection?.classList.toggle('hidden', rec.length === 0);
          // æ›´æ–°æœå°‹æ¨™ç±¤åˆ—ï¼ˆchipsï¼‰
          renderActiveChips();
        }

        /** æ¸²æŸ“ä¸‹ä¸€æ‰¹æ¬¡éŸ³æ•ˆå¡ç‰‡ */
        function renderNextBatch() {
          const { displayList, renderedCount } = state;
          if (renderedCount >= displayList.length) return;

          const batch = displayList.slice(renderedCount, renderedCount + CONFIG.ui.batchSize);
          if (batch.length === 0) return;

          // ç§»é™¤èˆŠçš„å“¨å…µå…ƒç´ 
          const oldSentinel = document.getElementById('grid-sentinel');
          if (oldSentinel) oldSentinel.remove();

          const fragment = document.createDocumentFragment();
          for (const s of batch) {
            fragment.appendChild(renderSoundCard(s));
          }
          els.grid.appendChild(fragment);
          state.renderedCount += batch.length;

          // è‹¥é‚„æœ‰å‰©é¤˜é …ç›®ï¼ŒåŠ å…¥å“¨å…µå…ƒç´ ä»¥è§¸ç™¼ä¸‹ä¸€æ¬¡è¼‰å…¥
          if (state.renderedCount < displayList.length) {
            const sentinel = dom.el('div', { id: 'grid-sentinel', style: { gridColumn: '1 / -1', height: '20px', pointerEvents: 'none' } });
            els.grid.appendChild(sentinel);
            state.observer.observe(sentinel);
          }
        }

        /** æ¸²æŸ“ç¥¨é¸é é¢ */
        function renderawardsPage() {
          if (!state.voteResults) {
            els.awardsTop10?.replaceChildren();
            els.awardsNext20?.replaceChildren();
            return;
          }
          if (els.awardsTop10) renderGrid(els.awardsTop10, state.voteResults.top10 ?? []);
          if (els.awardsNext20) renderGrid(els.awardsNext20, state.voteResults.next20 ?? []);
        }
        /** æ¸²æŸ“éŸ³æ•ˆå¡ç‰‡åˆ—è¡¨åˆ°å®¹å™¨ */
        function renderGrid(container, list, opts = { inFav: false }) {
          container.innerHTML = '';
          for (const s of list) { container.appendChild(renderSoundCard(s, opts)); }
        }
        /** å»ºç«‹å–®ä¸€éŸ³æ•ˆå¡ç‰‡å…ƒç´  */
        function renderSoundCard(snd, opts = { inFav: false }) {
          const interactive = !(state.isSorting && opts.inFav);
          const heartAttrs = {
            class: 'heart',
            'aria-pressed': String(utils.inFav(snd.id)),
            'aria-label': 'åŠ å…¥/ç§»é™¤æœ€æ„›',
            ...(!interactive && { disabled: 'true', 'aria-disabled': 'true', title: 'æ­£åœ¨ç·¨è¼¯æœ€æ„›æ’åºï¼Œç„¡æ³•è®Šæ›´æœ€æ„›' })
          };
          const heartBtn = dom.el('button', heartAttrs, dom.svgHeart());
          if (interactive) heartBtn.onclick = e => { e.stopPropagation(); toggleFavorite(snd.id, heartBtn); };
          const tagWrap = dom.el('div', { class: 'tags' });
          for (const t of snd.tags) {
            const tagKey = utils.slug(t);
            const color = state.tags[tagKey]?.color || '#94a3b8';
            const el = dom.el('span', { class: 'tag', style: { background: color } }, t);
            el.addEventListener('click', e => { e.stopPropagation(); addTagToQuery(tagKey); });
            tagWrap.appendChild(el);
          }
          const card = dom.el('div', { id: 'snd-' + snd.id, 'data-id': snd.id, class: 'sound', role: 'button', tabindex: '0', 'aria-label': `æ’­æ”¾éŸ³æ•ˆï¼š${snd.title}` }, [
            dom.el('div', { class: 'sound-top' }, [
              dom.el('div', { class: 'title', title: snd.title }, snd.title),
              heartBtn
            ]),
            tagWrap
          ]);
          const play = () => { try { playSoundObject(snd); } catch (e) { console.error(e); } };
          const endHold = () => clearTimeout(state.contextTimer);
          if (interactive) {
            card.addEventListener('click', play);
            card.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); play(); } });
            card.addEventListener('contextmenu', e => { e.preventDefault(); closeMenu(); openMenuForSound(snd, e.clientX, e.clientY); });
            card.addEventListener('pointerdown', e => {
              clearTimeout(state.contextTimer);
              const { clientX, clientY } = e;
              state.contextTimer = setTimeout(() => {
                closeMenu();
                openMenuForSound(snd, clientX || window.innerWidth / 2, clientY || window.innerHeight / 2);
              }, CONFIG.timing.longPressDelay);
            });
            card.addEventListener('pointerup', endHold);
            card.addEventListener('pointerleave', endHold);
          }
          card.addEventListener('pointercancel', endHold);
          return card;
        }

        /** åˆ‡æ›éŸ³æ•ˆçš„æœ€æ„›ç‹€æ…‹ */
        function toggleFavorite(id, btn) {
          if (state.isSorting) { toast(MESSAGES.toast.sortingBlocked); return; }
          if (state.favSet.has(id)) {
            state.favorites = state.favorites.filter(x => x !== id);
          } else {
            state.favorites.push(id);
          }
          state.favSet = new Set(state.favorites);
          utils.saveFav();
          if (btn) btn.setAttribute('aria-pressed', String(state.favSet.has(id)));
          render();
        }

        /** æ¸²æŸ“å·²é¸æ¨™ç±¤ chips */
        function renderActiveChips() {
          els.activeChips.innerHTML = '';
          for (const key of state.queryTags) {
            const tag = state.tags[key];
            const color = tag?.color || '#94a3b8';
            const chip = dom.el('span', { class: 'chip', style: { background: color }, onclick: () => { state.queryTags.delete(key); render(); updateURLFromState(true); } }, [
              `#${tag?.name || key}`,
              dom.el('button', { title: 'ç§»é™¤', onclick: () => { state.queryTags.delete(key); render(); updateURLFromState(true); } }, 'Ã—')
            ],
            );
            els.activeChips.appendChild(chip);
          }
        }

        /** å°‡æ¨™ç±¤åŠ å…¥æœå°‹æ¢ä»¶ */
        function addTagToQuery(tagKey) {
          state.queryTags.add(tagKey);
          render();
          updateURLFromState(true);
        }

        /* =======================================================================
           11. é€±å¹´æ…¶ç¥åŠŸèƒ½æ¨¡çµ„
           
           åŒ…å«ï¼š
           - å½©å¸¶ç‰¹æ•ˆ (fireConfetti)
           - éŸ³æ•ˆæ’­æ”¾
           - äº’å‹•äº‹ä»¶ç¶å®š
           ======================================================================= */

        /** æ…¶ç¥ä¸‰é€±å¹´å½©å¸¶ç‰¹æ•ˆ */
        function fireConfetti() {
           // æ’­æ”¾éŸ³æ•ˆ
           setTimeout(() => {
             const audio = new Audio('assets/confetti-pop.mp3');
             audio.volume = 0.6;
             audio.play().catch(e => console.warn('Confetti sound failed', e));
           }, 10);

           const canvas = document.createElement('canvas');
           canvas.style.position = 'fixed';
           canvas.style.top = '0';
           canvas.style.left = '0';
           canvas.style.width = '100%';
           canvas.style.height = '100%';
           canvas.style.pointerEvents = 'none';
           canvas.style.zIndex = '9999';
           document.body.appendChild(canvas);
           
           const ctx = canvas.getContext('2d');
           canvas.width = window.innerWidth;
           canvas.height = window.innerHeight;
           
           const particles = [];
           const colors = ['#ffc0ab', '#ff893d', '#ffde82', '#b2f4c7', '#60cfff', '#2d7eff', '#b5b1ff'];
           
           // Emitters at 4 corners
           const emitters = [
             {x: 0, y: 0},
             {x: canvas.width, y: 0},
             {x: 0, y: canvas.height},
             {x: canvas.width, y: canvas.height}
           ];
           
           emitters.forEach(emitter => {
             for(let i=0; i<80; i++) {
               const angle = Math.atan2(canvas.height/2 - emitter.y, canvas.width/2 - emitter.x);
               const spread = (Math.random() - 0.5) * 1.8;
               // é™ä½åˆå§‹é€Ÿåº¦ (åŸ: 15 + 10)
               const velocity = Math.random() * 10 + 6;
               
               particles.push({
                 x: emitter.x,
                 y: emitter.y,
                 vx: Math.cos(angle + spread) * velocity,
                 vy: Math.sin(angle + spread) * velocity,
                 color: colors[Math.floor(Math.random() * colors.length)],
                 size: Math.random() * 8 + 4,
                 life: 2.0,
                 decay: Math.random() * 0.01 + 0.005,
                 rotation: Math.random() * 360,
                 rotationSpeed: (Math.random() - 0.5) * 6
               });
             }
           });
           
           function loop() {
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             let alive = false;
             
             particles.forEach(p => {
               if(p.life > 0) {
                 alive = true;
                 p.x += p.vx;
                 p.y += p.vy;
                 p.vy += 0.12; // Gravity (åŸ: 0.2)
                 p.vx *= 0.95; // Friction (åŸ: 0.96)
                 p.vy *= 0.95;
                 p.life -= p.decay;
                 p.rotation += p.rotationSpeed;
                 
                 ctx.save();
                 ctx.translate(p.x, p.y);
                 ctx.rotate(p.rotation * Math.PI / 180);
                 ctx.fillStyle = p.color;
                 ctx.globalAlpha = Math.max(0, p.life);
                 ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                 ctx.restore();
               }
             });
             
             if(alive) {
               requestAnimationFrame(loop);
             } else {
               document.body.removeChild(canvas);
             }
           }
           
           loop();
        }

        /* =======================================================================
           12. åˆå§‹åŒ–æµç¨‹
           
           æ‡‰ç”¨ç¨‹å¼å•Ÿå‹•ã€äº‹ä»¶ç¶å®šã€è³‡æ–™è¼‰å…¥ã€‚
           ======================================================================= */

        /** åˆå§‹åŒ–äº‹ä»¶ç¶å®š */
        function initEvents() {
          // [Anniversary] ä¸‰é€±å¹´æ…¶ç¥äº’å‹•
          const zone = document.getElementById('anniversaryZone');
          if (zone) {
            zone.addEventListener('click', fireConfetti);
          }

          // æœå°‹æ¡†è¼¸å…¥ï¼ˆä½¿ç”¨ debounce é™ä½ render é »ç‡ï¼‰
          const handleSearchInput = () => {
            state.queryText = els.q.value;
            render();
            updateURLFromState(false);
          };
          els.q.addEventListener('input', utils.debounce(handleSearchInput, CONFIG.timing.searchDebounce));

          // æ¸…é™¤æœå°‹
          els.clearBtn.addEventListener('click', () => {
            els.q.value = '';
            state.queryText = '';
            state.queryTags.clear();
            render();
            updateURLFromState(true);
          });

          // å°è¦½åˆ‡æ›
          els.navTabs.forEach(tab => {
            tab.addEventListener('click', () => {
              const pg = tab.getAttribute('data-page');
              showPage(pg || 'home');
            });
          });
          // æ‰‹æ©Ÿé¸å–®é–‹é—œ
          if (els.navToggle) {
            els.navToggle.addEventListener('click', () => {
              const open = !document.body.classList.contains('nav-open');
              document.body.classList.toggle('nav-open', open);
              els.navToggle.setAttribute('aria-expanded', String(open));
            });
          }

          const closeNavMenu = () => {
            document.body.classList.remove('nav-open');
            els.navToggle?.setAttribute('aria-expanded', 'false');
          };
          // é»æ“Šé é¢å…¶ä»–åœ°æ–¹é—œé–‰æ‰‹æ©Ÿé¸å–®
          document.addEventListener('click', e => {
            if (!document.body.classList.contains('nav-open')) return;
            const headerEl = document.querySelector('header');
            if (headerEl && !headerEl.contains(e.target)) closeNavMenu();
          });
          // é»æ“Šå°è¦½å¾Œåœ¨å°è¢å¹•è‡ªå‹•æ”¶åˆ
          els.navTabs.forEach(t => t.addEventListener('click', closeNavMenu));

          // æ´—ç‰ŒæŒ‰éˆ•
          if (els.shuffleBtn) {
            els.shuffleBtn.addEventListener('click', () => {
              // åªæ´—ç‰Œã€Œéæœ€æ„›ã€éŸ³æ•ˆï¼Œä¸å½±éŸ¿æœ€æ„›å€çš„æ’åˆ—
              const nf = [];
              const idxs = [];
              state.sounds.forEach((s, i) => {
                if (!state.favSet.has(s.id)) { nf.push(s); idxs.push(i); }
              });
              shuffleInPlace(nf);
              idxs.forEach((i, k) => { state.sounds[i] = nf[k]; });
              render();
            });
          }
          // é è¨­é †åºæŒ‰éˆ•ï¼šå°‡éæœ€æ„›å€å¡Šæ¢å¾©ç‚ºè¼‰å…¥æ™‚çš„é †åº
          if (els.resetOrderBtn) {
            els.resetOrderBtn.addEventListener('click', () => {
              if (!state.defaultSoundsSnapshot || !state.defaultSoundsSnapshot.length) return;
              // æˆ‘å€‘åªæ¢å¾©éæœ€æ„›ï¼ˆrestï¼‰å€æ®µçš„é †åºï¼ŒåŒ shuffleBtn çš„è¡Œç‚ºç›¸å°æ‡‰
              const snapshot = state.defaultSoundsSnapshot;
              const idIndex = new Map(snapshot.map((s, i) => [s.id, i]));
              state.sounds.sort((a, b) => (idIndex.get(a.id) ?? Infinity) - (idIndex.get(b.id) ?? Infinity));
              render();
            });
          }
          // åˆ†äº«æœ€æ„›åˆ—è¡¨

          // æ‰‹å‹•æ’åºï¼ˆæª¢æŸ¥é»Aï¼‰ï¼šå•Ÿç”¨/åœç”¨ SortableJS åƒ…é‡å°æœ€æ„›æ¸…å–®
          if (els.sortFavBtn && els.doneSortBtn) {
            els.sortFavBtn.addEventListener('click', () => {
              state.isSorting = true;
              document.body.classList.add('sorting');
              els.sortFavBtn.classList.add('hidden');
              els.doneSortBtn.classList.remove('hidden');
              // é‡æ–°æ¸²æŸ“æœ€æ„›å€å¡Š
              const { terms, tags } = utils.parseQuery();
              const allowedIds = new Set(state.sounds.filter(s => utils.match(s, terms, tags)).map(s => s.id));
              const fav = state.favorites.map(id => state.soundMap.get(id)).filter(s => s && allowedIds.has(s.id));
              renderGrid(els.favGrid, fav, { inFav: true });
              // å•Ÿç”¨ SortableJS
              typeof Sortable !== 'undefined'
                ? state.sortable = Sortable.create(els.favGrid, {
                  dataIdAttr: 'data-id', animation: 150, delay: 150, delayOnTouchOnly: true,
                  ghostClass: 'drag-ghost', chosenClass: 'drag-chosen', dragClass: 'dragging',
                  filter: '.heart', preventOnFilter: false
                })
                : console.warn('SortableJS æœªè¼‰å…¥');
            });
            els.doneSortBtn.addEventListener('click', () => {
              const orderedIds = [...els.favGrid.children].map(el => el.dataset.id).filter(Boolean);
              if (orderedIds.length) {
                state.favorites = orderedIds.concat(state.favorites.filter(id => !orderedIds.includes(id)));
                state.favSet = new Set(state.favorites);
                utils.saveFav();
                toast(MESSAGES.toast.sortingSaved);
              }
              state.sortable?.destroy(); state.sortable = null;
              state.isSorting = false;
              document.body.classList.remove('sorting');
              els.doneSortBtn.classList.add('hidden');
              els.sortFavBtn.classList.remove('hidden');
              render();
            });
          }
          if (els.shareFavBtn) {
            els.shareFavBtn.addEventListener('click', async () => {
              const ids = [...state.favorites];
              if (ids.length === 0) { toast(MESSAGES.toast.noFavorites); return; }
              const url = buildListURL(ids);
              await copyToClipboard(url);
              toast(MESSAGES.toast.listLinkCopied);
            });
          }
        }

        /** åˆå§‹åŒ–èƒŒæ™¯å‹•ç•« */
        function initBackgroundAnimation() {
          let bgX = 0;
          setInterval(() => {
            bgX -= 75;
            document.body.style.setProperty('--bg-x', `${bgX}px`);
          }, 12000);
        }

        // å…¥å£ï¼šè¼‰å…¥è¨­å®šå¾Œåˆå§‹åŒ–ç‹€æ…‹ã€æ¸²æŸ“ä¸¦å¥—ç”¨ URL æŸ¥è©¢
        loadConfig().then(() => {
          initBackgroundAnimation();
          
          // [Anniversary] é å…ˆè¼‰å…¥æ…¶ç¥éŸ³æ•ˆ
          fetch('assets/confetti-pop.mp3').catch(() => {});
          
          applyURLToState();
          renderTagList();
          showPage(state.page);
          render();
          focusSoundFromURL();
          initEvents();
          // é»æ“Šæ¨™é¡Œæ™‚å›åˆ°ä¸»é ä¸¦æ¸…é™¤æœå°‹ï¼ˆé˜»æ­¢é è¨­çš„å…¨é å°å‘ï¼‰ï¼Œç„¶å¾Œé‡æ–°æ¸²æŸ“èˆ‡æ›´æ–° URL
          try {
            const titleLink = document.querySelector('header h1');
            if (titleLink) {
              titleLink.addEventListener('click', (e) => {
                // å¦‚æœä½¿ç”¨è€…ä½¿ç”¨ Ctrl/Cmd + click æˆ– æƒ³è¦åœ¨æ–°åˆ†é é–‹å•Ÿï¼Œä¿ç•™åŸè¡Œç‚º
                if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;
                // è‹¥å·²åœ¨ä¸»é ï¼Œå‰‡å¼·åˆ¶é‡æ–°æ•´ç†é é¢
                if (state.page === 'home') {
                  // å…è¨±ç€è¦½å™¨åšå®Œæ•´ reload
                  return location.reload();
                }
                e.preventDefault();
                // æ¸…é™¤æœå°‹ç‹€æ…‹ä¸¦å›é¦–é 
                state.queryText = '';
                state.queryTags.clear();
                if (els.q) els.q.value = '';
                showPage('home');
                render();
                updateURLFromState(true);
                // å¹³æ»‘æ»¾å›é ‚éƒ¨ï¼ˆæŸäº›èˆŠç€è¦½å™¨ä¸æ”¯æ´ smoothï¼‰
                try {
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                } catch {
                  window.scrollTo(0, 0); // fallback
                }
              });
            }
          } catch (e) {
            console.warn('[resetOrderBtn] é‡ç½®æ’åºå¤±æ•—', e);
          }
        }).catch(err => {
          console.error(err);
          els.grid.innerHTML = `<div class="empty">${MESSAGES.errors.configLoadFailed}</div>`;
        });

        /* =======================================================================
           12. è¨˜æ†¶å°éŠæˆ²
           
           é…å°è¨˜æ†¶éŠæˆ²æ¨¡çµ„ï¼ŒåŒ…å«éŠæˆ²é‚è¼¯ã€è¨ˆæ™‚ã€è¨ˆåˆ†ç³»çµ±ã€‚
           ======================================================================= */

        /** åˆå§‹åŒ–é…å°è¨˜æ†¶éŠæˆ² */
        function setupConcentrationGame() {
          const gameEl = document.getElementById('concentration-game');
          const boardEl = document.getElementById('cg-board');
          const timerEl = document.getElementById('cg-timer');
          const accEl = document.getElementById('cg-accuracy');
          const resultEl = document.getElementById('cg-result');
          const restartBtn = document.getElementById('cg-restart');
          if (!gameEl) return;

          // æ³¨æ„ï¼šä¸è¦åœ¨æ­¤è™•é‡æ–°å®£å‘Š cgCleanup â€”â€” è«‹ä½¿ç”¨å¤–å±¤ä½œç”¨åŸŸçš„ cgCleanupï¼Œ
          // ä»¥ä¾¿åœ¨åˆ‡æ›é é¢æ™‚ï¼ˆç”± showPage å‘¼å«ï¼‰èƒ½æ­£ç¢ºåŸ·è¡Œæ¸…ç†å·¥ä½œã€‚

          // --- éŠæˆ²ç‹€æ…‹ ---
          let cards = [];
          let first = null, second = null;
          // scoring: correct = æ­£ç¢ºæ•¸ (æ¯é…å° +2), wrong = éŒ¯è§£æ•¸ (å¯ +0/+1/+2)
          let correct = 0, wrong = 0;
          // matchedPairs counts how many pairs have been solved (0..pairCount)
          let matchedPairs = 0, tries = 0;
          let timer = 0, timerId = null, running = false;
          let allowClick = true;
          let pairs = [];
          // pending pair / timeout ç”¨æ–¼å»¶é²æª¢æŸ¥é…å°ï¼›è‹¥ä½¿ç”¨è€…åœ¨ç­‰å¾…æœŸé–“é»æ“Šå…¶ä»–å¡ï¼Œæœƒç«‹åˆ»çµç®—é€™å°ã€‚
          let pendingTimeout = null;
          let pendingPair = null; // {f, s}
          let timerStarted = false; // only start timer on first card flip

          /**
           * å¾ç¯©é¸éçš„æœ‰æ•ˆéŸ³æ•ˆä¸­é¸å‡ºæœ€å¤š 8 ç­†ä½œç‚ºé…å°ä¾†æºã€‚
           * 
           * é¸æ“‡ç­–ç•¥ï¼ˆå„ªå…ˆé †åºï¼‰ï¼š
           * 1. å·²çŸ¥ä¸»æ’­ï¼ˆæœ‰é…é¡ï¼‰ï¼šæŒ‰å„ªå…ˆé †åºé¸å–ç›´åˆ°é…é¡æ»¿æˆ–ç„¡å­˜é‡
           * 2. æœªçŸ¥ä¸»æ’­ï¼šæœ€å¤šé¸ 2 ç­†ä½œç‚ºè£œå……
           * 
           * é…é¡åˆ†é…ï¼š
           * - åœ°åŸºä¸»é˜¿è¬ï¼š2 ç­†
           * - ç“¦å“ˆ/Matsuko/è±¹å­é ­/è²“ä¸‹å»ï¼šå„ 1 ç­†
           * - å…¶ä»–å‹•ç‰©æœ‹å‹ï¼š2 ç­†
           * 
           * @param {Array} validSounds - å·²ç¯©é¸çš„éŸ³æ•ˆæ¸…å–®ï¼ˆå·²ç§»é™¤é«’è©±/SUSã€åªæœ‰ä¸€å€‹ streamer æ¨™ç±¤ï¼‰
           * @returns {Array} æœ€å¤š 8 ç­†é¸ä¸­çš„éŸ³æ•ˆ
           */
          function selectSounds(validSounds) {
            const quotas = { 'é˜¿è¬': 2, 'ç“¦å“ˆ': 1, 'Matsuko': 1, 'è±¹å­é ­': 1, 'è²“ä¸‹å»': 1 };
            const knownTags = new Set(Object.keys(quotas));
            const counts = Object.fromEntries(Object.keys(quotas).map(k => [k, 0]));
            let others = 0; // å…¶ä»–å‹•ç‰©æœ‹å‹çš„è¨ˆæ•¸
            const chosen = [];
            
            for (const snd of validSounds) {
              if (chosen.length >= CONFIG.game.pairCount) break; // é”é…å°æ•¸ä¸Šé™ï¼Œåœæ­¢
              const tags = snd.tags ?? [];
              // å„ªå…ˆé¸æ“‡æœ‰é…é¡ä¸”æœªæ»¿çš„å·²çŸ¥ä¸»æ’­
              const knownTag = tags.find(t => knownTags.has(t) && counts[t] < quotas[t]);
              if (knownTag) { counts[knownTag]++; chosen.push(snd); }
              // æ¬¡é¸ï¼šå…¶ä»–å‹•ç‰©æœ‹å‹ï¼Œå¿…é ˆè¦å† 2 ç­†
              else if (!tags.some(t => knownTags.has(t)) && others < 2) { others++; chosen.push(snd); }
            }
            return chosen;
          }

          // --- è³‡æ–™ç¯©é¸ ---
          /**
           * æŒ‘é¸é…å°éŠæˆ²çš„éŸ³æ•ˆæ¸…å–®ã€‚
           * 
           * ç¯©é¸è¦å‰‡ï¼š
           * 1. å¿…é ˆæ°å¥½åŒ…å« 1 å€‹ streamer æ¨™ç±¤ï¼ˆè­˜åˆ¥ä¸»æ’­ï¼‰
           * 2. ä¸èƒ½åŒ…å« 'é«’è©±' æˆ– 'SUS' æ¨™ç±¤
           * 3. æ‡‰ç”¨é¸æ“‡é…é¡ï¼ˆåœ°åŸºä¸»2å€‹ã€é­”æ³•å€¼ç­å®¤å…¶ä»–4äººå„1å€‹ã€å…¶ä»–å‹•ç‰©æœ‹å‹éš¨æ©Ÿé¸2ï¼‰
           * 4. å†æ¬¡æ´—ç‰Œä»¥éš¨æ©ŸåŒ–å°ç‰Œé †åº
           * 
           * @returns {Array<Object>} é¸å®šçš„é…å°ç‰©ä»¶æ¸…å–®ï¼Œæ¯å€‹åŒ…å« idã€audioã€avatarã€streamerNameã€title
           */
          function pickPairs() {
            // è¼”åŠ©ï¼šå¾ tagList æ“·å–æ‰€æœ‰ streamer çš„ keyï¼ˆä¸¦åš slug åŒ–ï¼‰ä»¥ä¾›å¾ŒçºŒæ¯”å°
            const streamerKeys = state.tagList
              .filter(t => t.role === 'streamer')
              .map(t => utils.slug(t.key));

            // åˆ¤æ–·æ¨™ç±¤æ˜¯å¦ç‚º streamerï¼ˆå·² slug åŒ–ï¼‰
            const isStreamer = t => streamerKeys.includes(t);
            
            // ç¯©é¸æœ‰æ•ˆçš„éŸ³æ•ˆï¼šæ°å¥½ 1 å€‹ streamerï¼Œç„¡é«’è©±/SUS
            let validSounds = state.sounds.filter(s => {
              const st = s.tags.filter(isStreamer);
              if (st.length !== 1) return false; // å¿…é ˆæ°å¥½ 1 å€‹ streamer
              if (s.tags.includes('é«’è©±') || s.tags.includes('SUS')) return false; // æ’é™¤ç¦æ­¢æ¨™ç±¤
              return true;
            });

            // æ´—ç‰Œï¼Œæ‡‰ç”¨é…é¡é¸æ“‡ï¼Œç¢ºä¿å¤šæ¨£æ€§
            validSounds = shuffleInPlace(validSounds);
            let chosen = selectSounds(validSounds);
            chosen = shuffleInPlace(chosen); // å†æ´—ç‰Œä»¥éš¨æ©ŸåŒ–å°ç‰Œé †åº
            // æœ€å¾Œç¢ºä¿ä¸è¶…éé…å°æ•¸é‡
            chosen.splice(CONFIG.game.pairCount);

            // æ˜ å°„åˆ°é…å°ç”¨ç‰©ä»¶ï¼ˆåŒ…å« id, audio, avatar, streamerName, title ç­‰æ¬„ä½ï¼‰
            return chosen.map(s => {
              const streamerTag = s.tags.find(isStreamer);
              const tagObj = state.tags[utils.slug(streamerTag)];
              return {
                id: s.id,
                audio: s.src,
                streamer: streamerTag,
                avatar: tagObj?.avatar || '',
                streamerName: tagObj?.name || streamerTag,
                title: s.title
              };
            });
          }

          /** é–‹å§‹æ–°éŠæˆ² */
          function startGame() {
            pairs = pickPairs();
            // å¦‚æœæ‰¾ä¸åˆ°è¶³å¤ çš„é…å°éŸ³æ•ˆï¼Œé¡¯ç¤ºè¨Šæ¯ä¸¦ä¸­æ­¢éŠæˆ²å•Ÿå‹•
            if (!pairs?.length) {
              resultEl.innerHTML = `<h3>ç„¡æ³•é–‹å§‹éŠæˆ²</h3><p style="color:var(--muted)">${MESSAGES.errors.gameNoSounds}</p>`;
              resultEl.classList.remove('hidden');
              running = state.cgRunning = false;
              return;
            }
            [cards, pendingTimeout, pendingPair] = [[], (clearTimeout(pendingTimeout), null), null];
            // ç‚ºæ¯å€‹é…å°å»ºç«‹å…©å¼µç›¸åŒçš„å¡ç‰‡
            for (const p of pairs) {
              const base = { type: 'card', pairId: p.id, audio: p.audio, avatar: p.avatar, streamer: p.streamer, streamerName: p.streamerName, title: p.title, matched: false, seen: false };
              cards.push({ ...base, id: `${p.id}-0` }, { ...base, id: `${p.id}-1` });
            }
            shuffleInPlace(cards);
            [matchedPairs, correct, wrong, tries, timer, first, second] = [0, 0, 0, 0, 0, null, null];
            allowClick = true;
            timerStarted = running = state.cgRunning = false;
            if (timerEl) { timerEl.textContent = formatTime(0); timerEl.classList.remove('cg-running'); }
            updateBoard();
            updateStats();
            resultEl.classList.add('hidden');
            // æä¾›æ¸…ç†å‡½å¼
            cgCleanup = () => {
              running = false;
              state.cgRunning = false;
              stopTimer();
              stopCurrentAudio();
              timerEl?.classList.remove('cg-running');
              boardEl.innerHTML = '';
              clearTimeout(pendingTimeout);
              pendingTimeout = pendingPair = null;
            };
          }
          /** é‡æ–°æ¸²æŸ“éŠæˆ²æ¿é¢ */
          function updateBoard() {
            boardEl.innerHTML = '';
            for (const [idx, card] of cards.entries()) {
              const cardEl = dom.el('div', {
                class: `cg-card${card.flipped || card.matched ? ' flipped' : ''}${card.matched ? ' matched' : ''}`,
                'data-idx': idx,
                onclick: () => onCardClick(idx),
                onpointerdown: () => { cardEl.classList.add('clicked'); setTimeout(() => cardEl.classList.remove('clicked'), 160); }
              });
              const backContent = card.avatar
                ? `<img src="${withV(card.avatar)}" alt="${card.streamerName}">`
                : `<div style="font-weight:700;color:var(--muted);font-size:12px">${card.streamerName}</div>`;
              cardEl.innerHTML = `<div class="cg-card-inner"><div class="cg-card-front"></div><div class="cg-card-back">${backContent}${card.matched ? '<div class="cg-lock">âœ“</div>' : ''}</div></div>`;
              boardEl.appendChild(cardEl);
            }
          }

          let currentAudio = null;
          /** åœæ­¢ç•¶å‰æ’­æ”¾çš„éŸ³æ•ˆ */
          const stopCurrentAudio = () => { if (currentAudio) { try { currentAudio.pause(); currentAudio.currentTime = 0; } catch (e) { } currentAudio = null; } };

          /** è™•ç†å¡ç‰‡é»æ“Šä¸¦æª¢æŸ¥é…å° */
          function onCardClick(idx) {
            // å¦‚æœæœ‰å¾…è™•ç†çš„ pendingPairï¼Œä½¿ç”¨è€…æ­¤åˆ»é»æ“Šå…¶ä»–å¡ç‰‡æ™‚æ‡‰ç«‹å³çµç®—è©² pendingPair
            if (pendingPair?.f || pendingPair?.s) {
              clearTimeout(pendingTimeout);
              pendingTimeout = null;
              const p = pendingPair;
              pendingPair = null;
              checkMatchPair(p.f, p.s);
              first = second = null;
              allowClick = true;
            }
            if (!allowClick) return;
            const card = cards[idx];
            if (card.flipped || card.matched) return;
            // åœ¨ç©å®¶ç¬¬ä¸€æ¬¡äº’å‹•ï¼ˆç¿»ç‰Œï¼‰æ™‚å•Ÿç”¨è¨ˆæ™‚å™¨
            if (!timerStarted) {
              timerStarted = running = state.cgRunning = true;
              timerEl?.classList.add('cg-running');
              startTimer();
            }
            // åŸ·è¡Œç¿»ç‰Œï¼ˆæ›´æ–°è³‡æ–™ç‹€æ…‹ä¸¦é‡æ–°æ¸²æŸ“æ¿é¢ï¼Œè§¸ç™¼ CSS ç¿»ç‰Œå‹•ç•«ï¼‰
            card.flipped = true;
            updateBoard();
            if (!first) {
              // è¨˜éŒ„é€™å¼µå¡ç‰Œåœ¨ç¿»å‰æ˜¯å¦å·²è¢«ç¿»çœ‹éï¼ˆç”¨æ–¼è¨ˆåˆ†åˆ¤å®šï¼‰
              card._seenBefore = !!card.seen;
              // æ¨™è¨˜ç‚ºå·²çœ‹éï¼ˆé¿å…å¾ŒçºŒé‡è¤‡è¨ˆåˆ†ï¼‰
              card.seen = true;
              first = card;
              // æ’­æ”¾è©²å¡çš„éŸ³æ•ˆä¸¦é¡¯ç¤ºæ¨™é¡Œ
              stopCurrentAudio();
              currentAudio = createPlayer(card.audio, { preload: 'auto' });
              if (card.title) toast(card.title, 3000);
            } else if (!second) {
              // ç¬¬äºŒå¼µå¡çš„è™•ç†ï¼šåŒæ¨£æ¨™è¨˜æ˜¯å¦å…ˆå‰çœ‹éä¸¦æ’­æ”¾éŸ³æ•ˆ
              card._seenBefore = !!card.seen;
              card.seen = true;
              second = card;
              stopCurrentAudio();
              currentAudio = createPlayer(card.audio, { preload: 'auto' });
              if (card.title) toast(card.title, 3000);
              tries++;
              allowClick = false;
              // æ•ç²ç•¶å‰ç¬¬ä¸€å¼µ/ç¬¬äºŒå¼µå¡çš„å¼•ç”¨ï¼Œé¿å…åœ¨å»¶é²æœŸé–“è¢«å…¶ä»–é‚è¼¯æ”¹å¯«é€ æˆ race conditionã€‚
              const fCard = first;
              const sCard = second;
              // å„²å­˜ç‚º pendingPairï¼Œä¸¦å•Ÿå‹•è¶…æ™‚ï¼ˆ500msï¼‰ã€‚å¦‚æœä½¿ç”¨è€…åœ¨æ­¤æœŸé–“é»æ“Šå…¶ä»–å¡
              // å‰‡æœƒåœ¨ onCardClick é–‹é ­ç«‹åˆ»çµç®—é€™å°ã€‚
              pendingPair = { f: fCard, s: sCard };
              if (pendingTimeout) { clearTimeout(pendingTimeout); pendingTimeout = null; }
              pendingTimeout = setTimeout(() => {
                pendingTimeout = null;
                const p = pendingPair; pendingPair = null;
                checkMatchPair(p.f, p.s);
                // é‡ç½®å…¨åŸŸæš«å­˜ï¼Œå…è¨±ä¸‹ä¸€å›åˆäº’å‹•
                first = null;
                second = null;
                allowClick = true;
              }, CONFIG.game.cardFlipDelay);
            }
            updateStats();
          }

          /** æª¢æŸ¥å…©å¼µå¡ç‰‡æ˜¯å¦é…å° */
          function checkMatchPair(f, s) {
            if (!f || !s) return;
            if (f.pairId === s.pairId) {
              f.matched = s.matched = true;
              correct += 2;
              matchedPairs++;
            } else {
              const seenCount = [f, s].filter(c => c._seenBefore).length;
              wrong += seenCount || 0;
              f.flipped = s.flipped = false;
            }
            delete f._seenBefore; delete s._seenBefore;
            updateBoard();
            updateStats();
            if (matchedPairs === pairs.length) { stopCurrentAudio(); endGame(); }
          }

          /** æ›´æ–°éŠæˆ²çµ±è¨ˆé¡¯ç¤º */
          function updateStats() {
            timerEl.textContent = formatTime(timer);
            const denom = correct + wrong;
            accEl.textContent = denom ? `æº–ç¢ºç‡ï¼š${Math.round((correct / denom) * 100)}%` : 'æº–ç¢ºç‡ï¼š--%';
          }

          /** æ ¼å¼åŒ–æ™‚é–“ç‚º mm:ss */
          const formatTime = t => `${String(Math.floor(t / 60)).padStart(2, '0')}:${String(t % 60).padStart(2, '0')}`;

          /** å•Ÿå‹•éŠæˆ²è¨ˆæ™‚å™¨ */
          function startTimer() {
            clearInterval(timerId);
            timerId = setInterval(() => { if (state.cgRunning) { timer++; timerEl.textContent = formatTime(timer); } }, 1000);
          }
          /** åœæ­¢éŠæˆ²è¨ˆæ™‚å™¨ */
          const stopTimer = () => { clearInterval(timerId); timerId = null; };

          /** çµæŸéŠæˆ²ä¸¦é¡¯ç¤ºæˆç¸¾ */
          function endGame() {
            running = state.cgRunning = false;
            stopTimer();
            stopCurrentAudio();
            timerEl?.classList.remove('cg-running');
            const denom = correct + wrong;
            const perc = denom ? Math.round((correct / denom) * 100) : '--';
            const stat = (v, l) => `<div><div class="big-num">${v}</div><div class="muted">${l}</div></div>`;
            const stats = [[formatTime(timer), 'ç”¨æ™‚'], [correct, 'æ­£ç¢ºæ•¸'], [wrong, 'éŒ¯è§£æ•¸'], [perc + '%', 'æº–ç¢ºç‡']].map(([v, l]) => stat(v, l)).join('');
            resultEl.innerHTML = `<h3>å®Œæˆï¼</h3>
                                  <div class="stats">${stats}</div>
                                  <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
                                    <button class="btn small-btn" id="cg-restart-2">å†ä¾†ä¸€å±€</button>
                                    <button class="btn small-btn" id="cg-home">å›ä¸»é </button>
                                  </div>`;
            resultEl.classList.remove('hidden');
            // è‹¥æº–ç¢ºç‡é”æ¨™ï¼Œéš¨æ©Ÿæ’­æ”¾çå‹µéŸ³æ•ˆ
            if (perc >= CONFIG.game.rewardAccuracy) {
              const reward = state.soundMap.get(CONFIG.game.rewardSoundIds[Math.floor(Math.random() * CONFIG.game.rewardSoundIds.length)]);
              if (reward?.src) { stopCurrentAudio(); currentAudio = createPlayer(reward.src, { preload: 'auto' }); toast(MESSAGES.toast.gameReward, 3000); }
            }
            utils.byId('cg-restart-2')?.addEventListener('click', startGame);
            utils.byId('cg-home')?.addEventListener('click', () => showPage('home'));
          }

          restartBtn.onclick = startGame;

          // åˆå§‹ï¼šè¼‰å…¥é é¢æ™‚é¡¯ç¤ºå¡ç‰Œï¼ˆä¸å•Ÿå‹•è¨ˆæ™‚ï¼‰ã€‚æŒ‰ã€Œé‡é–‹ä¸€å±€ã€å¯é‡æ–°å»ºç«‹ä¸€å±€ï¼›è¨ˆæ™‚çš†åœ¨ç¬¬ä¸€å¼µç¿»ç‰Œæ™‚å•Ÿå‹•ã€‚
          // é€™è£¡å‘¼å« startGame() ä»¥å»ºç«‹ä¸¦é¡¯ç¤ºå¡ç‰Œï¼ˆä½† timerStarted=falseï¼Œä¸æœƒè‡ªå‹•é–‹å§‹è¨ˆæ™‚ï¼‰
          startGame();
        }

        // åˆ‡æ›åˆ°å°éŠæˆ²åˆ†é æ™‚åˆå§‹åŒ–/æ¸…ç† Concentration Gameï¼ˆä½¿ç”¨äº‹ä»¶é©…å‹•ï¼‰
        document.addEventListener('pageChange', ({ detail: { page, prevPage, phase } = {} }) => {
          try {
            if (phase === 'before' && prevPage === 'game') cgCleanup?.();
            if (phase === 'after') {
              page === 'game' && setupConcentrationGame?.();
              page === 'awards' && renderawardsPage();
            }
          } catch (e) {
            console.warn('[pageChange] é é¢åˆ‡æ›è™•ç†å¤±æ•—', e);
          }
        });

        /* =======================================================================
           13. demaPanel å¤šè»Œæ··éŸ³ç·¨è¼¯å™¨æ¨¡çµ„
           ======================================================================= */

        /**
         * demaPanel - å¤šè»ŒéŸ³è¨Šç·¨è¼¯å™¨
         * 
         * åŠŸèƒ½ï¼š
         * - 3 è»Œå›ºå®šéŸ³è»Œï¼Œæ¯è»Œ 40px é«˜
         * - éŸ³è¨Šç‰‡æ®µæ‹–æ›³ï¼ˆå«è·¨è»Œï¼‰
         * - Trim è£å‰ªï¼ˆå·¦å³é‚Šç·£ï¼‰
         * - ç²¾ç¢º Playheadï¼ˆæ™‚é–“ç‚ºåŸºæº–ï¼Œè¦–è¦ºç‚ºæ´¾ç”Ÿï¼‰
         * - Undo/Redo æ­·å²ç´€éŒ„
         * - localStorage æŒä¹…åŒ–
         * - ç§»å‹•ç«¯æ‰‹å‹¢æ”¯æ´
         */
        const demaPanel = (() => {
          // === å¸¸æ•¸è¨­å®š ===
          const STORAGE_KEY = 'demaPanel_v1';
          const TRACK_COUNT = 3;
          const TRACK_LABEL_WIDTH = 32;
          const DEFAULT_PX_PER_SEC = 200;
          const MIN_PX_PER_SEC = 50;
          const MAX_PX_PER_SEC = 800;
          const MAX_DURATION = 300; // æœ€å¤§æ™‚é•· 5 åˆ†é˜
          const HISTORY_LIMIT = 50;
          // [HACK] clip è¦–è¦ºå‘å³åç§»é‡ï¼ˆpxï¼‰
          // åŸå› ï¼šclip åœ¨ startTime=0 æ™‚ï¼Œå·¦é‚Šç·£æœƒç¨å¾®è¶…å‡ºéŸ³è»Œæ¨™ç±¤å€åŸŸ
          // è§£æ³•ï¼šåƒ…åœ¨è¦–è¦ºæ¸²æŸ“æ™‚åŠ ä¸Šåç§»ï¼Œé‚è¼¯ä½ç½®ï¼ˆæ‹–æ›³ã€ç¢°æ’ã€æ™‚é–“è¨ˆç®—ï¼‰ä¸å—å½±éŸ¿
          const CLIP_VISUAL_OFFSET = 2;
          const LONG_PRESS_DELAY = 350;
          const MOBILE_DRAG_DELAY = 200;
          const WAVEFORM_SAMPLES_PER_SEC = 120; // æ³¢å‹è§£æåº¦ï¼šæ¯ç§’å¤šå°‘å€‹æ¨£æœ¬é»

          // === ç‹€æ…‹ ===
          let isOpen = false;
          let isPlaying = false;
          let playheadTime = 0; // ç§’ï¼ˆauthoritative source of truthï¼‰
          let pxPerSec = DEFAULT_PX_PER_SEC;
          let totalDuration = 30; // å‹•æ…‹è¨ˆç®—
          let clips = []; // { id, soundId, trackIndex, startTime, trimStart, trimEnd, duration }
          let selectedClipId = null;
          let undoStack = [];
          let redoStack = [];
          
          // éŸ³è¨Šæ’­æ”¾
          let audioContext = null;
          let scheduledSources = [];
          let playStartTime = 0; // audioContext.currentTime when play started
          let playStartPosition = 0; // playheadTime when play started
          let animationFrameId = null;

          // æ‹–æ›³ç‹€æ…‹
          let dragState = null;
          let longPressTimer = null;

          // Audio buffer å¿«å–
          const audioBufferCache = new Map();
          // æ³¢å‹è³‡æ–™å¿«å–
          const waveformCache = new Map();

          // === å·¥å…·å‡½å¼ ===
          const genId = () => 'clip-' + Math.random().toString(36).slice(2, 10);
          const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
          const formatTime = (s) => {
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            const ms = Math.floor((s % 1) * 100);
            return `${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}.${String(ms).padStart(2, '0')}`;
          };

          // === localStorage æŒä¹…åŒ– ===
          const saveState = () => {
            try {
              const data = {
                version: 1,
                playheadTime,
                pxPerSec,
                clips: clips.map(c => ({ ...c })),
                undoStack: undoStack.slice(-HISTORY_LIMIT),
                redoStack: redoStack.slice(-HISTORY_LIMIT)
              };
              localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch (e) { console.warn('[demaPanel] save failed', e); }
          };

          const loadState = () => {
            try {
              const raw = localStorage.getItem(STORAGE_KEY);
              if (!raw) return;
              const data = JSON.parse(raw);
              if (data.version !== 1) return;
              playheadTime = data.playheadTime || 0;
              pxPerSec = clamp(data.pxPerSec || DEFAULT_PX_PER_SEC, MIN_PX_PER_SEC, MAX_PX_PER_SEC);
              clips = (data.clips || []).filter(c => c && c.id && c.soundId);
              undoStack = data.undoStack || [];
              redoStack = data.redoStack || [];
            } catch (e) { console.warn('[demaPanel] load failed', e); }
          };

          // === æ­·å²ç´€éŒ„ï¼ˆUndo/Redoï¼‰===
          /**
           * æ­·å²ç´€éŒ„ç³»çµ±èªªæ˜ï¼š
           * 
           * undoStack: å„²å­˜ã€Œç·¨è¼¯å‰ã€çš„ç‹€æ…‹å¿«ç…§ï¼ˆJSON å­—ä¸²ï¼‰
           * redoStack: å„²å­˜è¢« undo çš„ç‹€æ…‹
           * 
           * æµç¨‹ï¼š
           * 1. é–‹å§‹ç·¨è¼¯å‰ï¼šå‘¼å« pushHistory() å„²å­˜ç•¶å‰ç‹€æ…‹
           * 2. åŸ·è¡Œç·¨è¼¯ï¼šä¿®æ”¹ clips é™£åˆ—
           * 3. ç·¨è¼¯å®Œæˆï¼šå‘¼å« saveState() å„²å­˜åˆ° localStorage
           * 
           * Undo æµç¨‹ï¼š
           * 1. æŠŠç•¶å‰ç‹€æ…‹ push åˆ° redoStack
           * 2. å¾ undoStack pop å‡ºä¹‹å‰çš„ç‹€æ…‹
           * 3. å¥—ç”¨è©²ç‹€æ…‹ä¸¦é‡æ–°æ¸²æŸ“
           * 
           * Redo æµç¨‹ï¼š
           * 1. æŠŠç•¶å‰ç‹€æ…‹ push åˆ° undoStack
           * 2. å¾ redoStack pop å‡ºä¹‹å‰çš„ç‹€æ…‹
           * 3. å¥—ç”¨è©²ç‹€æ…‹ä¸¦é‡æ–°æ¸²æŸ“
           */
          
          /**
           * åœ¨ç·¨è¼¯æ“ä½œé–‹å§‹ã€Œä¹‹å‰ã€å‘¼å«ï¼Œå„²å­˜ç•¶å‰ç‹€æ…‹ä½œç‚ºå¯å¾©åŸçš„å¿«ç…§
           * æ³¨æ„ï¼šå¿…é ˆåœ¨ä»»ä½•ä¿®æ”¹ clips ä¹‹å‰å‘¼å«
           */
          const pushHistory = () => {
            undoStack.push(JSON.stringify(clips));
            if (undoStack.length > HISTORY_LIMIT) undoStack.shift();
            // æ–°çš„ç·¨è¼¯æœƒæ¸…ç©º redo å †ç–Šï¼ˆå› ç‚ºæ™‚é–“ç·šåˆ†æ”¯äº†ï¼‰
            redoStack = [];
            updateHistoryButtons();
          };

          /**
           * å¾©åŸåˆ°ä¸Šä¸€å€‹ç‹€æ…‹
           */
          const undo = () => {
            if (!undoStack.length) return;
            // å…ˆå„²å­˜ç•¶å‰ç‹€æ…‹åˆ° redoStackï¼Œä»¥ä¾¿å¯ä»¥ redo å›ä¾†
            redoStack.push(JSON.stringify(clips));
            // å¾ undoStack å–å‡ºä¹‹å‰çš„ç‹€æ…‹
            clips = JSON.parse(undoStack.pop());
            selectedClipId = null; // æ¸…é™¤é¸æ“‡ä»¥é¿å…æŒ‡å‘å·²åˆªé™¤çš„ clip
            updateHistoryButtons();
            renderClips();
            saveState();
          };

          /**
           * é‡åšè¢«å¾©åŸçš„æ“ä½œ
           */
          const redo = () => {
            if (!redoStack.length) return;
            // å…ˆå„²å­˜ç•¶å‰ç‹€æ…‹åˆ° undoStack
            undoStack.push(JSON.stringify(clips));
            // å¾ redoStack å–å‡ºä¹‹å‰çš„ç‹€æ…‹
            clips = JSON.parse(redoStack.pop());
            selectedClipId = null;
            updateHistoryButtons();
            renderClips();
            saveState();
          };

          /**
           * æ›´æ–° Undo/Redo æŒ‰éˆ•çš„å•Ÿç”¨/ç¦ç”¨ç‹€æ…‹
           */
          const updateHistoryButtons = () => {
            if (els.demaUndo) els.demaUndo.disabled = !undoStack.length;
            if (els.demaRedo) els.demaRedo.disabled = !redoStack.length;
          };

          // === éŸ³è¨Šè¼‰å…¥èˆ‡è§£ç¢¼ ===
          const getAudioContext = () => {
            if (!audioContext) {
              audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
              audioContext.resume();
            }
            return audioContext;
          };

          const loadAudioBuffer = async (url) => {
            if (audioBufferCache.has(url)) {
              return audioBufferCache.get(url);
            }
            const ctx = getAudioContext();
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
            audioBufferCache.set(url, audioBuffer);
            // åŒæ™‚ç”Ÿæˆæ³¢å‹è³‡æ–™
            generateWaveformData(url, audioBuffer);
            return audioBuffer;
          };

          // ç”Ÿæˆæ³¢å‹è³‡æ–™ï¼ˆç°¡åŒ–ç‰ˆï¼Œå–æ¨£é™ä½è§£æåº¦ï¼‰
          
          const generateWaveformData = (url, audioBuffer) => {
            if (waveformCache.has(url)) return;
            const rawData = audioBuffer.getChannelData(0);
            const duration = audioBuffer.duration;
            const totalSamples = Math.ceil(duration * WAVEFORM_SAMPLES_PER_SEC);
            const blockSize = Math.floor(rawData.length / totalSamples);
            const waveform = [];
            for (let i = 0; i < totalSamples; i++) {
              let sum = 0;
              const start = i * blockSize;
              for (let j = 0; j < blockSize; j++) {
                sum += Math.abs(rawData[start + j] || 0);
              }
              waveform.push(sum / blockSize);
            }
            // æ­£è¦åŒ–
            const max = Math.max(...waveform, 0.01);
            const normalized = waveform.map(v => v / max);
            // å„²å­˜æ³¢å‹è³‡æ–™å’ŒéŸ³è¨Šæ™‚é•·
            waveformCache.set(url, { data: normalized, duration });
          };

          // ç¹ªè£½æ³¢å‹åˆ° Canvasï¼ˆæ ¹æ“š trim è£åˆ‡æ­£ç¢ºå€æ®µï¼‰
          const drawWaveform = (canvas, url, trimStart, trimEnd, audioDuration) => {
            const cached = waveformCache.get(url);
            if (!cached || !canvas) return;
            
            const { data: waveform, duration: fullDuration } = cached;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerY = height / 2;
            
            ctx.clearRect(0, 0, width, height);
            // ç™½è‰²æ³¢å‹ï¼Œè¼ƒé«˜å°æ¯”åº¦
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            
            // è¨ˆç®—è¦ç¹ªè£½çš„æ³¢å‹ç¯„åœï¼ˆæ ¹æ“š trimï¼‰
            const startRatio = trimStart / fullDuration;
            const endRatio = 1 - (trimEnd / fullDuration);
            const startIdx = Math.floor(startRatio * waveform.length);
            const endIdx = Math.ceil(endRatio * waveform.length);
            const visibleSamples = endIdx - startIdx;
            
            if (visibleSamples <= 0) return;
            
            // æ¯å€‹æ¨£æœ¬åœ¨ canvas ä¸Šçš„å¯¬åº¦
            const barWidth = width / visibleSamples;
            
            for (let i = 0; i < visibleSamples; i++) {
              const sampleIdx = startIdx + i;
              if (sampleIdx >= waveform.length) break;
              const x = i * barWidth;
              const barHeight = waveform[sampleIdx] * height * 0.85;
              ctx.fillRect(x, centerY - barHeight / 2, Math.max(1, barWidth - 0.5), barHeight);
            }
          };

          // === æ’­æ”¾æ§åˆ¶ ===
          const play = async () => {
            if (isPlaying) return;
            if (clips.length === 0) return;

            const ctx = getAudioContext();
            isPlaying = true;
            playStartTime = ctx.currentTime;
            playStartPosition = playheadTime;
            scheduledSources = [];

            // è¨ˆç®—çµæŸæ™‚é–“
            const endTime = calculateTotalDuration();
            if (playheadTime >= endTime) {
              playheadTime = 0;
              playStartPosition = 0;
            }

            // ç‚ºæ¯å€‹ clip å»ºç«‹éŸ³æº
            for (const clip of clips) {
              const snd = state.soundMap.get(clip.soundId);
              if (!snd) continue;

              try {
                const buffer = await loadAudioBuffer(snd.src);
                const source = ctx.createBufferSource();
                source.buffer = buffer;
                
                // å¥—ç”¨éŸ³é‡ï¼šå…¨åŸŸéŸ³é‡ * ç‰‡æ®µéŸ³é‡
                const gainNode = ctx.createGain();
                const clipVolume = clip.volume ?? 1;
                gainNode.gain.value = (state.globalVolume ?? 1) * clipVolume;
                source.connect(gainNode);
                gainNode.connect(ctx.destination);

                // è¨ˆç®—æ’­æ”¾æ™‚é–“
                const clipStart = clip.startTime;
                const clipDuration = clip.duration - clip.trimStart - clip.trimEnd;
                const clipEnd = clipStart + clipDuration;

                // å¦‚æœ playhead å·²ç¶“è¶…éæ­¤ clipï¼Œè·³é
                if (playheadTime >= clipEnd) continue;

                // è¨ˆç®— offset å’Œ when
                let offset = clip.trimStart;
                let when = 0;
                let duration = clipDuration;

                if (playheadTime > clipStart) {
                  // playhead åœ¨ clip ä¸­é–“
                  offset += (playheadTime - clipStart);
                  duration = clipEnd - playheadTime;
                } else {
                  // playhead åœ¨ clip ä¹‹å‰
                  when = clipStart - playheadTime;
                }

                if (duration > 0) {
                  source.start(ctx.currentTime + when, offset, duration);
                  scheduledSources.push({ source, gainNode });
                }
              } catch (e) {
                console.warn('[demaPanel] failed to play clip', clip.id, e);
              }
            }

            updatePlayPauseIcon();
            startPlayheadAnimation();
          };

          const pause = () => {
            if (!isPlaying) return;
            isPlaying = false;

            // åœæ­¢æ‰€æœ‰éŸ³æº
            for (const { source } of scheduledSources) {
              try {
                source.stop();
              } catch {
                // é æœŸè¡Œç‚ºï¼šéŸ³æºå¯èƒ½å·²è‡ªç„¶çµæŸæˆ–å·²åœæ­¢
              }
            }
            scheduledSources = [];

            // æ›´æ–° playhead ä½ç½®
            if (audioContext) {
              playheadTime = playStartPosition + (audioContext.currentTime - playStartTime);
            }

            stopPlayheadAnimation();
            updatePlayPauseIcon();
            renderPlayhead();
            saveState();
          };

          const stop = () => {
            pause();
            playheadTime = 0;
            renderPlayhead();
            updateTimeDisplay();
            saveState();
          };

          const skipToStart = () => {
            const wasPlaying = isPlaying;
            if (isPlaying) pause();

            let targetTime = 0;
            
            // 1. å°‹æ‰¾èˆ‡ playhead é‡ç–Šçš„ clips
            const overlappingClips = clips.filter(c => 
              c.startTime <= playheadTime && (c.startTime + c.duration) > playheadTime
            );

            if (overlappingClips.length > 0) {
              // å¦‚æœæœ‰å¤šå€‹é‡ç–Šï¼Œé¸æ“‡é–‹å§‹æ™‚é–“æœ€æ—©çš„
              overlappingClips.sort((a, b) => a.startTime - b.startTime);
              targetTime = overlappingClips[0].startTime;
            } else {
              // 2. å¦‚æœæ²’æœ‰é‡ç–Šï¼Œå¾€å‰æœå°‹æœ€è¿‘çš„ä¸€å€‹ clip
              const previousClips = clips.filter(c => c.startTime < playheadTime);
              
              if (previousClips.length > 0) {
                // æ’åºæ‰¾å‡ºæœ€æ¥è¿‘ playhead çš„ (startTime æœ€å¤§)
                previousClips.sort((a, b) => b.startTime - a.startTime);
                targetTime = previousClips[0].startTime;
              } else {
                targetTime = 0;
              }
            }

            playheadTime = targetTime;
            renderPlayhead();
            updateTimeDisplay();

            // æ»¾å‹•è¦–åœ–åˆ° playhead ä½ç½® (ç½®ä¸­)
            const scrollContainer = els.demaTracksScroll?.parentElement;
            if (scrollContainer) {
              const px = playheadTime * pxPerSec;
              const scrollLeft = (px + TRACK_LABEL_WIDTH) - (scrollContainer.clientWidth / 2);
              scrollContainer.scrollLeft = Math.max(0, scrollLeft);
            }

            if (wasPlaying) play();
          };

          const skipToNext = () => {
            const wasPlaying = isPlaying;
            if (isPlaying) pause();

            let targetTime = totalDuration;
            
            // 1. å°‹æ‰¾ playhead ä¹‹å¾Œçš„æ‰€æœ‰ clips
            // æˆ‘å€‘é—œæ³¨çš„æ˜¯ clip çš„ startTime
            const nextClips = clips.filter(c => c.startTime > playheadTime + 0.01); // åŠ ä¸€é»ç·©è¡é¿å…åŸåœ°è¸æ­¥

            if (nextClips.length > 0) {
              // æ’åºæ‰¾å‡ºæœ€æ¥è¿‘ playhead çš„ (startTime æœ€å°)
              nextClips.sort((a, b) => a.startTime - b.startTime);
              targetTime = nextClips[0].startTime;
            } else {
              // å¦‚æœå¾Œé¢æ²’æœ‰ clipï¼Œè·³åˆ°å…¨é«”è»Œé“ä¸Šæ™‚é–“æœ€æ™šçš„ clip çš„çµå°¾
              if (clips.length > 0) {
                let maxEnd = 0;
                for (const clip of clips) {
                  const duration = clip.duration - clip.trimStart - clip.trimEnd;
                  const end = clip.startTime + duration;
                  if (end > maxEnd) maxEnd = end;
                }
                targetTime = maxEnd;
              } else {
                targetTime = totalDuration;
              }
            }

            playheadTime = targetTime;
            renderPlayhead();
            updateTimeDisplay();

            // æ»¾å‹•è¦–åœ–åˆ° playhead ä½ç½® (ç½®ä¸­)
            const scrollContainer = els.demaTracksScroll?.parentElement;
            if (scrollContainer) {
              const px = playheadTime * pxPerSec;
              const scrollLeft = (px + TRACK_LABEL_WIDTH) - (scrollContainer.clientWidth / 2);
              scrollContainer.scrollLeft = Math.max(0, scrollLeft);
            }

            if (wasPlaying) play();
          };

          const updatePlayPauseIcon = () => {
            if (els.demaPlayIcon) els.demaPlayIcon.style.display = isPlaying ? 'none' : 'block';
            if (els.demaPauseIcon) els.demaPauseIcon.style.display = isPlaying ? 'block' : 'none';
            
            if (els.demaPlayPause) {
              els.demaPlayPause.style.background = isPlaying ? 'var(--accent-2)' : 'var(--accent)';
              els.demaPlayPause.style.borderColor = isPlaying ? 'var(--accent-2)' : 'var(--accent)';
            }
          };

          // === Playhead å‹•ç•« ===
          const startPlayheadAnimation = () => {
            const animate = () => {
              if (!isPlaying) return;

              const ctx = getAudioContext();
              playheadTime = playStartPosition + (ctx.currentTime - playStartTime);

              const endTime = calculateTotalDuration();
              if (playheadTime >= endTime) {
                playheadTime = endTime;
                pause();
                return;
              }

              renderPlayhead();
              updateTimeDisplay();
              animationFrameId = requestAnimationFrame(animate);
            };
            animationFrameId = requestAnimationFrame(animate);
          };

          const stopPlayheadAnimation = () => {
            if (animationFrameId) {
              cancelAnimationFrame(animationFrameId);
              animationFrameId = null;
            }
          };

          // === è¨ˆç®—ç¸½æ™‚é•· ===
          const calculateTotalDuration = () => {
            if (clips.length === 0) return 30;
            let maxEnd = 0;
            for (const clip of clips) {
              const end = clip.startTime + (clip.duration - clip.trimStart - clip.trimEnd);
              if (end > maxEnd) maxEnd = end;
            }
            return Math.max(30, Math.ceil(maxEnd) + 5);
          };

          // === æ¸²æŸ“å‡½å¼ ===
          const renderTimeline = () => {
            const canvas = els.demaTimelineCanvas;
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const width = totalDuration * pxPerSec + TRACK_LABEL_WIDTH;
            // å¾ CSS å–å¾—å¯¦éš›é«˜åº¦ï¼Œé¿å…æ‹‰ä¼¸
            const cssHeight = container?.clientHeight || 25;
            const height = cssHeight;
            
            // è¨­å®š canvas å¯¦éš›åƒç´ å¤§å°ï¼ˆé¿å…æ¨¡ç³Šå’Œæ‹‰ä¼¸ï¼‰
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            ctx.clearRect(0, 0, width, height);

            // å–å¾— CSS è®Šæ•¸é¡è‰²
            const style = getComputedStyle(document.documentElement);
            const fg = style.getPropertyValue('--fg').trim() || '#e9eef5';
            const muted = style.getPropertyValue('--muted').trim() || '#a8b3c7';

            ctx.font = '10px ui-sans-serif, system-ui, sans-serif';
            ctx.textBaseline = 'middle';

            // æ ¹æ“šç¸®æ”¾ç´šåˆ¥æ±ºå®šåˆ»åº¦é–“éš”
            let interval = 1; // ç§’
            if (pxPerSec < 80) interval = 5;
            else if (pxPerSec < 150) interval = 2;
            else if (pxPerSec < 300) interval = 1;
            else if (pxPerSec < 500) interval = 0.5;
            else interval = 0.25;

            const tickHeight = 6;
            const textY = height / 2; // æ–‡å­—å‚ç›´ç½®ä¸­

            for (let t = 0; t <= totalDuration; t += interval) {
              const x = TRACK_LABEL_WIDTH + t * pxPerSec;
              
              // ä¸»åˆ»åº¦ç·šï¼ˆå¾åº•éƒ¨å‘ä¸Šï¼‰
              ctx.fillStyle = muted;
              ctx.fillRect(x, height - tickHeight, 1, tickHeight);
              
              // æ™‚é–“æ–‡å­—ï¼ˆå°é½Šåˆ»åº¦ç·šï¼‰
              if (t % (interval < 1 ? 1 : interval) === 0 || interval >= 1) {
                const text = formatTime(t).slice(0, 5); // åªé¡¯ç¤º mm:ss
                ctx.fillStyle = fg;
                ctx.fillText(text, x + 3, textY);
              }
            }
          };

          const renderPlayhead = () => {
            if (!els.demaPlayhead) return;
            const x = TRACK_LABEL_WIDTH + playheadTime * pxPerSec;
            els.demaPlayhead.style.left = x + 'px';
          };

          const updateTimeDisplay = () => {
            if (!els.demaTime) return;
            totalDuration = calculateTotalDuration();
            els.demaTime.textContent = `${formatTime(playheadTime)} / ${formatTime(totalDuration)}`;
          };

          // ç”¨æ–¼æ‹–æ›³æ™‚é¿å…é‡æ–°æ¸²æŸ“å°è‡´äº‹ä»¶ä¸Ÿå¤±
          let isDragging = false;

          const renderClips = () => {
            // å¦‚æœæ­£åœ¨æ‹–æ›³ä¸­ï¼Œåªæ›´æ–°ä½ç½®ä¸é‡å»º DOM
            if (isDragging) {
              updateClipPositions();
              return;
            }

            // æ¸…ç©ºæ‰€æœ‰éŸ³è»Œå…§å®¹
            els.demaTrackContents.forEach(tc => tc.innerHTML = '');
            
            // æ›´æ–°ç©ºç‹€æ…‹
            if (els.demaEmpty) {
              els.demaEmpty.style.display = clips.length === 0 ? 'flex' : 'none';
            }

            // æ¸²æŸ“æ¯å€‹ clip
            for (const clip of clips) {
              const snd = state.soundMap.get(clip.soundId);
              if (!snd) continue;

              const trackContent = document.querySelector(`[data-track-content="${clip.trackIndex}"]`);
              if (!trackContent) continue;

              // å–å¾— streamer æ¨™ç±¤é¡è‰²
              let color = '#6aa9ff';
              for (const tagKey of snd.tags) {
                const tag = state.tags[utils.slug(tagKey)];
                if (tag?.role === 'streamer' && tag.color) {
                  color = tag.color;
                  break;
                }
              }

              const clipDuration = clip.duration - clip.trimStart - clip.trimEnd;
              const width = Math.max(20, clipDuration * pxPerSec);
              const left = clip.startTime * pxPerSec + CLIP_VISUAL_OFFSET; // [HACK] è¦–è¦ºåç§»ï¼Œè¦‹ CLIP_VISUAL_OFFSET å®šç¾©

              // å»ºç«‹æ³¢å‹ canvasï¼ˆé«˜åº¦é…åˆéŸ³è»Œé«˜åº¦ 30px - 4px padding = 26pxï¼‰
              const waveCanvas = document.createElement('canvas');
              waveCanvas.width = Math.max(20, Math.floor(width));
              waveCanvas.height = 26;
              waveCanvas.className = 'dema-clip-wave-canvas';

              const clipEl = dom.el('div', {
                class: `dema-clip${clip.id === selectedClipId ? ' selected' : ''}`,
                'data-clip-id': clip.id,
                style: {
                  left: left + 'px',
                  width: width + 'px',
                  background: color
                }
              }, [
                dom.el('div', { class: 'dema-clip-wave' }, [waveCanvas]),
                dom.el('div', { class: 'dema-clip-label' }, snd.title),
                dom.el('div', { class: 'dema-clip-handle dema-clip-handle--left' }),
                dom.el('div', { class: 'dema-clip-handle dema-clip-handle--right' })
              ]);

              // ç¹ªè£½æ³¢å‹
              if (waveformCache.has(snd.src)) {
                drawWaveform(waveCanvas, snd.src, clip.trimStart, clip.trimEnd, clip.duration);
              } else {
                // éåŒæ­¥è¼‰å…¥ä¸¦ç¹ªè£½
                loadAudioBuffer(snd.src).then(() => {
                  drawWaveform(waveCanvas, snd.src, clip.trimStart, clip.trimEnd, clip.duration);
                }).catch((e) => {
                  console.warn('[demaPanel] ç„¡æ³•è¼‰å…¥éŸ³è¨Šæ³¢å‹', snd.src, e);
                });
              }

              // äº‹ä»¶ç¶å®š
              clipEl.addEventListener('pointerdown', e => onClipPointerDown(e, clip));
              clipEl.addEventListener('dblclick', e => onClipDoubleClick(e, clip));

              trackContent.appendChild(clipEl);
            }

            // æ›´æ–°éŸ³è»Œå®¹å™¨å¯¬åº¦
            updateTracksWidth();
            updateTimeDisplay();
            updateRemoveSelectedBtn();
            updateVolumeSlider();
          };

          // åªæ›´æ–° clip ä½ç½®ï¼ˆç”¨æ–¼æ‹–æ›³æ™‚ï¼‰
          const updateClipPositions = () => {
            for (const clip of clips) {
              const clipEl = document.querySelector(`[data-clip-id="${clip.id}"]`);
              if (!clipEl) continue;

              const clipDuration = clip.duration - clip.trimStart - clip.trimEnd;
              const width = Math.max(20, clipDuration * pxPerSec);
              const left = clip.startTime * pxPerSec + CLIP_VISUAL_OFFSET; // [HACK] è¦–è¦ºåç§»ï¼Œè¦‹ CLIP_VISUAL_OFFSET å®šç¾©

              clipEl.style.left = left + 'px';
              clipEl.style.width = width + 'px';

              // æ›´æ–°é¸ä¸­ç‹€æ…‹
              clipEl.classList.toggle('selected', clip.id === selectedClipId);

              // æª¢æŸ¥æ˜¯å¦éœ€è¦ç§»å‹•åˆ°å…¶ä»–éŸ³è»Œ
              const currentTrack = clipEl.closest('[data-track-content]');
              const targetTrack = document.querySelector(`[data-track-content="${clip.trackIndex}"]`);
              if (currentTrack && targetTrack && currentTrack !== targetTrack) {
                targetTrack.appendChild(clipEl);
              }

              // Trim æ™‚éœ€è¦é‡ç¹ªæ³¢å‹
              const waveCanvas = clipEl.querySelector('.dema-clip-wave-canvas');
              if (waveCanvas) {
                const snd = state.soundMap.get(clip.soundId);
                if (snd) {
                  // æ›´æ–° canvas å°ºå¯¸
                  waveCanvas.width = Math.max(20, Math.floor(width));
                  drawWaveform(waveCanvas, snd.src, clip.trimStart, clip.trimEnd, clip.duration);
                }
              }
            }
            updateTimeDisplay();
          };

          // æ›´æ–°ã€Œç§»é™¤é¸æ“‡ã€æŒ‰éˆ•ç‹€æ…‹
          const updateRemoveSelectedBtn = () => {
            if (els.demaRemoveSelected) {
              els.demaRemoveSelected.disabled = !selectedClipId;
            }
          };

          // æ›´æ–°ç‰‡æ®µéŸ³é‡æ»‘æ¡¿
          const updateVolumeSlider = () => {
            if (!els.demaClipVolumeWrap) return;
            
            if (!selectedClipId) {
              els.demaClipVolumeWrap.style.display = 'none';
              return;
            }

            const clip = clips.find(c => c.id === selectedClipId);
            if (!clip) {
              els.demaClipVolumeWrap.style.display = 'none';
              return;
            }

            els.demaClipVolumeWrap.style.display = 'flex';
            const volumePercent = Math.round((clip.volume ?? 1) * 100);
            els.demaClipVolume.value = volumePercent;
            els.demaClipVolumeValue.textContent = volumePercent + '%';
          };

          const updateTracksWidth = () => {
            totalDuration = calculateTotalDuration();
            const width = totalDuration * pxPerSec + TRACK_LABEL_WIDTH;
            if (els.demaTracksScroll) {
              els.demaTracksScroll.style.minWidth = width + 'px';
            }
            renderTimeline();
          };

          // === Clip æ“ä½œ ===
          const addClip = async (snd, trackIndex = 0, startTime = null) => {
            // è¼‰å…¥éŸ³è¨Šä»¥å–å¾—æ™‚é•·
            let duration = 3; // é è¨­ 3 ç§’
            try {
              const buffer = await loadAudioBuffer(snd.src);
              duration = buffer.duration;
            } catch (e) {
              console.warn('[demaPanel] failed to get duration', e);
            }

            const newClip = {
              id: genId(),
              soundId: snd.id,
              trackIndex: clamp(trackIndex, 0, TRACK_COUNT - 1),
              startTime: startTime ?? playheadTime,
              trimStart: 0,
              trimEnd: 0,
              duration,
              volume: 1.0  // ç‰‡æ®µéŸ³é‡ï¼ˆ1.0 = 100%ï¼‰
            };

            pushHistory();
            clips.push(newClip);
            selectedClipId = newClip.id;
            renderClips();
            saveState();

            return newClip;
          };

          const removeClip = (clipId) => {
            const idx = clips.findIndex(c => c.id === clipId);
            if (idx === -1) return;
            pushHistory();
            clips.splice(idx, 1);
            if (selectedClipId === clipId) selectedClipId = null;
            renderClips();
            saveState();
          };

          const clearAllClips = () => {
            if (clips.length === 0 && undoStack.length === 0 && redoStack.length === 0) return;
            
            // å»ºç«‹ç¢ºèª Modal
            const backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop';
            backdrop.setAttribute('role', 'dialog');
            backdrop.setAttribute('aria-modal', 'true');
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
              <p style="margin: 0 0 var(--space-sm); font-size: 14px;">ç¢ºå®šè¦é‡ç½®æ‰€æœ‰éŸ³è»Œå—ï¼Ÿ</p>
              <p style="margin: 0 0 var(--space-sm); font-size: 12px; color: var(--muted);">é€™å°‡æ¸…ç©ºæ‰€æœ‰ç‰‡æ®µå’Œæ­¥é©Ÿç´€éŒ„ã€‚</p>
              <div class="modal-actions">
                <button class="btn" data-action="cancel">å–æ¶ˆ</button>
                <button class="btn" data-action="confirm">ç¢ºå®šé‡ç½®</button>
              </div>
            `;
            backdrop.appendChild(modal);
            document.body.appendChild(backdrop);
            
            // ç„¦é»è¨­åˆ°å–æ¶ˆæŒ‰éˆ•
            modal.querySelector('[data-action="cancel"]').focus();
            
            // äº‹ä»¶è™•ç†
            const closeModal = () => backdrop.remove();
            
            backdrop.addEventListener('click', e => {
              if (e.target === backdrop) closeModal();
            });
            
            modal.querySelector('[data-action="cancel"]').addEventListener('click', closeModal);
            
            modal.querySelector('[data-action="confirm"]').addEventListener('click', () => {
              closeModal();
              // é‡ç½®æ‰€æœ‰ç‹€æ…‹
              clips = [];
              selectedClipId = null;
              undoStack = [];
              redoStack = [];
              playheadTime = 0;
              renderClips();
              renderPlayhead();
              updateHistoryButtons();
              saveState();
              toast('å·²é‡ç½®æ‰€æœ‰éŸ³è»Œ');
            });
            
            // ESC é—œé–‰
            const onKeydown = e => {
              if (e.key === 'Escape') {
                closeModal();
                document.removeEventListener('keydown', onKeydown);
              }
            };
            document.addEventListener('keydown', onKeydown);
          };

          // === æ‹–æ›³èˆ‡ Trim ===
          const onClipPointerDown = (e, clip) => {
            e.stopPropagation();
            e.preventDefault(); // é˜²æ­¢é¸å–æ–‡å­—ç­‰é è¨­è¡Œç‚º
            
            // åˆ¤æ–·æ˜¯å¦åœ¨ handle ä¸Š
            const target = e.target;
            const isLeftHandle = target.classList.contains('dema-clip-handle--left');
            const isRightHandle = target.classList.contains('dema-clip-handle--right');

            // é¸æ“‡æ­¤ clip
            selectedClipId = clip.id;
            
            // æ›´æ–°é¸ä¸­ç‹€æ…‹ï¼ˆä¸é‡å»º DOMï¼‰
            document.querySelectorAll('.dema-clip').forEach(el => {
              el.classList.toggle('selected', el.dataset.clipId === clip.id);
            });
            
            // æ›´æ–° UI
            updateRemoveSelectedBtn();
            updateVolumeSlider();

            // æº–å‚™æ‹–æ›³
            const clipEl = e.currentTarget;
            const rect = clipEl.getBoundingClientRect();

            // æ±ºå®šæ¨¡å¼
            let mode = 'pending';
            if (isLeftHandle) {
              mode = 'trim-left';
            } else if (isRightHandle) {
              mode = 'trim-right';
            }

            dragState = {
              clipId: clip.id,
              mode: mode,
              startX: e.clientX,
              startY: e.clientY,
              initialStartTime: clip.startTime,
              initialTrimStart: clip.trimStart,
              initialTrimEnd: clip.trimEnd,
              initialTrackIndex: clip.trackIndex,
              moved: false
            };

            // å°æ–¼ trim æ¨¡å¼ï¼Œç«‹å³å•Ÿå‹•
            if (mode === 'trim-left' || mode === 'trim-right') {
              // åœ¨é–‹å§‹ç·¨è¼¯å‰å„²å­˜æ­·å²
              pushHistory();
              isDragging = true;
              clipEl.classList.add('dragging');
            }
            // ç§»å‹•ç«¯ï¼šé•·æŒ‰æ‰å•Ÿå‹•æ‹–æ›³
            else if (e.pointerType === 'touch') {
              longPressTimer = setTimeout(() => {
                if (dragState && dragState.mode === 'pending') {
                  // åœ¨é–‹å§‹ç·¨è¼¯å‰å„²å­˜æ­·å²
                  pushHistory();
                  dragState.mode = 'move';
                  isDragging = true;
                  clipEl.classList.add('dragging');
                }
              }, MOBILE_DRAG_DELAY);
            } else {
              // PCï¼šç›´æ¥é€²å…¥ç§»å‹•æ¨¡å¼
              // åœ¨é–‹å§‹ç·¨è¼¯å‰å„²å­˜æ­·å²
              pushHistory();
              dragState.mode = 'move';
              isDragging = true;
              clipEl.classList.add('dragging');
            }

            // è¨­ç½® pointer capture ç¢ºä¿æ‹–æ›³ä¸æœƒä¸Ÿå¤±
            clipEl.setPointerCapture(e.pointerId);

            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
            document.addEventListener('pointercancel', onPointerUp);
          };

          const onPointerMove = (e) => {
            if (!dragState) return;

            const dx = e.clientX - dragState.startX;
            const dy = e.clientY - dragState.startY;
            const clip = clips.find(c => c.id === dragState.clipId);
            if (!clip) return;

            // å¦‚æœç§»å‹•è¶…éé–¾å€¼ï¼Œå–æ¶ˆé•·æŒ‰è¨ˆæ™‚ä¸¦ç¢ºèªç‚ºæ‹–æ›³
            if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
              if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
              }
              if (dragState.mode === 'pending') {
                dragState.mode = 'move';
                isDragging = true;
                const clipEl = document.querySelector(`[data-clip-id="${clip.id}"]`);
                if (clipEl) clipEl.classList.add('dragging');
              }
              dragState.moved = true;
            }

            // å¦‚æœé‚„åœ¨ pending ç‹€æ…‹ï¼Œä¸åŸ·è¡Œç§»å‹•
            if (dragState.mode === 'pending') return;

            if (dragState.mode === 'move') {
              // ç§»å‹• clip
              const deltaTime = dx / pxPerSec;
              clip.startTime = Math.max(0, dragState.initialStartTime + deltaTime);

              // è·¨éŸ³è»Œæª¢æ¸¬
              const trackEls = document.querySelectorAll('.dema-track');
              for (let i = 0; i < trackEls.length; i++) {
                const rect = trackEls[i].getBoundingClientRect();
                if (e.clientY >= rect.top && e.clientY <= rect.bottom) {
                  clip.trackIndex = i;
                  break;
                }
              }

              updateClipPositions();
            } else if (dragState.mode === 'trim-left') {
              // å·¦å´ Trim
              const deltaTime = dx / pxPerSec;
              
              // é™åˆ¶ï¼šä¸èƒ½è®“ startTime < 0
              // startTime = initialStartTime + (newTrimStart - initialTrimStart)
              // æ‰€ä»¥ newTrimStart >= initialTrimStart - initialStartTime
              const minTrimStart = Math.max(0, dragState.initialTrimStart - dragState.initialStartTime);

              const newTrimStart = clamp(
                dragState.initialTrimStart + deltaTime,
                minTrimStart,
                clip.duration - clip.trimEnd - 0.1
              );
              const trimDelta = newTrimStart - dragState.initialTrimStart;
              clip.trimStart = newTrimStart;
              clip.startTime = dragState.initialStartTime + trimDelta;
              updateClipPositions();
            } else if (dragState.mode === 'trim-right') {
              // å³å´ Trim
              const deltaTime = dx / pxPerSec;
              clip.trimEnd = clamp(
                dragState.initialTrimEnd - deltaTime,
                0,
                clip.duration - clip.trimStart - 0.1
              );
              updateClipPositions();
            }
          };

          const onPointerUp = (e) => {
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }

            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', onPointerUp);
            document.removeEventListener('pointercancel', onPointerUp);

            // é‡‹æ”¾ pointer capture
            try {
              const clipEl = document.querySelector(`[data-clip-id="${dragState?.clipId}"]`);
              if (clipEl && e.pointerId) clipEl.releasePointerCapture(e.pointerId);
            } catch {
              // é æœŸè¡Œç‚ºï¼šcapture å¯èƒ½å·²é‡‹æ”¾æˆ–å…ƒç´ å·²ç§»é™¤
            }

            isDragging = false;

            // å¦‚æœæœ‰å¯¦éš›ç§»å‹•/ç·¨è¼¯ï¼Œå„²å­˜ç‹€æ…‹åˆ° localStorage
            // æ³¨æ„ï¼špushHistory å·²ç¶“åœ¨æ‹–æ›³é–‹å§‹æ™‚å‘¼å«éäº†
            if (dragState?.moved) {
              saveState();
            }

            // æ¸…é™¤ dragging ç‹€æ…‹
            document.querySelectorAll('.dema-clip.dragging').forEach(el => el.classList.remove('dragging'));
            dragState = null;

            renderClips();
          };

          // === Clip é¸å–®ï¼ˆç§»å‹•ç«¯é›™æ“Š/PCå³éµï¼‰===
          const onClipDoubleClick = (e, clip) => {
            e.stopPropagation();
            showClipMenu(clip, e.clientX, e.clientY);
          };

          const showClipMenu = (clip, x, y) => {
            const m = els.menu;
            if (!m) return;
            m.innerHTML = '';

            const snd = state.soundMap.get(clip.soundId);
            const playItem = dom.el('div', { class: 'menu-item', role: 'menuitem' }, 'â–¶ï¸ è©¦è½');
            playItem.addEventListener('click', () => {
              closeMenu();
              if (snd) playSoundObject(snd);
            });

            const removeItem = dom.el('div', { class: 'menu-item', role: 'menuitem' }, 'ğŸ—‘ï¸ ç§»é™¤');
            removeItem.addEventListener('click', () => {
              closeMenu();
              removeClip(clip.id);
            });

            m.append(playItem, removeItem);
            m.classList.remove('hidden');
            requestAnimationFrame(() => positionMenu(x, y));
          };

          // === éŸ³è»Œå€åŸŸäº‹ä»¶ï¼ˆæ‹–æ›³æ»¾å‹• + é»æ“Šè¨­å®š playheadï¼‰===
          let tracksDragState = null;

          const onTracksPointerDown = (e) => {
            // å¦‚æœé»æ“Šçš„æ˜¯ clipï¼Œä¸è™•ç†æ»¾å‹•
            if (e.target.closest('.dema-clip')) return;
            
            const scrollContainer = els.demaTracksScroll?.parentElement;
            if (!scrollContainer) return;
            
            tracksDragState = {
              startX: e.clientX,
              startY: e.clientY,
              startScrollLeft: scrollContainer.scrollLeft,
              moved: false
            };
            
            scrollContainer.classList.add('dragging');
            scrollContainer.setPointerCapture(e.pointerId);
          };

          const onTracksPointerMove = (e) => {
            if (!tracksDragState) return;
            
            const dx = e.clientX - tracksDragState.startX;
            const dy = e.clientY - tracksDragState.startY;
            
            // å¦‚æœç§»å‹•è¶…éé–¾å€¼ï¼Œæ¨™è¨˜ç‚ºæ‹–æ›³
            if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
              tracksDragState.moved = true;
            }
            
            if (tracksDragState.moved) {
              const scrollContainer = els.demaTracksScroll?.parentElement;
              if (scrollContainer) {
                scrollContainer.scrollLeft = tracksDragState.startScrollLeft - dx;
              }
            }
          };

          const onTracksPointerUp = (e) => {
            if (!tracksDragState) return;
            
            const scrollContainer = els.demaTracksScroll?.parentElement;
            if (scrollContainer) {
              scrollContainer.classList.remove('dragging');
              try {
                scrollContainer.releasePointerCapture(e.pointerId);
              } catch {
                // é æœŸè¡Œç‚ºï¼šcapture å¯èƒ½å·²é‡‹æ”¾
              }
            }
            
            // å¦‚æœæ²’æœ‰ç§»å‹•ï¼Œè¦–ç‚ºé»æ“Šï¼Œè¨­å®š playhead
            if (!tracksDragState.moved) {
              onTracksClick(e);
            }
            
            tracksDragState = null;
          };

          const onTracksClick = (e) => {
            // å¦‚æœé»æ“Šçš„æ˜¯ clipï¼Œä¸è™•ç†
            if (e.target.closest('.dema-clip')) return;
            
            // å–æ¶ˆé¸æ“‡
            selectedClipId = null;
            renderClips();

            // è¨­å®š playhead
            // ä½¿ç”¨æ»¾å‹•å®¹å™¨ï¼ˆçˆ¶å…ƒç´ ï¼‰çš„ rectï¼Œè€Œä¸æ˜¯å…§å®¹å€åŸŸ
            const scrollContainer = els.demaTracksScroll?.parentElement;
            if (!scrollContainer) return;
            
            const rect = scrollContainer.getBoundingClientRect();
            const scrollLeft = scrollContainer.scrollLeft;
            // clientX - rect.left = é»æ“Šä½ç½®ç›¸å°æ–¼æ»¾å‹•å®¹å™¨è¦–çª—çš„ x
            // + scrollLeft = åŠ ä¸Šå·²æ»¾å‹•çš„è·é›¢ï¼Œå¾—åˆ°ç›¸å°æ–¼å…§å®¹èµ·é»çš„ x
            // - TRACK_LABEL_WIDTH = æ¸›å»å·¦å´æ¨™ç±¤å¯¬åº¦ï¼Œå¾—åˆ°ç›¸å°æ–¼æ™‚é–“è»¸ 0 é»çš„ x
            const x = e.clientX - rect.left + scrollLeft - TRACK_LABEL_WIDTH;
            
            if (x >= 0) {
              const wasPlaying = isPlaying;
              if (isPlaying) pause();
              playheadTime = clamp(x / pxPerSec, 0, totalDuration);
              renderPlayhead();
              updateTimeDisplay();
              saveState();
              if (wasPlaying) play();
            }
          };

          // === ç¸®æ”¾æ§åˆ¶ ===
          const setZoom = (newPxPerSec) => {
            // ä¿æŒ playhead è¦–è¦ºä½ç½®ç©©å®š
            const container = els.demaTracksScroll?.parentElement;
            if (!container) return;

            const scrollLeft = container.scrollLeft;
            const viewportCenter = scrollLeft + container.clientWidth / 2;
            const centerTime = (viewportCenter - TRACK_LABEL_WIDTH) / pxPerSec;

            pxPerSec = clamp(newPxPerSec, MIN_PX_PER_SEC, MAX_PX_PER_SEC);

            // æ›´æ–°æ»¾å‹•ä½ç½®ä»¥ä¿æŒä¸­å¿ƒæ™‚é–“ä¸è®Š
            const newScrollLeft = (centerTime * pxPerSec + TRACK_LABEL_WIDTH) - container.clientWidth / 2;
            container.scrollLeft = Math.max(0, newScrollLeft);

            renderClips();
            renderPlayhead();
            saveState();

            if (els.demaZoom) els.demaZoom.value = pxPerSec;
          };

          // === é¢æ¿é–‹é—œ ===
          const open = () => {
            if (isOpen) return;
            isOpen = true;
            els.demaPanel?.classList.add('open');
            els.demaPanel?.setAttribute('aria-hidden', 'false');
            document.body.classList.add('dema-open');
            renderClips();
            renderPlayhead();
            updateTimeDisplay();
          };

          const close = () => {
            if (!isOpen) return;
            pause();
            isOpen = false;
            els.demaPanel?.classList.remove('open');
            els.demaPanel?.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('dema-open');
          };

          const toggle = () => isOpen ? close() : open();

          // === å…¬é–‹ APIï¼šåŠ å…¥éŸ³æ•ˆ ===
          const addSoundToTrack = async (snd, trackIndex = 0) => {
            if (!isOpen) open();
            await addClip(snd, trackIndex);
          };

          // === åˆå§‹åŒ– ===
          const init = () => {
            loadState();

            // æŒ‰éˆ•äº‹ä»¶
            els.openDemaBtn?.addEventListener('click', open);
            els.demaClose?.addEventListener('click', close);
            els.demaPlayPause?.addEventListener('click', () => isPlaying ? pause() : play());
            els.demaSkipNext?.addEventListener('click', skipToNext);
            els.demaSkipBack?.addEventListener('click', skipToStart);
            els.demaUndo?.addEventListener('click', undo);
            els.demaRedo?.addEventListener('click', redo);
            els.demaClear?.addEventListener('click', clearAllClips);
            els.demaRemoveSelected?.addEventListener('click', () => {
              if (selectedClipId) removeClip(selectedClipId);
            });

            // ç¸®æ”¾æ»‘æ¡¿
            els.demaZoom?.addEventListener('input', (e) => {
              setZoom(parseInt(e.target.value, 10));
            });
            if (els.demaZoom) els.demaZoom.value = pxPerSec;

            // ç‰‡æ®µéŸ³é‡æ»‘æ¡¿ - é–‹å§‹æ‹–æ›³æ™‚å„²å­˜æ­·å²
            let volumeHistorySaved = false;
            els.demaClipVolume?.addEventListener('pointerdown', () => {
              volumeHistorySaved = false;
            });
            
            els.demaClipVolume?.addEventListener('input', (e) => {
              if (!selectedClipId) return;
              const clip = clips.find(c => c.id === selectedClipId);
              if (!clip) return;
              
              // é¦–æ¬¡è®Šæ›´æ™‚å„²å­˜æ­·å²
              if (!volumeHistorySaved) {
                pushHistory();
                volumeHistorySaved = true;
              }
              
              const volumePercent = parseInt(e.target.value, 10);
              clip.volume = volumePercent / 100;
              els.demaClipVolumeValue.textContent = volumePercent + '%';
              saveState();
            });

            // éŸ³è»Œå€åŸŸæ‹–æ›³æ»¾å‹• + é»æ“Š
            const tracksWrap = els.demaTracksScroll?.parentElement;
            if (tracksWrap) {
              tracksWrap.addEventListener('pointerdown', onTracksPointerDown);
              tracksWrap.addEventListener('pointermove', onTracksPointerMove);
              tracksWrap.addEventListener('pointerup', onTracksPointerUp);
              tracksWrap.addEventListener('pointercancel', onTracksPointerUp);
            }

            // éµç›¤å¿«æ·éµ
            document.addEventListener('keydown', (e) => {
              if (!isOpen) return;
              // æª¢æŸ¥æ˜¯å¦åœ¨è¼¸å…¥æ¡†å…§
              if (e.target.matches('input, textarea, [contenteditable]')) return;

              if (e.key === ' ') {
                e.preventDefault();
                isPlaying ? pause() : play();
              } else if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedClipId) {
                  e.preventDefault();
                  removeClip(selectedClipId);
                }
              } else if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') {
                  e.preventDefault();
                  if (e.shiftKey) redo();
                  else undo();
                } else if (e.key === 'y') {
                  e.preventDefault();
                  redo();
                }
              }
            });

            // åˆå§‹æ¸²æŸ“
            updateHistoryButtons();
            updateTracksWidth();
            renderClips();
            renderPlayhead();
            updateTimeDisplay();

            console.info('[demaPanel] initialized');
          };

          // å»¶é²åˆå§‹åŒ–ï¼ˆç­‰å¾… DOM æº–å‚™ï¼‰
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
          } else {
            setTimeout(init, 0);
          }

          // å…¬é–‹ API
          return {
            open,
            close,
            toggle,
            addSoundToTrack,
            play,
            pause,
            stop
          };
        })();

        /* =======================================================================
           16. æ§åˆ¶å°è¨ºæ–·ç³»çµ± (SoundboardDebug)
           
           æä¾›é–‹ç™¼è€…åœ¨ç€è¦½å™¨æ§åˆ¶å°æª¢æŸ¥æ‡‰ç”¨ç¨‹å¼ç‹€æ…‹ã€åŸ·è¡Œæ¸¬è©¦çš„å·¥å…·ã€‚
           ä½¿ç”¨æ–¹å¼ï¼šåœ¨æ§åˆ¶å°è¼¸å…¥ SoundboardDebug.help() ç²å–æŒ‡å—ã€‚
           ======================================================================= */

        const SoundboardDebug = (() => {
          const VERSION = '1.0.0';

          // ===== å·¥å…·å‡½å¼ =====
          const fmt = {
            title: (text) => console.log(`%câ•â•â• ${text} â•â•â•`, 'color: #6aa9ff; font-weight: bold; font-size: 14px;'),
            section: (text) => console.log(`%câ–¸ ${text}`, 'color: #ff9e6a; font-weight: bold;'),
            ok: (text) => console.log(`%câœ… ${text}`, 'color: #4ade80;'),
            warn: (text) => console.log(`%câš ï¸ ${text}`, 'color: #fbbf24;'),
            error: (text) => console.log(`%câŒ ${text}`, 'color: #f87171;'),
            info: (text) => console.log(`%câ„¹ï¸ ${text}`, 'color: #94a3b8;'),
            list: (items, indent = '   ') => items.forEach(item => console.log(`${indent}â€¢ ${item}`))
          };

          // ===== A. ç‹€æ…‹å ±å‘Š =====
          const status = () => {
            fmt.title('ğŸ“Š éŸ³æ•ˆæ¿ç‹€æ…‹å ±å‘Š');

            // A.1 éŸ³æ•ˆæ•¸é‡çµ±è¨ˆ
            fmt.section('éŸ³æ•ˆçµ±è¨ˆ');
            console.log(`   è¼‰å…¥éŸ³æ•ˆæ•¸é‡: ${state.sounds.length} ç­†`);
            console.log(`   soundMap å¤§å°: ${state.soundMap.size} ç­†`);
            console.log(`   æœ€æ„›æ•¸é‡: ${state.favorites.length} ç­†`);
            console.log(`   ç›®å‰é¡¯ç¤ºåˆ—è¡¨: ${state.displayList.length} ç­†`);
            console.log(`   å·²æ¸²æŸ“æ•¸é‡: ${state.renderedCount} ç­†`);

            // A.2 æ¨™ç±¤çµ±è¨ˆ
            fmt.section('æ¨™ç±¤çµ±è¨ˆ');
            console.log(`   tags.json å®šç¾©: ${state.tagList.length} å€‹`);
            console.log(`   å¯¦éš›è¢«ä½¿ç”¨: ${state.usedTagList.length} å€‹`);

            // A.3 å­¤å…’æ¨™ç±¤æª¢æ¸¬ï¼ˆéŸ³æ•ˆä½¿ç”¨ä½† tags.json æœªå®šç¾©ï¼‰
            const definedKeys = new Set(state.tagList.map(t => t.key));
            const usedInSounds = new Set();
            state.sounds.forEach(snd => snd.tags.forEach(t => usedInSounds.add(utils.slug(t))));
            const orphanTags = [...usedInSounds].filter(k => !definedKeys.has(k));

            if (orphanTags.length > 0) {
              fmt.warn(`å­¤å…’æ¨™ç±¤ (éŸ³æ•ˆä½¿ç”¨ä½†æœªåœ¨ tags.json å®šç¾©): ${orphanTags.length} å€‹`);
              fmt.list(orphanTags);
            } else {
              fmt.ok('ç„¡å­¤å…’æ¨™ç±¤');
            }

            // A.4 æœªä½¿ç”¨æ¨™ç±¤ï¼ˆtags.json å®šç¾©ä½†æ²’æœ‰éŸ³æ•ˆä½¿ç”¨ï¼‰
            const unusedTags = state.tagList.filter(t => !usedInSounds.has(t.key)).map(t => t.key);
            if (unusedTags.length > 0) {
              fmt.info(`æœªä½¿ç”¨æ¨™ç±¤ (å·²å®šç¾©ä½†ç„¡éŸ³æ•ˆä½¿ç”¨): ${unusedTags.length} å€‹`);
              fmt.list(unusedTags);
            }

            // A.5 é‡è¤‡ ID æª¢æ¸¬
            const idCounts = {};
            state.sounds.forEach(s => { idCounts[s.id] = (idCounts[s.id] || 0) + 1; });
            const duplicateIds = Object.entries(idCounts).filter(([, c]) => c > 1).map(([id, c]) => `${id} (${c}æ¬¡)`);
            if (duplicateIds.length > 0) {
              fmt.error(`é‡è¤‡ ID: ${duplicateIds.length} å€‹`);
              fmt.list(duplicateIds);
            } else {
              fmt.ok('ç„¡é‡è¤‡ ID');
            }

            // A.6 å…¶ä»–ç‹€æ…‹
            fmt.section('å…¶ä»–ç‹€æ…‹');
            console.log(`   ç›®å‰é é¢: ${state.page}`);
            console.log(`   æ’åºæ¨¡å¼: ${state.isSorting ? 'æ˜¯' : 'å¦'}`);
            console.log(`   å…¨åŸŸéŸ³é‡: ${Math.round(state.globalVolume * 100)}%`);
            console.log(`   æ”¶åˆ°çš„åˆ†äº«åˆ—è¡¨: ${state.receivedList.length} ç­†`);

            console.log('');
            return { soundCount: state.sounds.length, orphanTags, unusedTags, duplicateIds };
          };

          // ===== B. æ¸¬è©¦ç³»çµ± =====
          const test = {
            /**
             * æª¢æŸ¥æ‰€æœ‰éŸ³æ•ˆæª”æ¡ˆæ˜¯å¦å­˜åœ¨
             * @param {Object} options - é¸é …
             * @param {boolean} options.verbose - æ˜¯å¦é¡¯ç¤ºæ¯å€‹æª”æ¡ˆçš„çµæœ
             * @param {number} options.concurrency - ä¸¦ç™¼è«‹æ±‚æ•¸é‡
             */
            checkFiles: (options = {}) => {
              const { verbose = false, concurrency = 10 } = options;

              fmt.title('ğŸ” æª”æ¡ˆå­˜åœ¨æ€§æ¸¬è©¦');
              console.log(`   æ¸¬è©¦ ${state.sounds.length} å€‹éŸ³æ•ˆæª”æ¡ˆ...`);
              console.log(`   ä¸¦ç™¼æ•¸: ${concurrency}`);
              console.log('');

              const results = { ok: [], missing: [], error: [] };
              let completed = 0;

              const checkFile = async (snd) => {
                try {
                  const resp = await fetch(snd.src, { method: 'HEAD' });
                  if (resp.ok) {
                    results.ok.push(snd);
                    if (verbose) fmt.ok(`${snd.file}`);
                  } else {
                    results.missing.push({ snd, status: resp.status });
                    fmt.error(`${snd.file} (HTTP ${resp.status})`);
                  }
                } catch (e) {
                  results.error.push({ snd, error: e.message });
                  fmt.error(`${snd.file} (${e.message})`);
                }
                completed++;
                if (completed % 100 === 0 || completed === state.sounds.length) {
                  console.log(`   é€²åº¦: ${completed}/${state.sounds.length}`);
                }
              };

              // ä½¿ç”¨ä¸¦ç™¼æ§åˆ¶åŸ·è¡Œ
              (async () => {
                const queue = [...state.sounds];
                const workers = [];

                for (let i = 0; i < concurrency; i++) {
                  workers.push((async () => {
                    while (queue.length > 0) {
                      const snd = queue.shift();
                      if (snd) await checkFile(snd);
                    }
                  })());
                }

                await Promise.all(workers);

                // è¼¸å‡ºçµæœæ‘˜è¦
                console.log('');
                fmt.section('æ¸¬è©¦çµæœæ‘˜è¦');
                fmt.ok(`æ­£å¸¸: ${results.ok.length} ç­†`);
                if (results.missing.length > 0) {
                  fmt.error(`ç¼ºå¤±: ${results.missing.length} ç­†`);
                  results.missing.forEach(({ snd, status }) => {
                    console.log(`      â€¢ ${snd.file} (HTTP ${status})`);
                  });
                }
                if (results.error.length > 0) {
                  fmt.warn(`éŒ¯èª¤: ${results.error.length} ç­†`);
                  results.error.forEach(({ snd, error }) => {
                    console.log(`      â€¢ ${snd.file} (${error})`);
                  });
                }

                console.log('');
                console.log('ğŸ’¡ çµæœå·²å­˜å…¥: SoundboardDebug.lastTestResult');
                window.SoundboardDebug.lastTestResult = results;
              })();

              return 'æ¸¬è©¦åŸ·è¡Œä¸­ï¼Œè«‹ç­‰å¾…çµæœ...';
            },

            /** æª¢æŸ¥æ¨™ç±¤åƒç…§å®Œæ•´æ€§ */
            checkTags: () => {
              fmt.title('ğŸ·ï¸ æ¨™ç±¤å®Œæ•´æ€§æ¸¬è©¦');

              const definedKeys = new Set(state.tagList.map(t => t.key));
              const issues = [];

              state.sounds.forEach(snd => {
                snd.tags.forEach(tag => {
                  const key = utils.slug(tag);
                  if (!definedKeys.has(key)) {
                    issues.push({ sound: snd.title, soundId: snd.id, tag, tagKey: key });
                  }
                });
              });

              if (issues.length === 0) {
                fmt.ok('æ‰€æœ‰æ¨™ç±¤åƒç…§éƒ½æœ‰æ•ˆ');
              } else {
                fmt.error(`ç™¼ç¾ ${issues.length} å€‹ç„¡æ•ˆæ¨™ç±¤åƒç…§:`);
                const grouped = {};
                issues.forEach(i => {
                  if (!grouped[i.tagKey]) grouped[i.tagKey] = [];
                  grouped[i.tagKey].push(i.sound);
                });
                Object.entries(grouped).forEach(([tagKey, sounds]) => {
                  console.log(`   â€¢ "${tagKey}" è¢« ${sounds.length} å€‹éŸ³æ•ˆä½¿ç”¨`);
                  if (sounds.length <= 5) {
                    sounds.forEach(s => console.log(`      - ${s}`));
                  } else {
                    sounds.slice(0, 3).forEach(s => console.log(`      - ${s}`));
                    console.log(`      ... é‚„æœ‰ ${sounds.length - 3} å€‹`);
                  }
                });
              }

              console.log('');
              return { valid: issues.length === 0, issues };
            },

            /** æª¢æŸ¥ ID å”¯ä¸€æ€§ */
            checkIds: () => {
              fmt.title('ğŸ”‘ ID å”¯ä¸€æ€§æ¸¬è©¦');

              const idMap = {};
              state.sounds.forEach(snd => {
                if (!idMap[snd.id]) idMap[snd.id] = [];
                idMap[snd.id].push(snd);
              });

              const duplicates = Object.entries(idMap).filter(([, arr]) => arr.length > 1);

              if (duplicates.length === 0) {
                fmt.ok(`æ‰€æœ‰ ${state.sounds.length} å€‹éŸ³æ•ˆ ID éƒ½æ˜¯å”¯ä¸€çš„`);
              } else {
                fmt.error(`ç™¼ç¾ ${duplicates.length} çµ„é‡è¤‡ ID:`);
                duplicates.forEach(([id, sounds]) => {
                  console.log(`   â€¢ ID "${id}" å‡ºç¾ ${sounds.length} æ¬¡:`);
                  sounds.forEach(s => console.log(`      - ${s.title} (${s.file})`));
                });
              }

              console.log('');
              return { valid: duplicates.length === 0, duplicates };
            },

            /** åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦ */
            all: () => {
              fmt.title('ğŸ§ª åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦');
              console.log('');

              test.checkIds();
              test.checkTags();

              console.log('');
              fmt.info('æª”æ¡ˆå­˜åœ¨æ€§æ¸¬è©¦éœ€è¦ç¶²è·¯è«‹æ±‚ï¼Œè«‹åŸ·è¡Œ:');
              console.log('   SoundboardDebug.test.checkFiles()');
              console.log('');
            }
          };

          // ===== C. ç‹€æ…‹æª¢è¦–å™¨ =====
          const inspect = {
            /** æŸ¥çœ‹å®Œæ•´ state ç‰©ä»¶ */
            state: () => {
              fmt.title('ğŸ“¦ æ‡‰ç”¨ç¨‹å¼ç‹€æ…‹ (state)');
              console.log(state);
              return state;
            },

            /** æŸ¥çœ‹ç‰¹å®šéŸ³æ•ˆè©³æƒ… */
            sound: (idOrIndex) => {
              let snd;
              if (typeof idOrIndex === 'number') {
                snd = state.sounds[idOrIndex];
              } else {
                snd = state.soundMap.get(idOrIndex);
              }

              if (!snd) {
                fmt.error(`æ‰¾ä¸åˆ°éŸ³æ•ˆ: ${idOrIndex}`);
                return null;
              }

              fmt.title(`ğŸ”Š éŸ³æ•ˆè©³æƒ…: ${snd.title}`);
              console.log('   ID:', snd.id);
              console.log('   æª”æ¡ˆ:', snd.file);
              console.log('   ä¾†æº:', snd.src);
              console.log('   æ¨™ç±¤:', snd.tags.join(', '));
              console.log('   æ˜¯å¦æœ€æ„›:', state.favSet.has(snd.id) ? 'æ˜¯' : 'å¦');
              console.log('');
              console.log('å®Œæ•´ç‰©ä»¶:');
              console.log(snd);
              return snd;
            },

            /** æŸ¥çœ‹ç‰¹å®šæ¨™ç±¤è©³æƒ… */
            tag: (key) => {
              const tagKey = utils.slug(key);
              const tagDef = state.tags[tagKey];

              if (!tagDef) {
                fmt.error(`æ‰¾ä¸åˆ°æ¨™ç±¤å®šç¾©: ${key}`);
                // æª¢æŸ¥æ˜¯å¦æœ‰éŸ³æ•ˆä½¿ç”¨æ­¤æ¨™ç±¤
                const usingSounds = state.sounds.filter(s => s.tags.some(t => utils.slug(t) === tagKey));
                if (usingSounds.length > 0) {
                  fmt.warn(`ä½†æœ‰ ${usingSounds.length} å€‹éŸ³æ•ˆä½¿ç”¨æ­¤æ¨™ç±¤`);
                }
                return null;
              }

              fmt.title(`ğŸ·ï¸ æ¨™ç±¤è©³æƒ…: ${tagDef.name}`);
              console.log('   Key:', tagDef.key);
              console.log('   åç¨±:', tagDef.name);
              console.log('   é¡è‰²:', tagDef.color);
              console.log('   è§’è‰²:', tagDef.role);
              if (tagDef.avatar) console.log('   é ­åƒ:', tagDef.avatar);

              const usingSounds = state.sounds.filter(s => s.tags.some(t => utils.slug(t) === tagKey));
              console.log(`   ä½¿ç”¨æ­¤æ¨™ç±¤çš„éŸ³æ•ˆ: ${usingSounds.length} å€‹`);

              console.log('');
              return { definition: tagDef, soundCount: usingSounds.length, sounds: usingSounds };
            },

            /** æŸ¥çœ‹æœ€æ„›åˆ—è¡¨è©³æƒ… */
            favorites: () => {
              fmt.title('â¤ï¸ æœ€æ„›åˆ—è¡¨');
              console.log(`   ç¸½æ•¸: ${state.favorites.length} ç­†`);
              console.log('');

              if (state.favorites.length === 0) {
                fmt.info('ç›®å‰æ²’æœ‰æœ€æ„›');
                return [];
              }

              const details = state.favorites.map((id, i) => {
                const snd = state.soundMap.get(id);
                if (snd) {
                  console.log(`   ${i + 1}. ${snd.title} (${id})`);
                  return { id, title: snd.title, found: true };
                } else {
                  fmt.warn(`   ${i + 1}. [æ‰¾ä¸åˆ°] (${id})`);
                  return { id, title: null, found: false };
                }
              });

              const missing = details.filter(d => !d.found);
              if (missing.length > 0) {
                console.log('');
                fmt.warn(`æœ‰ ${missing.length} å€‹æœ€æ„› ID æ‰¾ä¸åˆ°å°æ‡‰éŸ³æ•ˆ`);
              }

              console.log('');
              return details;
            },

            /** åˆ—å‡ºæ‰€æœ‰éŸ³æ•ˆï¼ˆæ”¯æ´åˆ†é ï¼‰ */
            sounds: (page = 1, pageSize = 20) => {
              const start = (page - 1) * pageSize;
              const end = start + pageSize;
              const totalPages = Math.ceil(state.sounds.length / pageSize);

              fmt.title(`ğŸ“‹ éŸ³æ•ˆåˆ—è¡¨ (ç¬¬ ${page}/${totalPages} é )`);
              console.log(`   é¡¯ç¤º ${start + 1}-${Math.min(end, state.sounds.length)} / ${state.sounds.length}`);
              console.log('');

              state.sounds.slice(start, end).forEach((snd, i) => {
                console.log(`   ${start + i + 1}. ${snd.title} [${snd.id}]`);
              });

              console.log('');
              if (page < totalPages) {
                console.log(`ğŸ’¡ æŸ¥çœ‹ä¸‹ä¸€é : SoundboardDebug.inspect.sounds(${page + 1})`);
              }

              return state.sounds.slice(start, end);
            },

            /** åˆ—å‡ºæ‰€æœ‰æ¨™ç±¤ */
            tags: () => {
              fmt.title('ğŸ·ï¸ æ¨™ç±¤åˆ—è¡¨');
              console.log(`   ç¸½æ•¸: ${state.tagList.length} å€‹`);
              console.log('');

              const streamers = state.tagList.filter(t => t.role === 'streamer');
              const categories = state.tagList.filter(t => t.role === 'category');
              const others = state.tagList.filter(t => t.role !== 'streamer' && t.role !== 'category');

              if (streamers.length > 0) {
                fmt.section('å¯¦æ³ä¸»');
                streamers.forEach(t => console.log(`   â€¢ ${t.name} (${t.key}) ${t.color}`));
              }

              if (categories.length > 0) {
                fmt.section('åˆ†é¡');
                categories.forEach(t => console.log(`   â€¢ ${t.name} (${t.key}) ${t.color}`));
              }

              if (others.length > 0) {
                fmt.section('å…¶ä»–');
                others.forEach(t => console.log(`   â€¢ ${t.name} (${t.key}) ${t.color}`));
              }

              console.log('');
              return state.tagList;
            }
          };

          // ===== D. å¹«åŠ©ç³»çµ± =====
          const help = () => {
            console.log(`
%câ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          ğŸ›ï¸ SoundboardDebug æ§åˆ¶å°è¨ºæ–·å·¥å…· v${VERSION}          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•%c

%cã€ç‹€æ…‹å ±å‘Šã€‘%c
  SoundboardDebug.status()          é¡¯ç¤ºå®Œæ•´ç‹€æ…‹å ±å‘Šï¼ˆéŸ³æ•ˆæ•¸é‡ã€å­¤å…’æ¨™ç±¤ç­‰ï¼‰

%cã€æ¸¬è©¦åŠŸèƒ½ã€‘%c
  SoundboardDebug.test.checkFiles() æª¢æŸ¥æ‰€æœ‰éŸ³æ•ˆæª”æ¡ˆæ˜¯å¦å­˜åœ¨ï¼ˆéœ€ç­‰å¾…ï¼‰
  SoundboardDebug.test.checkFiles({ verbose: true })  é¡¯ç¤ºæ¯å€‹æª”æ¡ˆçµæœ
  SoundboardDebug.test.checkTags()  æª¢æŸ¥æ¨™ç±¤åƒç…§å®Œæ•´æ€§
  SoundboardDebug.test.checkIds()   æª¢æŸ¥ ID å”¯ä¸€æ€§
  SoundboardDebug.test.all()        åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦ï¼ˆä¸å«æª”æ¡ˆæª¢æŸ¥ï¼‰

%cã€ç‹€æ…‹æª¢è¦–ã€‘%c
  SoundboardDebug.inspect.state()       æŸ¥çœ‹å®Œæ•´ state ç‰©ä»¶
  SoundboardDebug.inspect.sound(id)     æŸ¥çœ‹ç‰¹å®šéŸ³æ•ˆï¼ˆå¯ç”¨ ID æˆ–ç´¢å¼•ï¼‰
  SoundboardDebug.inspect.sounds(page)  åˆ—å‡ºéŸ³æ•ˆï¼ˆåˆ†é ï¼Œæ¯é  20 ç­†ï¼‰
  SoundboardDebug.inspect.tag(key)      æŸ¥çœ‹ç‰¹å®šæ¨™ç±¤è©³æƒ…
  SoundboardDebug.inspect.tags()        åˆ—å‡ºæ‰€æœ‰æ¨™ç±¤
  SoundboardDebug.inspect.favorites()   æŸ¥çœ‹æœ€æ„›åˆ—è¡¨è©³æƒ…

%cã€å…¶ä»–ã€‘%c
  SoundboardDebug.help()            é¡¯ç¤ºæ­¤èªªæ˜
  SoundboardDebug.lastTestResult    ä¸Šæ¬¡æª”æ¡ˆæ¸¬è©¦çš„çµæœï¼ˆåŸ·è¡Œ checkFiles å¾Œï¼‰

`,
              'color: #6aa9ff; font-weight: bold;',
              '',
              'color: #ff9e6a; font-weight: bold;', 'color: inherit;',
              'color: #ff9e6a; font-weight: bold;', 'color: inherit;',
              'color: #ff9e6a; font-weight: bold;', 'color: inherit;',
              'color: #ff9e6a; font-weight: bold;', 'color: inherit;'
            );
          };

          // ===== åˆå§‹åŒ–æç¤º =====
          const init = () => {
            console.log(
              '%cğŸ›ï¸ SoundboardDebug å·²è¼‰å…¥ %câ€” è¼¸å…¥ %cSoundboardDebug.help()%c ç²å–ä½¿ç”¨æŒ‡å—',
              'color: #6aa9ff; font-weight: bold;',
              'color: #94a3b8;',
              'color: #4ade80; font-weight: bold;',
              'color: #94a3b8;'
            );
          };

          // å»¶é²åŸ·è¡Œåˆå§‹åŒ–æç¤ºï¼ˆç¢ºä¿åœ¨å…¶ä»–è¨Šæ¯ä¹‹å¾Œï¼‰
          setTimeout(init, 100);

          // ===== å…¬é–‹ API =====
          return {
            status,
            test,
            inspect,
            help,
            lastTestResult: null,
            _version: VERSION
          };
        })();

        // æ›è¼‰åˆ° window ä¾›æ§åˆ¶å°å­˜å–
        window.SoundboardDebug = SoundboardDebug;

      })();
    </script>
</body>

</html>