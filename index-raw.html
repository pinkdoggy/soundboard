<!doctype html>
<html lang="zh-Hant">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="assets/favicon.png" type="image/png">

  <title>é˜¿è¬èˆ‡å‹•ç‰©æœ‹å‹æŒ‰éˆ•</title>
  <style>
    :root {
      --bg: #0b0d10;
      --search: #0b0d1000;
      --fg: #e9eef5;
      --muted: #a8b3c7;
      --card: #141821;
      --card-2: #212832;
      --border: #202636;
      --accent: #6aa9ff;
      --accent2: #ff9e6a;
      --heart: #ff5a7a;
      --chip-fg: #0b0d10;
      --shadow: 0 6px 24px rgba(0, 0, 0, .25);

      /* æš—è‰²ä¸»é¡Œçš„èƒŒæ™¯æ··åˆæ¨¡å¼ */
      --bg-blend-mode: normal;
      --bg-opacity: 0.25;

      --control-h: 44px;
      --liquid-hover: rgba(96, 150, 255, .20);
    }

    :root.light {
      --bg: #f8fafc;
      --search: #f8fafc00;
      --fg: #0d1320;
      --muted: #4b5563;
      --card: #ffffff;
      --card-2: #f3f6fb;
      --border: #e5e7eb;
      --accent: #2563eb;
      --accent2: #eb7b25;
      --heart: #e11d48;
      --chip-fg: #ffffff;
      --shadow: 0 4px 18px rgba(2, 6, 23, .08);

      /* äº®è‰²ä¸»é¡Œçš„èƒŒæ™¯æ··åˆæ¨¡å¼å’Œé€æ˜åº¦ */
      --bg-blend-mode: normal;
      --bg-opacity: 0.35;
    }

    /* --- é€šç”¨æ¨£å¼ --- */
    * {
      box-sizing: border-box;
    }

    html,body { height: 100%; }

    body {
      margin: 0;
      background-color: var(--bg);
      color: var(--fg);
      font: medium ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Noto Sans, "Helvetica Neue", Arial;
      position: relative;
      /* ç‚º ::before æä¾›å®šä½ä¸Šä¸‹æ–‡ */
      z-index: 1;
      /* å°‡æ‰€æœ‰å…§å®¹æå‡åˆ°èƒŒæ™¯åœ–ä¹‹ä¸Š */
    }

    /* --- èƒŒæ™¯ --- */
    body::before {
      content: '';
      position: fixed;
      /* èƒŒæ™¯å›ºå®šåœ¨è¦–çª— */
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('assets/background-by-jia.avif');
      background-size: auto 90%;
      background-repeat: repeat;
      background-attachment: fixed;
      mix-blend-mode: var(--bg-blend-mode);
      opacity: var(--bg-opacity);
      z-index: -1;
      /* å°‡èƒŒæ™¯åœ–å±¤æ”¾åœ¨æœ€åº•éƒ¨ */
    }
    a { color: inherit }
    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px
    }
    header {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 14px;
    }

    /* æ¨™é¡Œå…è¨±ç¸®æ”¾ï¼Œä½†ä¸å£“ç¸®å³å´å°èˆªèˆ‡æŒ‰éˆ•ã€‚å°‡å³é‚Šå…ƒç´ æ¨åˆ°æœ€å³å´ */
    header h1 {
      white-space: nowrap;
      margin-right: auto;
      /* ä½¿ç”¨ auto margin è®“å¾Œæ–¹å°è¦½èˆ‡æŒ‰éˆ•é å³ */
    }

    /* å°è¦½åˆ—æ¨£å¼å·²æ•´åˆåˆ° .tabs å’Œ .tabï¼Œä¿ç•™èˆŠæ¨£å¼ä¾›æœªä¾†éœ€è¦ä½¿ç”¨ */
    h1 {
      font-size: 1.4rem;
      margin: 0 8px 0 0;
      letter-spacing: .5px
    }

    .theme-toggle {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--fg);
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
      box-shadow: var(--shadow)
    }

    /* æœå°‹åˆ— */
    .search-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0px;
      align-items: stretch;
      position: sticky;
      top: 0;
      background: var(--search);
      padding: 8px 0 12px;
      z-index: 5
    }

    .searchbar {
      flex: 1 1 260px;
      display: flex;
      align-items: center;
      gap: 6px;
      background: var(--glass-bg) !important;
      border: 1px solid var(--glass-border) !important;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 6px 8px;
      box-shadow: var(--shadow);
      position: relative;
      height: var(--control-h);
    }

    .searchbar input {
      flex: 1;
      background: transparent;
      border: 0;
      outline: 0;
      color: var(--fg);
      font-size: 16px;
      min-width: 160px;
      height: 100%;
      line-height: var(--control-h);
      padding: 0 6px;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 12px;
      color: var(--chip-fg);
      box-shadow: 0 2px 6px rgba(0, 0, 0, .18);
    }

    .chip button {
      appearance: none;
      border: 0;
      background: transparent;
      color: inherit;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      padding: 0 0 0 2px
    }

    .searchbar .chip {
      cursor: pointer;
    }

    /* Favorites + Grid */
    .section-title {
      margin: 18px 0 10px;
      font-weight: 700;
      letter-spacing: .3px
    }

    .grid {
      display: grid;
      gap: 4px;
      grid-template-columns: repeat(6, minmax(0, 1fr));
    }

    @media (max-width:1000px) {
      .grid {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }
    }

    @media (max-width:800px) {
      .grid {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    }

    @media (max-width:600px) {
      .grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (max-width:400px) {
      .grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .sound {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: saturate(1) blur(8px);
      -webkit-backdrop-filter: saturate(1) blur(8px);
      border-radius: 12px;
      padding: 8px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 5px 2px;
      user-select: none;
      cursor: pointer;
      transition: transform .06s ease;

    }

    .sound:active {
      transform: scale(.985)
    }

    .sound-top {
      display: flex;
      align-items: center;
      gap: 4px
    }

    .title {
      font-weight: 600;
      font-size: smaller;
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis
    }

    .heart {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      place-items: center;
      border: 1px solid var(--border);
      background: var(--card-2);
      cursor: pointer;
      flex: 0 0 auto;
    }

    .heart svg {
      width: 16px;
      height: 16px;
      display: block
    }

    .heart[aria-pressed="true"] svg path {
      fill: var(--heart)
    }

    .tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px
    }

    .tag {
      border-radius: 999px;
      padding: 3px 6px;
      font-size: small;
      color: var(--chip-fg);
      cursor: pointer;
      white-space: nowrap;
      box-shadow: 0 2px 6px rgba(0, 0, 0, .16);
    }

    .stage {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px 14px;
      justify-content: center;
      pointer-events: none;
      z-index: 40;
      padding: 0 12px;
    }

    .group {
      display: inline-flex;
      gap: 8px;
      align-items: flex-end
    }

    .avatar {
      width: 75px;
      height: 75px;
      border-radius: 999px;
      background: transparent;
      /* ä¿æŒé€æ˜èƒŒæ™¯ä»¥å‘ˆç¾é ­åƒ PNG çš„é€æ˜å€åŸŸ */
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, .8);
      box-shadow: 0 8px 24px rgba(0, 0, 0, .35);
      transform-origin: 50% 100%;
    }

    .avatar>img {
      width: 100%;
      height: 100%;
      object-fit: cover
    }

    /* Keyframes */
    @keyframes popIn {
      0% {
        transform: translateY(20px) scale(.7);
        opacity: 0
      }

      100% {
        transform: translateY(0) scale(1);
        opacity: 1
      }
    }

    @keyframes jitter {
      0%,
      100% {transform: translateY(0) rotate(0deg)}
      20% {transform: translateY(-2px) rotate(-1deg)}
      40% {transform: translateY(1px) rotate(1deg)}
      60% {transform: translateY(-1px) rotate(.6deg)}
      80% {transform: translateY(1px) rotate(-.6deg)}
    }

    /* ç°¡åŒ–çš„é›¢å ´å‹•ç•«ï¼šå½ˆèµ·å¾Œå‘ä¸‹æ‰ä¸¦æ·¡å‡º */
    @keyframes hopOut {
      0% {
        transform: translateY(0);
        opacity: 1
      }

      22% {
        transform: translateY(-12px);
        opacity: 1
      }

      100% {
        transform: translateY(60px);
        opacity: 0
      }
    }

    .pop-in {
      animation: popIn .28s cubic-bezier(.2, .9, .18, 1) both
    }

    .jit {
      animation: jitter .9s ease-in-out infinite
    }

    .hop-out {
      animation: hopOut .5s cubic-bezier(.2, .8, .2, 1) forwards
    }

    .hidden {
      display: none
    }

    .desc {
      color: var(--muted);
      font-size: 14px;
      margin: 0 0 6px
    }

    .empty {
      color: var(--muted);
      padding: 12px 0
    }

    /* Utility */
    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap
    }

    .btn {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--fg);
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer
    }

    /* å°è¦½åˆ†é  */
    /* å°è¦½åˆ†é ç½®æ–¼ header å³å´ï¼Œç”± h1 çš„ margin-right:auto æ¨é–‹ */
    .tabs {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      /* allow nav items to wrap on small screens */
    }

    .tab {
      display: inline-block;
      padding: 6px 16px;
      /* æ›´å¯¬çš„é–“è·ï¼Œèˆ‡å…¶ä»–è† å›Šå…ƒç´ ä¸€è‡´ */
      font-size: 14px;
      border: 1px solid var(--border);
      border-radius: 999px;
      /* pill é€ å‹ï¼Œèˆ‡æ¨™ç±¤ä¸€è‡´ */
      background: var(--card-2);
      color: var(--fg);
      cursor: pointer;
      transition: background .15s ease, color .15s ease;
    }

    .tab:hover {
      background: var(--card);
    }

    .tab.active {
      background: var(--accent);
      border-color: var(--accent);
      color: var(--chip-fg);
    }

    /* å°è¢å¹•æ™‚å°è¦½åˆ—èˆ‡ä¸»é¡Œåˆ‡æ›æŒ‰éˆ•æ›è¡Œä¸¦å¢åŠ ä¸Šé‚Šè· */
    @media (max-width: 600px) {
      header .tabs {
        margin-top: 8px;
      }

      header .theme-toggle {
        margin-top: 8px;
      }
    }

    /* å€å¡Šæ¨™é¡Œèˆ‡æ§åˆ¶æŒ‰éˆ• */
    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 14px 0 8px;
    }

    .section-header .actions {
      display: flex;
      gap: 3px;
    }

    .section-header h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: .2px;
    }

    .small-btn {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 8px;
    }

    /* æ¨™ç±¤ä¸€è¦½ */
    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 8px;
      margin: 8px 0;
    }

    .tag-list .tag {
      cursor: pointer;
    }

    /* Context Menu */
    .menu {
      position: fixed;
      z-index: 9999;
      min-width: 180px;
      background: var(--glass-bg) !important;
      border: 1px solid var(--glass-border) !important;
      backdrop-filter: saturate(1.8) blur(12px);
      -webkit-backdrop-filter: saturate(1.8) blur(12px);
      border-radius: 12px;
      overflow: hidden;
    }

    .menu.hidden {
      display: none
    }

    .menu-item {
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid var(--border)
    }

    .menu-item:last-child {
      border-bottom: 0
    }

    .menu-item:hover {
      background: var(--liquid-hover);
    }

    /* Toast */
    .toast {
      position: fixed;
      left: 50%;
      bottom: 80px;
      transform: translateX(-50%);
      background: var(--card);
      border: 1px solid var(--border);
      padding: 10px 14px;
      border-radius: 10px;
      box-shadow: var(--shadow);
      z-index: 70
    }

    .toast.hidden {
      display: none
    }

    /* æ··éŸ³é¢æ¿ */
    .mix-panel {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 16px;
      width: min(980px, calc(100% - 32px));
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: saturate(1.6) blur(18px);
      -webkit-backdrop-filter: saturate(1.6) blur(18px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px 14px 14px;
      z-index: 80;
    }

    .mix-panel.hidden {
      display: none
    }

    .mix-header {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .mix-scroll-host {
      position: relative;
      overflow-x: auto;
      overflow-y: hidden;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.22);
      border: 1px solid rgba(255, 255, 255, 0.12);
      scrollbar-width: none;
    }

    .mix-scroll-host::-webkit-scrollbar {
      display: none
    }

    .mix-scroll-content {
      position: relative;
      min-height: 75px;
    }

    .mix-track-lanes {
      position: relative;
    }

    .mix-track {
      position: relative;
      height: 25px;
      border-bottom: 1px dashed var(--glass-border);
      background-color: var(--glass-bg);
      overflow: hidden;
    }

    .mix-track:last-of-type {
      border-bottom: 0;
    }

    .mix-track::before {
      content: attr(data-label);
      position: absolute;
      left: 0;
      top: 50%;
      transform: translate(-110%, -50%);
      font-size: 12px;
      color: var(--muted);
    }

    .mix-clip {
      position: absolute;
      top: 1px;
      height: 23px;
      border-radius: 8px;
      padding: 4px 26px 4px 8px;
      font-size: 12px;
      font-weight: 600;
      color: var(--chip-fg);
      display: flex;
      align-items: center;
      cursor: grab;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.35);
    }

    .mix-clip:active {
      cursor: grabbing;
    }

    .mix-clip.dragging {
      opacity: 0.85;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.55);
      cursor: grabbing;
    }

    /* Touch / selection tweaks to ensure mobile can drag clips instead of opening native menus */
    .mix-scroll-host,
    .mix-track-lanes,
    .mix-clip {
      -webkit-touch-callout: none;
      /* iOS: disable callout on long press */
      -webkit-user-select: none;
      /* Safari */
      user-select: none;
      /* Prevent text selection while dragging */
    }

    /* For pointer-based dragging we disable default touch actions inside the timeline
     and implement panning/dragging via pointer events. This prevents long-press
     context menus on many mobile browsers. */
    .mix-scroll-host,
    .mix-track-lanes,
    .mix-clip {
      touch-action: none;
    }

    .mix-clip-title {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
    }

    .mix-clip-remove {
      position: absolute;
      right: 4px;
      top: 4px;
      border: 0;
      width: 15px;
      height: 15px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.6);
      color: var(--chip-fg);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .mix-clip-remove:hover {
      background: rgba(15, 23, 42, 0.8);
    }

    .mix-clip-placeholder {
      height: 23px;
      margin: 0;
      position: absolute;
      top: 1px;
      left: 0;
      right: 0;
      pointer-events: none;
    }

    .mix-playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--accent);
      z-index: 3;
      pointer-events: none;
    }

    .mix-bar-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 0 4px;
    }

    .mix-bar-row>.mix-bar {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 0;
    }

    .mix-bar input[type="range"] {
      flex: 1;
      min-width: 0;
    }

    .mix-controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
    }

    .mix-controls-left {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .mix-controls-center {
      display: flex;
      align-items: center;
      gap: 2px;
    }

    .mix-controls-right {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .mix-btn {
      border: 1px solid var(--glass-border);
      background: var(--card-2);
      color: var(--fg);
      border-radius: 8px;
      padding: 6px 6px;
      cursor: pointer;
      min-width: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
      font-size: 13px;
    }

    .mix-btn:hover {
      background: rgba(15, 23, 42, 0.55);
    }

    .mix-btn[disabled] {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .mix-muted {
      color: var(--muted);
      font-size: 12px;
    }

    .mix-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.45);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 120;
    }

    .mix-modal-backdrop.hidden {
      display: none;
    }

    .mix-modal {
      background: var(--bg);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 12px 12px;
      max-width: 320px;
      box-shadow: var(--shadow);
    }

    .mix-modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 16px;
    }

    /* æ’­æ”¾/åˆ†äº«èšç„¦é«˜äº® */
    /* å¤–å…‰æšˆé«˜å…‰æ•ˆæœï¼šæŒçºŒç™¼å…‰ */
    .glow-persistent {
      box-shadow: 0 0 0 4px rgba(106, 169, 255, 0.5), 0 0 12px rgba(106, 169, 255, 0.75);
      /* transition added to avoid abrupt appearance */
      transition: box-shadow 0.3s ease;
    }


    :root {
      --glass-bg: rgba(20, 24, 33, .8);
      --glass-border: rgba(255, 255, 255, .12);
    }

    :root.light {
      --glass-bg: rgba(255, 255, 255, .6);
      --glass-border: rgba(15, 23, 42, .12);
    }

    .glass {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(3px);
      -webkit-backdrop-filter: blur(3px);
      background-clip: padding-box;
      box-shadow: var(--shadow);
    }

    .searchbar,
    .sound,
    .menu {
      background: var(--glass-bg) !important;
      border-color: var(--glass-border) !important;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
    }

    /* Navbar enhancements */
    header {
      position: relative;
    }

    .nav-toggle {
      display: none;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--fg);
      border-radius: 10px;
      padding: 8px;
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    @media (max-width: 760px) {
      .nav-toggle {
        display: inline-flex;
      }

      header .tabs {
        display: none;
        position: absolute;
        right: 0;
        top: 100%;
        padding: 8px;
        border-radius: 12px;
        gap: 6px;
        flex-direction: column;
        align-items: stretch;
        min-width: 180px;
        z-index: 120;
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        backdrop-filter: saturate(1.8) blur(12px);
        -webkit-backdrop-filter: saturate(1.8) blur(12px);
        box-shadow: var(--shadow);
      }

      body.nav-open header .tabs {
        display: flex;
      }
    }

    /* Background page tweaks */
    body.bg-full {
      --bg-opacity: 1 !important;
    }

    .bg-page {
      min-height: 50vh;
    }

    .bg-credit {
      position: fixed;
      right: 16px;
      bottom: 16px;
      font-size: large;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 800;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: saturate(1.8) blur(10px);
      -webkit-backdrop-filter: saturate(1.8) blur(10px);
      box-shadow: var(--shadow);
      z-index: 60;
    }

    .bg-credit a {
      text-decoration: underline;
    }



    #clearBtn.btn {
      height: var(--control-h);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 14px;
    }

    .search-row .searchbar {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
      border-right: 0 !important;
    }

    .search-row #clearBtn {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
      border-left: 1px solid var(--glass-border);
      background: var(--glass-bg);
      backdrop-filter: saturate(1.5) blur(8px);
      -webkit-backdrop-filter: saturate(1.5) blur(8px);
    }

    #page-about .about-content {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: saturate(1.8) blur(12px);
      -webkit-backdrop-filter: saturate(1.8) blur(12px);
      border-radius: 14px;
      padding: 14px 16px;
      box-shadow: var(--shadow);
    }


    /* --- Layout fixes (per request) --- */
    /* Keep h1 and nav-toggle on the same row; let the h1 text wrap internally */
    header {
      flex-wrap: nowrap;
    }

    header h1 {
      white-space: normal;
      min-width: 0;
      overflow-wrap: anywhere;
    }

    /* Keep searchbar and clearBtn on the same row; let the searchbar shrink first */
    .search-row {
      flex-wrap: nowrap;
    }

    .search-row .searchbar {
      flex: 1 1 auto;
      min-width: 0;
    }

    .search-row .searchbar input {
      min-width: 0;
    }

    .search-row #clearBtn {
      flex: 0 0 auto;
      white-space: nowrap;
    }


    /* SortableJS drag styles & sorting mode cursor */
    .drag-ghost {
      opacity: .6;
      transform: scale(.98);
    }

    .drag-chosen {
      outline: 2px dashed var(--accent);
    }

    .dragging {
      cursor: grabbing;
    }

    body.sorting #favGrid .card {
      cursor: grab;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <h1>é˜¿è¬èˆ‡å‹•ç‰©æœ‹å‹æŒ‰éˆ•â‚‚â‚€â‚€â‚€</h1>
      <button id="navToggle" class="nav-toggle" aria-label="æ‰“é–‹é¸å–®" aria-expanded="false" aria-controls="primaryNav"
        title="é¸å–®">
        <svg width="22" height="22" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M3 6h18M3 12h18M3 18h18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
        </svg>
      </button>

      <!-- å°è¦½åˆ†é ï¼šæ”¾ç½®æ–¼æ¨™é¡Œèˆ‡ä¸»é¡Œåˆ‡æ›æŒ‰éˆ•ä¹‹é–“ï¼Œé å³æ’ç‰ˆ -->
      <nav id="primaryNav" class="tabs" aria-label="ä¸»é¸å–®">
        <button class="tab active" data-page="home">ä¸»é </button>
        <button class="tab" data-page="game">å°éŠæˆ²</button>
        <!-- <button class="tab" data-page="bg" id="tab-bg">èƒŒæ™¯</button> -->
  <button class="tab" data-page="about">é—œæ–¼</button>
  <button class="tab" data-page="awards">ç¥¨é¸çµæœ</button>
  <button id="settingsBtn" class="tab" aria-label="è¨­å®š">è¨­å®š</button>
      </nav>

    </header>

    <!-- é¦–é å…§å®¹ï¼šéŸ³æ•ˆåˆ—è¡¨ -->
    <div id="page-home">
      <!-- æœå°‹åˆ—ï¼ˆç¨ç«‹æˆ rowï¼‰ -->
      <div class="search-row">
        <div class="searchbar" role="search">
          <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
            <path fill="currentColor"
              d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16a6.471 6.471 0 0 0 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14" />
          </svg>
          <input id="q" placeholder="æœå°‹æ¨™é¡Œæˆ– #æ¨™ç±¤ï¼ˆå¯å¤šå€‹ï¼Œç”¨ç©ºç™½åˆ†éš”ï¼‰" autocomplete="off" />
          <div id="activeChips" class="chips"></div>
        </div>
        <button id="clearBtn" class="btn" aria-label="æ¸…é™¤æœå°‹">æ¸…é™¤</button>
      </div>
      <!-- æ¨™ç±¤ä¸€è¦½ -->
      <div id="tagList" class="tag-list"></div>
      <!-- æœ€æ„›å€ -->
      <div class="section-header">
        <h3>æœ€æ„›éŸ³æ•ˆ</h3>
        <div class="actions">
          <button id="sortFavBtn" class="btn small-btn">æ‰‹å‹•æ’åˆ—</button>
          <button id="doneSortBtn" class="btn small-btn glow-persistent hidden">å„²å­˜æ’åˆ—</button>
          <button id="shareFavBtn" class="btn small-btn">åˆ†äº«</button>
        </div>
      </div>
      <div id="favGrid" class="grid"></div>
      <div id="favEmpty" class="empty hidden">é‚„æ²’æœ‰æœ€æ„›ã€‚é»éŸ³æ•ˆå³ä¸Šçš„ â¤ï¸ åŠ å…¥æœ€æ„›ã€‚</div>
      <!-- æ”¶åˆ°çš„åˆ—è¡¨ï¼šåƒ…ç•¶ URL åŒ…å« list åƒæ•¸æ™‚é¡¯ç¤º -->
      <div id="receivedSection" class="hidden">
        <div id="receivedHeader" class="section-header">
          <h3>æ”¶åˆ°çš„åˆ—è¡¨</h3>
        </div>
        <div id="receivedGrid" class="grid"></div>
      </div>
      <!-- å…¨éƒ¨éŸ³æ•ˆ -->
      <div class="section-header">
        <h3>å…¨éƒ¨éŸ³æ•ˆ</h3>
        <div class="actions">
          <button id="openMixBtn" class="btn small-btn">éŸ³è»Œ</button>
          <button id="shuffleBtn" class="btn small-btn">æ´—ç‰Œ</button>
          <button id="resetOrderBtn" class="btn small-btn">é è¨­é †åº</button>
        </div>
      </div>
      <p class="desc">æç¤ºï¼šé»éŸ³æ•ˆå³å¯æ’­æ”¾ï¼›å³éµï¼ˆæˆ–è¡Œå‹•è£ç½®é•·æŒ‰ï¼‰å¯åˆ†äº«/ä¸‹è¼‰ã€‚</p>
      <div id="grid" class="grid"></div>
      <div id="empty" class="empty hidden">æ²’æœ‰ç¬¦åˆæœå°‹çš„éŸ³æ•ˆã€‚</div>
    </div>
    <!-- å°éŠæˆ²åˆ†é  -->
    <div id="page-game" class="hidden">
      <div id="concentration-game">
        <div class="cg-header">
          <div class="cg-stats">
            <span id="cg-timer">00:00</span>
            <span id="cg-accuracy">æº–ç¢ºç‡ï¼š--%</span>
          </div>
          <div class="cg-controls">
            <button id="cg-restart" class="btn small-btn">é‡é–‹ä¸€å±€</button>
          </div>
        </div>
        <div id="cg-board" class="cg-board"></div>
        <div id="cg-result" class="cg-result hidden"></div>
        <!-- è¦å‰‡èªªæ˜å¡ï¼šèˆ‡å…¶ä»–éŠæˆ²å€å¡ŠåŒå¯¬ä¸¦ç½®æ–¼ä¸‹æ–¹ -->
        <div id="cg-rules" class="cg-rules" aria-labelledby="cg-rules-title">
          <h4 id="cg-rules-title">è¨˜æ†¶å°éŠæˆ²è¦å‰‡</h4>
          <ul>
            <li>ç¬¬ä¸€æ¬¡ç¿»é–‹çš„ç‰Œä¸å°è¨ˆåˆ†é€ æˆå½±éŸ¿ï¼Œå±¬æ–¼è¨˜æ†¶æç¤ºã€‚</li>
            <li>æ¯ç¿»é–‹å…©å¼µå¡ï¼Œè‹¥ç‚ºç›¸åŒä¸»æ’­çš„ç›¸åŒéŸ³æ•ˆå³ç‚ºé…å°ï¼Œå…±æœ‰ 8 å°é…å°ã€‚</li>
            <li>ï¼ˆä¸æœƒå‡ºç¾å¸¶æœ‰ã€Œé«’è©±ã€æˆ–ã€ŒSUSã€æ¨™ç±¤çš„èªéŸ³ï¼Œä½†æ˜¯æœƒæœ‰å°–å«ï¼Œè«‹å°å¿ƒè€³è†œã€‚ï¼‰</li>
          </ul>
        </div>
      </div>
      <style>
        .cg-board {
          display: grid;
          grid-template-columns: repeat(4, 70px);
          grid-template-rows: repeat(4, 70px);
          gap: 8px;
          justify-content: center;
          margin: 12px auto;
          /* èˆ‡ .cg-header åŒå¯¬ä¸”ç½®ä¸­ï¼Œå‘ˆç¾åŠé€æ˜ç»ç’ƒæ‰˜ç›¤ */
          width: min(720px, 96%);
          padding: 12px;
          border-radius: 12px;
          background: var(--glass-bg);
          border: 1px solid var(--glass-border);
          backdrop-filter: saturate(1.8) blur(12px);
          -webkit-backdrop-filter: saturate(1.8) blur(12px);
          box-shadow: var(--shadow);
          justify-items: center;
        }

        .cg-card {
          width: 70px;
          height: 70px;
          background: #888;
          border-radius: 10px;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          position: relative;
          perspective: 600px;
          /* subtle click feedback */
          will-change: transform;
          transition: transform 140ms ease, box-shadow 140ms ease;
          user-select: none;
        }

        .cg-card.matched {
          opacity: 0.5;
          pointer-events: none;
        }

        .cg-card-inner {
          width: 100%;
          height: 100%;
          transition: transform 0.4s cubic-bezier(.4, 2, .6, 1);
          transform-style: preserve-3d;
          position: relative;
        }

        .cg-card.flipped .cg-card-inner {
          transform: rotateY(180deg);
        }

        .cg-card-front,
        .cg-card-back {
          position: absolute;
          width: 100%;
          height: 100%;
          backface-visibility: hidden;
          border-radius: 10px;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .cg-card-front {
          background: #888;
        }

        /* click feedback: a short pop + shadow while clicked */
        .cg-card:active,
        .cg-card.clicked {
          transform: scale(1.06);
          box-shadow: 0 10px 28px rgba(0, 0, 0, 0.28);
        }

        .cg-card-back {
          background: #fff;
          transform: rotateY(180deg);
          overflow: hidden;
        }

        .cg-card-back img {
          width: 80%;
          height: 80%;
          object-fit: contain;
          border-radius: 8px;
        }

        .cg-lock {
          position: absolute;
          right: 6px;
          top: 6px;
          background: rgba(0, 0, 0, 0.4);
          color: white;
          width: 20px;
          height: 20px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          font-weight: 700;
          font-size: 14px;
        }

        .cg-header {
          /* ç»ç’ƒæ‰˜ç›¤æ¨£å¼ï¼šåŠé€æ˜ã€åœ“è§’ã€é™°å½±ï¼Œä¸¦å›ºå®šæ–¼è¦–çª—é ‚ç«¯ï¼ˆåœ¨åˆ†é å…§ï¼‰ */
          display: flex;
          gap: 6px;
          align-items: center;
          justify-content: space-between;
          margin: 4px auto;
          padding: 8px 12px;
          width: min(720px, 96%);
          border-radius: 12px;
          background: var(--glass-bg);
          border: 1px solid var(--glass-border);
          backdrop-filter: saturate(1.8) blur(12px);
          -webkit-backdrop-filter: saturate(1.8) blur(12px);
          box-shadow: var(--shadow);
          position: sticky;
          top: 12px;
          z-index: 60;
          /* allow wrap on very small screens */
          flex-wrap: wrap;
        }

        /* å·¦å´æ•¸å€¼ç¾¤ï¼ˆè¨ˆæ™‚å™¨ + æº–ç¢ºç‡ï¼‰ */
        #cg-timer {
          font-size: 1.0rem;
          font-weight: 700;
          color: var(--fg);
          letter-spacing: 0.6px;
          min-width: 25px;
          text-align: left;
        }

        /* ç•¶éŠæˆ²é€²è¡Œä¸­ï¼ˆè¨ˆæ™‚å™¨é‹è¡Œï¼‰æ™‚é¡¯ç¤ºç¶ è‰² */
        #cg-timer.cg-running {
          color: #34d399;
        }

        #cg-accuracy {
          color: var(--muted);
          font-weight: 600;
          margin-left: 8px;
        }

        .cg-stats {
          display: flex;
          align-items: center;
          gap: 8px;
          flex: 1 1 auto;
          min-width: 0
        }

        .cg-controls {
          display: flex;
          align-items: center;
          gap: 8px;
          flex: 0 0 auto
        }

        /* å³å´æ§åˆ¶æŒ‰éˆ•æ’åˆ— */
        .cg-header button {
          margin-left: 8px;
          flex: 0 0 auto;
        }

        @media (max-width:420px) {
          .cg-header {
            gap: 8px;
            padding: 8px;
          }

          #cg-timer {
            font-size: 1rem;
          }

          .cg-board {
            grid-template-columns: repeat(4, 56px);
            grid-template-rows: repeat(4, 56px);
            gap: 4px;
            padding: 10px
          }

          .cg-card {
            width: 56px;
            height: 56px
          }
        }

        .cg-result {
          text-align: center;
          font-size: 1.05rem;
          margin-top: 18px;
          /* ä½¿ç”¨èˆ‡é—œæ–¼é é¢ç›¸åŒçš„æ–‡å­—å¡æ¨£å¼ */
          background: var(--glass-bg);
          border: 1px solid var(--glass-border);
          backdrop-filter: saturate(1.8) blur(12px);
          -webkit-backdrop-filter: saturate(1.8) blur(12px);
          border-radius: 14px;
          padding: 14px 16px;
          box-shadow: var(--shadow);
          max-width: 480px;
          margin: 18px auto 0;
        }

        .cg-result h3 {
          margin: 0 0 6px;
          font-size: 1.15rem
        }

        .cg-result .stats {
          display: flex;
          gap: 12px;
          justify-content: center;
          flex-wrap: wrap;
          color: var(--muted);
          font-weight: 600
        }

        .cg-result .big-num {
          font-size: 1.25rem;
          font-weight: 700;
          color: var(--fg)
        }

        /* è¦å‰‡èªªæ˜å¡ï¼šèˆ‡ .cg-board / .cg-header åŒå¯¬ä¸”ç½®ä¸­ï¼Œå¤–è§€ä¸€è‡´ */
        .cg-rules {
          width: min(720px, 96%);
          margin: 14px auto 28px;
          background: var(--glass-bg);
          border: 1px solid var(--glass-border);
          backdrop-filter: saturate(1.8) blur(12px);
          -webkit-backdrop-filter: saturate(1.8) blur(12px);
          border-radius: 12px;
          padding: 12px 16px;
          box-shadow: var(--shadow);
          color: var(--fg);
        }

        .cg-rules h4 {
          margin: 0 0 8px;
          font-size: 1.05rem
        }

        .cg-rules ul {
          margin: 0;
          padding-left: 18px;
          color: var(--muted)
        }
      </style>
    </div>

    <!-- èƒŒæ™¯åˆ†é  
    <div id="page-bg" class="bg-page hidden" aria-labelledby="tab-bg" role="region">
      <div class="bg-credit"><a href="https://x.com/jiauwu_0730" target="_blank" rel="noopener">èƒŒæ™¯æ’ç•«ç”± Jia ç¹ªè£½</a></div>
    </div>
    -->

  <!-- é—œæ–¼åˆ†é  -->
  <div id="page-about" class="hidden">
      <div class="about-content">
        <p>æœ¬ç«™ç”±ç²‰è‚è£½ä½œï¼Œä¸¦éç”±å­ä¸–é†«å¸«é˜¿è¬å®˜æ–¹ç¶“ç‡Ÿã€‚éŸ³æ•ˆå…§å®¹çš†æ˜¯ç²‰è‚å»è„ˆçµ¡å¼ã€æ–·ç« å–ç¾©çš„å‰ªè¼¯ï¼Œåƒ…ä¾›å¨›æ¨‚ã€‚æœ€å¾Œæ›´æ–°æ™‚é–“ï¼š2025/10/27ã€‚</p>

        <p>é˜¿è¬æœ¬å®¶â†’ <a href="https://x.com/drlifesucks" target="_blank">å­ä¸–é†«å¸«é˜¿è¬X</a>ã€<a
            href="https://www.youtube.com/@Dr.lifesucks" target="_blank">å­ä¸–é†«å¸«é˜¿è¬Youtube</a> </p>
        <p><a href="https://discord.gg/e6ch4VbRB4" target="_blank">éŸ³æ•ˆæ¿å•é¡Œå›å ±èˆ‡å»ºè­°å€</a></p>
        <img src="assets/art-by-sigh.png" alt=""
          style="margin: 0 auto; max-width:100%; max-height: 250px; display: block; object-fit: cover;" />
        <p style="text-align: right;">æ’ç•«ï¼š<a href="https://x.com/sigh121212" target="_blank">Minie(Sigh)</a></p>
        <h2>å¤§å¾·èŠ³åéŒ„</h2>
        <p>æ„Ÿè¬53ã€Kieåœ¨DCå¼„äº†ä¸€å †éŸ³æ•ˆï¼Œè®“å—æƒ³åˆ°å¯ä»¥åšé€™å€‹ç¶²ç«™ï¼Œä¸¦åœ¨æå‡ºé€™å€‹æƒ³æ³•çš„ä¸€é–‹å§‹å°±å¼„äº†ä¸€å †éŸ³æ•ˆéä¾†ã€‚é‚„æœ‰åŒæ¨£æ„Ÿè¬åœ¨åŸå‹éšæ®µå°±å¹«å¿™æ”¶é›†éŸ³æ•ˆçš„ç±³ç³•è·Ÿè–°è–°è‰ã€‚
          <br />æ„Ÿè¬Jiaç¹ªè£½è¶…å¯æ„›çš„èƒŒæ™¯åœ–è·Ÿæ”¶é›†äº†å¾ˆå¤šéŸ³æ•ˆã€‚
          <br />
          <br />æ„Ÿè¬ç²‰è‚å€‘æ”¶é›†å¾ˆå¤šéŸ³æ•ˆï¼Œè±å¯Œäº†é€™å€‹ç¶²ç«™ï¼ˆWordç­†åŠƒé †ï¼‰ï¼š
          <br />AmBinBongã€CZã€HUIã€Lococco de
          suzuranã€Nokimi07ã€Sighã€TENNã€Yichenæ²‰æ²‰ã€ğŸŒ™ğŸ°æœˆæ¡‚è‘‰é¦™åŒ…â™ğŸµã€å¸ƒä¸(25:00)ã€å¹¸ç¦æŸ´æŸ´ã€é’æœ«æã€å‡Œä¼ŠLingYiï¼ˆ01ï¼‰ã€å¤ç™½è¡«ã€æ¾â–½ç±³ç²‰ è‚‰å¹²ã€è²“è²“é›¨ã€‚
          ä»¥åŠå…¶ä»–å›å ±å•é¡Œã€æå‡ºå»ºè­°çš„ç²‰è‚å€‘ï¼Œä½ å€‘è®“é€™å€‹ç¶²ç«™çš„åŠŸèƒ½æ›´å®Œå–„ã€‚
        </p>
      </div>
      <div class="bg-credit"><a href="https://x.com/jiauwu_0730" target="_blank" rel="noopener">èƒŒæ™¯æ’ç•«ç”± Jia ç¹ªè£½</a></div>

    </div>

    <!-- ç¥¨é¸çµæœåˆ†é  -->
    <div id="page-awards" class="hidden">
    
      <style>
        #page-awards .awards-grid {
          display: grid;
          gap: 4px;
          grid-template-columns: repeat(4, minmax(120px, 240px));
          align-items: center;
          justify-items: center;
          justify-content: center; /* center the grid tracks when total width is less than container */
        }
        @media (max-width: 700px) {
          #page-awards .awards-grid {
            grid-template-columns: repeat(2, minmax(120px, 240px));
            justify-content: center;
          }
        }
        #page-awards .awards-grid img { width: 100%; height: auto; display: block; max-width: 100%; object-fit: cover; }
        /* ensure sound card titles inside awards page keep left alignment (override parent text-align:center) */
        #page-awards .grid .title { text-align: left; }
      </style>
      <div style="max-width:1100px;margin:0 auto;padding:18px;">
        <h2 style="text-align:center">ç¬¬ä¸€å±†éŸ³æ•ˆæ¿çˆ­éœ¸æˆ°</h2>
        <div style="text-align:center;margin:12px 0">
          <div class="awards-grid">
            <img src="assets/award1-1.jpg" alt="ç¬¬ä¸€å±†è²“ä¸‹å»" />
            <img src="assets/award1-2.jpg" alt="ç¬¬ä¸€å±†Matsuko" />
            <img src="assets/award1-3.jpg" alt="ç¬¬ä¸€å±†è±¹å­é ­" />
            <img src="assets/award1-4.jpg" alt="ç¬¬ä¸€å±†ç“¦å“ˆ" />
          </div>
        <h3>ç²çå€ï¼ˆå‰ååï¼‰</h3>
        <div id="awards-top10" class="grid"></div>
        <h3 style="margin-top:18px">å…¥åœçï¼ˆå¾Œ20åï¼‰</h3>
        <div id="awards-next20" class="grid"></div>
      </div>
    </div>
  </div>

    <!-- è¨­å®š Modalï¼ˆç«™å…§æ‰€æœ‰è¨­å®šï¼šéŸ³é‡ / ä¸»é¡Œé–‹é—œ ç­‰ï¼‰ -->
    <div id="settingsModal" class="mix-modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <div class="mix-modal">
        <h3 id="settingsTitle" style="margin-top: 0px;margin-bottom: 12px;">è¨­å®š</h3>
        <div style="display:flex;flex-direction:column;gap:8px;">
          <button id="themeBtn" class="mix-btn" type="button">é›»ç‡ˆé–‹é—œ</button>
          <label for="settingsVolume">æ’­æ”¾éŸ³é‡ï¼š <span id="settingsVolumeValue">100%</span></label>
          <input id="settingsVolume" type="range" min="0" max="100" step="1" value="100" />
          <div style="display:flex;justify-content:flex-end;margin-top:6px;gap:8px;">
            <button id="settingsClose" class="mix-btn" type="button">é—œé–‰</button>
          </div>
        </div>
      </div>
    </div>

  <!-- æ··éŸ³è»Œé“é¢æ¿ -->
  <div id="mixPanel" class="mix-panel hidden" aria-hidden="true" role="region" aria-label="æ··éŸ³è»Œé“æ§åˆ¶">
    <div class="mix-header">
      <div class="mix-bar-row">
        <div class="mix-bar">
          <span class="mix-muted">ç¸®æ”¾</span>
          <input id="mixZoomRange" type="range" min="5" max="150" step="5" value="50" aria-label="æ··éŸ³è»Œé“ç¸®æ”¾" />
        </div>
        <div class="mix-bar">
          <span class="mix-muted">ä½ç½®</span>
          <input id="mixScrollRange" type="range" min="0" max="100" step="1" value="0" aria-label="æ··éŸ³è»Œé“æª¢è¦–ä½ç½®" />
        </div>
      </div>
      <div id="mixScrollHost" class="mix-scroll-host" aria-hidden="false">
        <div id="mixScrollContent" class="mix-scroll-content">
          <div id="mixTrackLanes" class="mix-track-lanes">
            <div class="mix-track" data-track="0" data-label="1"></div>
            <div class="mix-track" data-track="1" data-label="2"></div>
            <div class="mix-track" data-track="2" data-label="3"></div>
          </div>
          <div id="mixPlayhead" class="mix-playhead" style="left:0"></div>
        </div>
      </div>
    </div>
    <div class="mix-controls">
      <div class="mix-controls-left">
        <button id="mixClearBtn" class="mix-btn" type="button">æ¸…é™¤</button>
      </div>
      <div class="mix-controls-center">
        <button id="mixUndoBtn" class="mix-btn" type="button" aria-label="ä¸Šä¸€æ­¥">â†º</button>
        <button id="mixRedoBtn" class="mix-btn" type="button" aria-label="ä¸‹ä¸€æ­¥">â†»</button>
        <button id="mixToStartBtn" class="mix-btn" type="button" aria-label="ç§»åˆ°é–‹é ­">â®</button>
        <button id="mixPlayPauseBtn" class="mix-btn" type="button" aria-label="æ’­æ”¾æˆ–æš«åœ">â–¶</button>
        <button id="mixToEndBtn" class="mix-btn" type="button" aria-label="ç§»åˆ°çµå°¾">â­</button>
      </div>
      <div class="mix-controls-right">
        <button id="mixCloseBtn" class="mix-btn" type="button">é—œé–‰</button>
      </div>
    </div>
  </div>

  <!-- æ··éŸ³æ¸…é™¤ç¢ºèª -->
  <div id="mixConfirmModal" class="mix-modal-backdrop hidden" role="dialog" aria-modal="true"
    aria-labelledby="mixConfirmTitle">
    <div class="mix-modal">
      <h3 id="mixConfirmTitle">è¦æ¸…é™¤æ‰€æœ‰éŸ³è»Œå—ï¼Ÿ</h3>
      <div class="mix-modal-actions">
        <button id="mixConfirmCancel" class="mix-btn" type="button">å–æ¶ˆ</button>
        <button id="mixConfirmAccept" class="mix-btn" type="button">æ¸…é™¤</button>
      </div>
    </div>
  </div>

  <!-- æ’­æ”¾å½©è›‹èˆå° -->
  <div id="stage" class="stage" aria-hidden="true"></div>
  <!-- å³éµ/é•·æŒ‰é¸å–® -->
  <div id="menu" class="menu hidden" role="menu" aria-label="éŸ³æ•ˆé¸å–®"></div>
  <!-- Toastæç¤º -->
  <div id="toast" class="toast hidden" role="status" aria-live="polite"></div>
  <!--
<script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.3/Sortable.min.js"></script>
-->
  <script src="scripts/Tone.js"></script>
  <script src="scripts/Sortable.min.js"></script>
  <script>
    (function () {
      /**
       * æª”æ¡ˆç‰ˆæœ¬å­—ä¸²ï¼šæ¯æ¬¡éƒ¨ç½²è®Šæ›´æ­¤å€¼ï¼Œå¯ç¢ºä¿æŠ“å–æœ€æ–°è³‡æ–™ä¸¦å¼·åˆ¶ CDN/ç€è¦½å™¨é‡æ–°è¼‰å…¥ã€‚
       */
      const VERSION = 'ver2025-10-27-1';

      /**
       * ç‚ºçµ¦å®šçš„ URL é™„åŠ ç‰ˆæœ¬å­—ä¸² (?v=<VERSION>)ã€‚å¦‚æœå·²æœ‰æŸ¥è©¢åƒæ•¸å‰‡åŠ  &ã€‚
       * @param {string} url
       * @returns {string}
       */
      function withV(url) {
        return url + (url.includes('?') ? '&' : '?') + 'v=' + encodeURIComponent(VERSION);
      }

      /** Fisher-Yates æ´—ç‰Œæ¼”ç®—æ³• **/
      function shuffleInPlace(arr, rng = Math.random) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      /** @typedef {{key:string, name:string, color:string, role:'streamer'|'category', avatar?:string}} Tag */
      /** @typedef {{file:string, title:string, tags:string[]}} SoundConf */
      /** @typedef {{id:string, src:string, title:string, tags:string[]}} Sound */

      // å…ƒç´ å¼•ç”¨ã€‚å° menu èˆ‡ toast ä½¿ç”¨ getter ç¢ºä¿ DOM å·²å­˜åœ¨ã€‚
      const els = {
        q: document.getElementById('q'),
        activeChips: document.getElementById('activeChips'),
        grid: document.getElementById('grid'),
        favGrid: document.getElementById('favGrid'),
        empty: document.getElementById('empty'),
        favEmpty: document.getElementById('favEmpty'),
  settingsBtn: document.getElementById('settingsBtn'),
  themeBtn: document.getElementById('themeBtn'),
        stage: document.getElementById('stage'),
        clearBtn: document.getElementById('clearBtn'),
        get menu() { return document.getElementById('menu'); },
        get toast() { return document.getElementById('toast'); },
        mixPanel: document.getElementById('mixPanel'),
        mixScrollHost: document.getElementById('mixScrollHost'),
        mixScrollContent: document.getElementById('mixScrollContent'),
        mixTrackLanes: document.getElementById('mixTrackLanes'),
        mixPlayhead: document.getElementById('mixPlayhead'),
        mixScrollRange: document.getElementById('mixScrollRange'),
        mixZoomRange: document.getElementById('mixZoomRange'),
        mixClearBtn: document.getElementById('mixClearBtn'),
        mixUndoBtn: document.getElementById('mixUndoBtn'),
        mixRedoBtn: document.getElementById('mixRedoBtn'),
        mixToStartBtn: document.getElementById('mixToStartBtn'),
        mixPlayPauseBtn: document.getElementById('mixPlayPauseBtn'),
        mixToEndBtn: document.getElementById('mixToEndBtn'),
        mixCloseBtn: document.getElementById('mixCloseBtn'),
        mixConfirmModal: document.getElementById('mixConfirmModal'),
        mixConfirmCancel: document.getElementById('mixConfirmCancel'),
        mixConfirmAccept: document.getElementById('mixConfirmAccept'),
        openMixBtn: document.getElementById('openMixBtn'),
        // åˆ†é å®¹å™¨
        pageHome: document.getElementById('page-home'),
        pageGame: document.getElementById('page-game'),
    pageAbout: document.getElementById('page-about'),
  pageawards: document.getElementById('page-awards'),
  pageBg: document.getElementById('page-bg'),
    // settings modal elements (added)
    settingsModal: document.getElementById('settingsModal'),
    settingsClose: document.getElementById('settingsClose'),
    settingsVolume: document.getElementById('settingsVolume'),
    settingsVolumeValue: document.getElementById('settingsVolumeValue'),
        navToggle: document.getElementById('navToggle'),
        // å°è¦½æ¨™ç±¤ï¼ˆå‹•æ…‹æŠ“å–ï¼‰
        get navTabs() { return document.querySelectorAll('.tab'); },
        // æ¨™ç±¤ä¸€è¦½å®¹å™¨
        tagList: document.getElementById('tagList'),
        // æ”¶åˆ°çš„åˆ—è¡¨
        receivedSection: document.getElementById('receivedSection'),
        receivedGrid: document.getElementById('receivedGrid'),
        receivedHeader: document.getElementById('receivedHeader'),
  awardsTop10: document.getElementById('awards-top10'),
  awardsNext20: document.getElementById('awards-next20'),
        // æœ€æ„›æ’åº/åˆ†äº«èˆ‡æ´—ç‰ŒæŒ‰éˆ•
        sortFavBtn: document.getElementById('sortFavBtn'),
        doneSortBtn: document.getElementById('doneSortBtn'),
        shareFavBtn: document.getElementById('shareFavBtn'),
        shuffleBtn: document.getElementById('shuffleBtn'),
        resetOrderBtn: document.getElementById('resetOrderBtn')
      };

      // å…¨åŸŸç‹€æ…‹ã€‚
      const state = {
        tags: /** @type {Record<string, Tag>} */ ({}),
        tagList: /** @type {Tag[]} */ ([]),
        sounds: /** @type {Sound[]} */ ([]),
        favorites: JSON.parse(localStorage.getItem('favorites') || '[]'),
        favSet: new Set(),
        queryText: '',
        queryTags: new Set(),
        soundMap: new Map(),
        // é•·æŒ‰/å³éµé–‹é¸å–®çš„è¨ˆæ™‚å™¨
        contextTimer: null,
        // åˆ†é ç‹€æ…‹ï¼šhome | game | about
        page: 'home',
        // åˆ†äº«åˆ—è¡¨æ”¶åˆ°çš„ id é™£åˆ—
        receivedList: /** @type {string[]} */ ([]),
        // å·²ç§»é™¤è‡ªå‹•æ’­æ”¾åŠŸèƒ½
        // Toast è¨ˆæ™‚å™¨ id
        toastTimer: null,
        // ä½¿ç”¨éçš„æ¨™ç±¤åˆ—è¡¨
        usedTagList: /** @type {Tag[]} */ ([]),
        // æ’åºç·¨è¼¯æ¨¡å¼
        isSorting: false,
        sortable: /** @type {any} */ (null),
        // ç›®å‰è¢«é«˜äº®ï¼ˆæŒçºŒå¤–å…‰æšˆï¼‰çš„éŸ³æ•ˆå¡ç‰‡ idï¼ˆè‹¥æœ‰ï¼‰
        highlightedCardId: '',
        // å°éŠæˆ²ï¼ˆConcentrationï¼‰æ˜¯å¦æ­£åœ¨é€²è¡Œä¸­
        cgRunning: false,
        // å„²å­˜ä¸€ä»½è¼‰å…¥æ™‚çš„é è¨­éŸ³æ•ˆé †åºï¼ˆç”¨æ–¼å›å¾©é è¨­æ’åºï¼‰
        defaultSoundsSnapshot: []
      };

      // åˆå§‹åŒæ­¥ favorites Set ä¾›å¿«é€ŸæŸ¥è©¢
      state.favSet = new Set(state.favorites);

      // å…¨åŸŸéŸ³é‡ï¼ˆ0.0 - 1.0ï¼‰ï¼Œå¾ localStorage è¼‰å…¥ï¼Œé è¨­ 1.0ï¼ˆ100%ï¼‰
      state.globalVolume = (function () {
        try {
          const v = localStorage.getItem('globalVolume');
          if (v !== null) {
            const n = Number(v);
            if (!isNaN(n) && n >= 0 && n <= 1) return n;
          }
        } catch (e) { }
        return 1.0;
      })();

      function applyVolumeToAudio(a) {
        try { if (a && typeof a.volume === 'number') a.volume = state.globalVolume; } catch (e) { }
      }

      /**
       * å»ºç«‹ä¸€å€‹ Audio æ’­æ”¾å™¨ä¸¦å•Ÿå‹•æ’­æ”¾ã€‚æœƒè‡ªå‹•å¥—ç”¨å…¨åŸŸéŸ³é‡ä¸¦ç¶å®šå¸¸ç”¨ callbackã€‚
       * @param {string} src éŸ³æª” URL
       * @param {{snd?:object, onPlay?:function, onEnded?:function, preload?:string, loop?:boolean}} opts
       * @returns {HTMLAudioElement}
       */
      function createPlayer(src, opts = {}) {
        try {
          const { snd = null, onPlay = null, onEnded = null, preload = 'auto', loop = false, autoplay = true } = opts;
          const audio = new Audio(src);
          if (preload) audio.preload = preload;
          audio.loop = !!loop;
          if (onPlay && typeof onPlay === 'function') audio.addEventListener('play', () => onPlay(snd, audio));
          if (onEnded && typeof onEnded === 'function') audio.addEventListener('ended', () => onEnded(snd, audio));
          applyVolumeToAudio(audio);
          if (autoplay) {
            try { audio.play().catch(() => { }); } catch (e) { }
          }
          return audio;
        } catch (e) { console.warn('[createPlayer] failed', e); return null; }
      }

      /**
       * ä»¥ sound ç‰©ä»¶ï¼ˆå…·æœ‰ id/src/title/tagsï¼‰æ’­æ”¾ï¼Œä¸¦é€£çµ onPlayStart/onPlayEnd ä»¥ä¿ç•™èˆå°é¡¯ç¤ºè¡Œç‚ºã€‚
       * @param {{id:string,src:string,title?:string,tags?:string[]}} snd
       * @returns {HTMLAudioElement|null}
       */
      function playSoundObject(snd) {
        if (!snd || !snd.src) return null;
        return createPlayer(snd.src, { snd, onPlay: onPlayStart, onEnded: onPlayEnd, preload: 'auto' });
      }

      // Concentration game cleanup hook (set when game initialized)
      let cgCleanup = null;


      // DOM å¿«é€Ÿå»ºé€ å·¥å…·
      const dom = {
        el(tag, attrs = {}, children = []) {
          const e = document.createElement(tag);
          Object.entries(attrs).forEach(([k, v]) => {
            if (k === 'class') e.className = v;
            else if (k === 'style') Object.assign(e.style, v);
            else if (k.startsWith('on') && typeof v === 'function') e.addEventListener(k.substring(2), v);
            else if (v !== undefined && v !== null) e.setAttribute(k, v);
          });
          (Array.isArray(children) ? children : [children]).filter(Boolean).forEach(c => {
            if (typeof c === 'string') e.appendChild(document.createTextNode(c));
            else e.appendChild(c);
          });
          return e;
        },
        svgHeart() {
          const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.setAttribute('viewBox', '0 0 24 24');
          svg.innerHTML = '<path d="M12 21s-6.716-4.438-9.428-7.15C.59 11.868.59 8.608 2.57 6.627 4.55 4.647 7.81 4.647 9.79 6.627L12 8.838l2.21-2.21c1.98-1.98 5.24-1.98 7.22 0 1.98 1.98 1.98 5.24 0 7.223C18.716 16.562 12 21 12 21z" fill="none" stroke="currentColor" stroke-width="1.5"/>';
          return svg;
        }
      };

      // å·¥å…·å‡½å¼
      const utils = {
        slug(s) { return s.normalize('NFKC').trim(); },
        byId(id) { return document.getElementById(id); },
        saveFav() { localStorage.setItem('favorites', JSON.stringify(state.favorites)); },
        inFav(id) { return state.favSet.has(id); },
        // ä¸‹è¼‰éŸ³æª”
        download(url, filename) {
          const a = document.createElement('a');
          a.href = url;
          a.download = filename || '';
          document.body.appendChild(a);
          a.click();
          a.remove();
        },
        // è§£æè¼¸å…¥æ¡†æ–‡å­—èˆ‡ç›®å‰å·²é¸æ¨™ç±¤ï¼Œå›å‚³ {terms, tags}
        parseQuery() {
          const raw = state.queryText.trim();
          const parts = raw.length ? raw.split(/\s+/) : [];
          const tags = new Set([...state.queryTags]);
          const terms = [];
          for (const p of parts) {
            if (p.startsWith('#')) tags.add(utils.slug(p.slice(1)));
            else terms.push(utils.slug(p));
          }
          return { terms, tags };
        },
        // åˆ¤æ–·éŸ³æ•ˆæ˜¯å¦åŒ¹é…æœå°‹æ¢ä»¶
        match(sound, terms, tags) {
          for (const t of tags) {
            if (!sound.tags.some(s => utils.slug(s) === t)) return false;
          }
          for (const term of terms) {
            const inTitle = sound.title.toLowerCase().includes(term.toLowerCase());
            const inTags = sound.tags.some(t => t.toLowerCase().includes(term.toLowerCase()));
            if (!(inTitle || inTags)) return false;
          }
          return true;
        }
        ,
        // Debounce helper to limit how often a callback runs while an input is changing
        // usage: const debounced = utils.debounce(fn, 200);
        debounce(fn, wait = 200) {
          let t = null;
          return (...args) => {
            if (t) clearTimeout(t);
            t = setTimeout(() => { t = null; try { fn(...args); } catch (e) { console.error(e); } }, wait);
          };
        }
      };

      /** ===== æ··éŸ³è»Œé“ç‹€æ…‹ ===== */
      const MIX_TRACK_COUNT = 3;
      const MIX_STORAGE_KEY = 'mix_tracks_v1';
      const MIX_HISTORY_LIMIT = 10;
      const MIX_MIN_SECONDS = 30;
      const MIX_PX_PER_SEC_DEFAULT = 30;
      const MIX_ZOOM_MIN = 20;
      const MIX_ZOOM_MAX = 120;

      /**
       * @typedef {{id:string,soundId:string,start:number,duration:number,track:number}} MixClip
       */

      const mixState = {
        tracks: Array.from({ length: MIX_TRACK_COUNT }, () => /** @type {MixClip[]} */([])),
        playhead: 0,
        pxPerSecond: MIX_PX_PER_SEC_DEFAULT,
        contentDuration: 0,
        timelineDuration: MIX_MIN_SECONDS,
        durationCache: new Map(),
        durationRequests: new Map(),
        history: [],
        future: [],
        isOpen: false,
        isPlaying: false,
        scrollRatio: 0,
        initialized: false
      };

      const mixAudio = {
        players: new Map(),
        loading: new Map(),
        rafId: 0,
        startTime: 0,
        startPlayhead: 0,
        scheduleIds: [],
        masterGain: null,
        toneStarted: false
      };

      let mixDrag = null;
      let mixPan = null;
      let mixPanSuppressClick = false;
      let mixZoomPersistTimer = null;

      function mixResetTracks() {
        return Array.from({ length: MIX_TRACK_COUNT }, () => /** @type {MixClip[]} */([]));
      }

      function mixNormalizeClip(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const soundId = typeof raw.soundId === 'string' ? raw.soundId : '';
        if (!soundId) return null;
        const start = Number(raw.start);
        const duration = Number(raw.duration);
        const track = Number(raw.track);
        if (!Number.isFinite(start) || start < 0) return null;
        if (!Number.isFinite(duration) || duration <= 0) return null;
        if (!Number.isInteger(track) || track < 0 || track >= MIX_TRACK_COUNT) return null;
        const id = typeof raw.id === 'string' && raw.id ? raw.id : mixGenerateClipId();
        return { id, soundId, start: mixRoundSeconds(start), duration: mixRoundSeconds(duration), track };
      }

      /**
       * å°‡ localStorage ä¸­çš„ç‰‡æ®µè³‡æ–™ï¼ˆæ”¯æ´æ–°ç‰ˆç¸®å¯«éµèˆ‡èˆŠç‰ˆå®Œæ•´éµï¼‰è½‰æ›æˆæ¨™æº– clip ç‰©ä»¶ã€‚
       * æ–°ç‰ˆç¸®å¯«éµå°ç…§ï¼šsid(soundId)ã€st(start)ã€du(duration)ã€tr(track)ã€‚
       */
      function mixNormalizeClipFromStorage(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const converted = {
          id: raw.id,
          soundId: raw.sid ?? raw.soundId,
          start: raw.st ?? raw.start,
          duration: raw.du ?? raw.duration,
          track: raw.tr ?? raw.track
        };
        return mixNormalizeClip(converted);
      }

      function mixRoundSeconds(value) {
        if (!Number.isFinite(value)) return 0;
        return Number(value.toFixed(3));
      }

      function mixGenerateClipId() {
        return 'cp-' + Math.random().toString(36).slice(3, 6) + Date.now().toString(36).slice(-2);
      }

      function mixRecalculateDuration() {
        let max = 0;
        mixState.tracks.forEach(track => track.forEach(clip => {
          const end = clip.start + clip.duration;
          if (end > max) max = end;
        }));
        mixState.contentDuration = max;
        mixState.timelineDuration = Math.max(MIX_MIN_SECONDS, Math.ceil(max));
        if (mixState.playhead > mixState.timelineDuration) mixState.playhead = mixState.timelineDuration;
        return mixState.timelineDuration;
      }

      function mixGetTimelineWidth() {
        return mixState.timelineDuration * mixState.pxPerSecond;
      }

      function mixResolveSoundColor(sound) {
        if (!sound || !Array.isArray(sound.tags)) return '#64748b';
        for (const tag of sound.tags) {
          const t = state.tags[utils.slug(tag)];
          if (t && t.color) return t.color;
        }
        return '#64748b';
      }

      function mixGetDurationForSound(sound) {
        if (!sound) return 2;
        const cached = mixState.durationCache.get(sound.id);
        if (typeof cached === 'number' && cached > 0) return cached;
        return 2;
      }

      function mixApplyDurationToClips(soundId, duration) {
        let updated = false;
        const rounded = mixRoundSeconds(duration);
        mixState.tracks.forEach(track => {
          track.forEach(clip => {
            if (clip.soundId === soundId) {
              if (Math.abs(clip.duration - rounded) > 0.0001) {
                clip.duration = rounded;
                updated = true;
              }
            }
          });
        });
        if (updated) {
          mixRecalculateDuration();
          mixRenderAll();
          mixSaveToStorage();
        }
      }

      function mixRequestDuration(sound, clip) {
        if (!sound) return;
        const cached = mixState.durationCache.get(sound.id);
        if (typeof cached === 'number' && cached > 0) return;
        if (mixState.durationRequests.has(sound.id)) return;
        const audio = new Audio();
        audio.preload = 'metadata';
        audio.src = sound.src;
  applyVolumeToAudio(audio);
        const promise = new Promise((resolve) => {
          const cleanup = () => {
            audio.removeEventListener('loadedmetadata', onLoaded);
            audio.removeEventListener('error', onError);
            audio.src = '';
          };
          const onLoaded = () => {
            const dur = Number(audio.duration);
            cleanup();
            if (isFinite(dur) && dur > 0) {
              const rounded = mixRoundSeconds(dur);
              mixState.durationCache.set(sound.id, rounded);
              mixApplyDurationToClips(sound.id, rounded);
              if (clip) { clip.duration = rounded; }
            }
            resolve();
          };
          const onError = () => {
            cleanup();
            resolve();
          };
          audio.addEventListener('loadedmetadata', onLoaded, { once: true });
          audio.addEventListener('error', onError, { once: true });
          try { audio.load(); } catch (e) { cleanup(); resolve(); }
        });
        mixState.durationRequests.set(sound.id, promise);
        promise.finally(() => mixState.durationRequests.delete(sound.id));
      }

      function mixHydrateClip(clip) {
        const snd = state.soundMap.get(clip.soundId);
        if (!snd) return;
        if (!mixState.durationCache.has(snd.id)) {
          mixRequestDuration(snd, clip);
        }
      }

      function mixCreateClipElement(clip) {
        const snd = state.soundMap.get(clip.soundId);
        const title = snd?.title || clip.soundId;
        const width = Math.max(clip.duration * mixState.pxPerSecond, 36);
        const left = clip.start * mixState.pxPerSecond;
        const color = mixResolveSoundColor(snd);
        const removeBtn = dom.el('button', { class: 'mix-clip-remove', type: 'button', 'data-clip-id': clip.id, 'aria-label': 'ç§»é™¤éŸ³æ•ˆ' }, 'Ã—');
        removeBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          mixRemoveClipById(clip.id);
        });
        const titleEl = dom.el('span', { class: 'mix-clip-title' }, title);
        const clipEl = dom.el('div', {
          class: 'mix-clip',
          'data-clip-id': clip.id,
          style: { left: `${left}px`, width: `${width}px`, background: color },
          title
        }, [
          titleEl,
          removeBtn
        ]);
        clipEl.dataset.start = String(clip.start);
        clipEl.dataset.duration = String(clip.duration);
        clipEl.dataset.track = String(clip.track);
        return clipEl;
      }

      function mixRenderTracks() {
        const lanes = els.mixTrackLanes;
        if (!lanes) return;
        const width = mixGetTimelineWidth();
        const trackEls = lanes.querySelectorAll('.mix-track');
        trackEls.forEach(trackEl => {
          trackEl.style.width = width + 'px';
          trackEl.innerHTML = '';
        });
        mixState.tracks.forEach((track, idx) => {
          const trackEl = lanes.querySelector(`.mix-track[data-track="${idx}"]`);
          if (!trackEl) return;
          track.sort((a, b) => a.start - b.start || a.id.localeCompare(b.id));
          track.forEach(clip => {
            mixHydrateClip(clip);
            const el = mixCreateClipElement(clip);
            trackEl.appendChild(el);
          });
        });
      }

      function mixRenderPlayhead() {
        const ph = els.mixPlayhead;
        if (!ph) return;
        const x = mixState.playhead * mixState.pxPerSecond;
        ph.style.left = `${x}px`;
      }

      function mixUpdateScrollState() {
        const host = els.mixScrollHost;
        const range = els.mixScrollRange;
        if (!host || !range) return;
        const maxScroll = Math.max(0, host.scrollWidth - host.clientWidth);
        if (maxScroll <= 1) {
          range.value = '0';
          range.disabled = true;
          mixState.scrollRatio = 0;
          return;
        }
        range.disabled = false;
        const ratio = host.scrollLeft / maxScroll;
        mixState.scrollRatio = isFinite(ratio) ? ratio : 0;
        range.value = String(Math.round(mixState.scrollRatio * 100));
      }

      function mixOnWheelZoom(event) {
        const host = els.mixScrollHost;
        if (!host) return;
        if (mixState.timelineDuration <= 0) return;
        const deltaY = event.deltaY || 0;
        const deltaX = event.deltaX || 0;
        const primaryDelta = Math.abs(deltaY) >= Math.abs(deltaX) ? deltaY : deltaX;
        if (primaryDelta === 0) return;
        event.preventDefault();
        const step = primaryDelta > 0 ? -5 : 5;
        if (step === 0) return;
        const rect = host.getBoundingClientRect();
        const anchor = event.clientX - rect.left;
        const before = mixState.pxPerSecond;
        mixApplyZoom(mixState.pxPerSecond + step, { persist: false, anchorPixel: anchor });
        if (before !== mixState.pxPerSecond) {
          if (mixZoomPersistTimer) clearTimeout(mixZoomPersistTimer);
          mixZoomPersistTimer = setTimeout(() => {
            mixSaveToStorage();
            mixZoomPersistTimer = null;
          }, 240);
        }
      }

      function mixOnScrollRangeInput() {
        const host = els.mixScrollHost;
        const range = els.mixScrollRange;
        if (!host || !range) return;
        const maxScroll = Math.max(0, host.scrollWidth - host.clientWidth);
        const ratio = Number(range.value) / 100;
        host.scrollLeft = maxScroll * ratio;
        mixState.scrollRatio = isFinite(ratio) ? ratio : 0;
        mixUpdateScrollState();
      }

      function mixRenderAll() {
        if (!els.mixPanel) return;
        mixRecalculateDuration();
        const contentWidth = mixGetTimelineWidth();
        if (els.mixScrollContent) els.mixScrollContent.style.width = `${contentWidth}px`;
        if (els.mixZoomRange) {
          const rounded = String(Math.round(mixState.pxPerSecond));
          if (els.mixZoomRange.value !== rounded) els.mixZoomRange.value = rounded;
        }
        mixRenderTracks();
        const host = els.mixScrollHost;
        if (host) {
          const maxScroll = Math.max(0, host.scrollWidth - host.clientWidth);
          host.scrollLeft = maxScroll * mixState.scrollRatio;
        }
        mixRenderPlayhead();
        mixUpdateScrollState();
        mixUpdateControlStates();
      }

      function mixScrollPlayheadIntoView() {
        const host = els.mixScrollHost;
        if (!host) return;
        const x = mixState.playhead * mixState.pxPerSecond;
        const padding = 40;
        if (x < host.scrollLeft + padding) {
          host.scrollLeft = Math.max(0, x - padding);
        } else if (x > host.scrollLeft + host.clientWidth - padding) {
          host.scrollLeft = Math.max(0, x - host.clientWidth + padding);
        }
        mixUpdateScrollState();
      }

      function mixScrollClipIntoView(clip) {
        const host = els.mixScrollHost;
        if (!host) return;
        const startX = clip.start * mixState.pxPerSecond;
        const endX = (clip.start + clip.duration) * mixState.pxPerSecond;
        const padding = 40;
        if (startX < host.scrollLeft + padding) {
          host.scrollLeft = Math.max(0, startX - padding);
        } else if (endX > host.scrollLeft + host.clientWidth - padding) {
          host.scrollLeft = Math.max(0, endX - host.clientWidth + padding);
        }
        mixUpdateScrollState();
      }

      function mixApplyZoom(pxPerSecond, { persist = true, maintainCenter = false, anchorPixel = null } = {}) {
        const host = els.mixScrollHost;
        const previousPx = mixState.pxPerSecond;
        const clamped = Math.min(MIX_ZOOM_MAX, Math.max(MIX_ZOOM_MIN, Number(pxPerSecond) || MIX_PX_PER_SEC_DEFAULT));
        let targetScrollRatio = mixState.scrollRatio;
        if (anchorPixel != null && host) {
          const anchorLocal = Math.max(0, Math.min(anchorPixel, host.clientWidth));
          const currentWidth = mixState.timelineDuration * previousPx;
          const anchorAbsolute = host.scrollLeft + anchorLocal;
          const anchorRatio = currentWidth > 0 ? anchorAbsolute / currentWidth : 0;
          const newWidth = mixState.timelineDuration * clamped;
          const targetAnchor = newWidth * anchorRatio;
          const targetScrollLeft = Math.max(0, targetAnchor - anchorLocal);
          const maxScroll = Math.max(0, newWidth - host.clientWidth);
          targetScrollRatio = maxScroll > 0 ? targetScrollLeft / maxScroll : 0;
        } else if (maintainCenter && host) {
          const currentWidth = mixState.timelineDuration * previousPx;
          const center = host.scrollLeft + host.clientWidth / 2;
          const centerRatio = currentWidth > 0 ? center / currentWidth : 0;
          const newWidth = mixState.timelineDuration * clamped;
          const targetCenter = newWidth * centerRatio;
          const targetScrollLeft = Math.max(0, targetCenter - host.clientWidth / 2);
          const maxScroll = Math.max(0, newWidth - host.clientWidth);
          targetScrollRatio = maxScroll > 0 ? targetScrollLeft / maxScroll : 0;
        }
        if (Math.abs(clamped - mixState.pxPerSecond) < 0.0001) {
          if (persist) mixSaveToStorage();
          return;
        }
        mixState.pxPerSecond = clamped;
        mixState.scrollRatio = Math.min(1, Math.max(0, targetScrollRatio));
        mixRenderAll();
        if (host && (maintainCenter || anchorPixel != null)) {
          const maxScroll = Math.max(0, host.scrollWidth - host.clientWidth);
          host.scrollLeft = maxScroll * mixState.scrollRatio;
          mixUpdateScrollState();
        }
        if (els.mixZoomRange) {
          const rounded = String(Math.round(mixState.pxPerSecond));
          if (els.mixZoomRange.value !== rounded) els.mixZoomRange.value = rounded;
        }
        if (persist) mixSaveToStorage();
      }

      function mixSaveToStorage() {
        try {
          // å„²å­˜æ™‚æ¡ç”¨ç¸®å¯«éµä»¥æ¸›å°‘ metadata é«”ç©ï¼šplh(playhead)ã€pps(pxPerSecond)ã€trs(tracks array)ã€‚
          const payload = {
            plh: mixRoundSeconds(mixState.playhead),
            pps: mixState.pxPerSecond,
            trs: mixState.tracks.map(track => track.map(clip => ({
              id: clip.id,
              sid: clip.soundId,       // sound id
              st: mixRoundSeconds(clip.start),
              du: mixRoundSeconds(clip.duration),
              tr: clip.track
            })))
          };
          localStorage.setItem(MIX_STORAGE_KEY, JSON.stringify(payload));
        } catch (err) {
          console.warn('[mix] save failed', err);
        }
      }

      function mixLoadFromStorage() {
        try {
          const raw = localStorage.getItem(MIX_STORAGE_KEY);
          if (!raw) { mixState.tracks = mixResetTracks(); mixState.playhead = 0; mixState.pxPerSecond = MIX_PX_PER_SEC_DEFAULT; mixRecalculateDuration(); return; }
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== 'object') throw new Error('invalid mix payload');
          const tracks = mixResetTracks();
          const rawTracks = Array.isArray(parsed.trs) ? parsed.trs : parsed.tracks;
          for (let i = 0; i < MIX_TRACK_COUNT; i++) {
            const arr = Array.isArray(rawTracks?.[i]) ? rawTracks[i] : [];
            tracks[i] = arr.map(mixNormalizeClipFromStorage).filter(Boolean).sort((a, b) => a.start - b.start || a.id.localeCompare(b.id));
          }
          mixState.tracks = tracks;
          const rawPlayhead = parsed.plh ?? parsed.playhead;
          mixState.playhead = mixRoundSeconds(Math.max(0, Number(rawPlayhead) || 0));
          const storedPx = Number(parsed.pps ?? parsed.pxPerSecond);
          if (Number.isFinite(storedPx) && storedPx >= MIX_ZOOM_MIN && storedPx <= MIX_ZOOM_MAX) {
            mixState.pxPerSecond = storedPx;
          } else {
            mixState.pxPerSecond = MIX_PX_PER_SEC_DEFAULT;
          }
          mixRecalculateDuration();
        } catch (err) {
          console.warn('[mix] load failedï¼Œå·²é‚„åŸç‚ºé è¨­å€¼ã€‚', err);
          localStorage.removeItem(MIX_STORAGE_KEY);
          mixState.tracks = mixResetTracks();
          mixState.playhead = 0;
          mixState.pxPerSecond = MIX_PX_PER_SEC_DEFAULT;
          mixRecalculateDuration();
        }
        mixState.history = [];
        mixState.future = [];
        mixState.scrollRatio = 0;
      }

      function mixHasClips() {
        return mixState.tracks.some(track => track.length > 0);
      }

      function mixCloneState() {
        return {
          playhead: mixState.playhead,
          tracks: mixState.tracks.map(track => track.map(clip => ({
            ...clip,
            start: mixRoundSeconds(clip.start),
            duration: mixRoundSeconds(clip.duration)
          })))
        };
      }

      function mixStageHistory() {
        mixState.history.push(mixCloneState());
        if (mixState.history.length > MIX_HISTORY_LIMIT) {
          mixState.history.shift();
        }
        mixState.future = [];
      }

      function mixRestoreFromSnapshot(snapshot) {
        mixState.tracks = snapshot.tracks.map(track => track.map(clip => ({ ...clip })));
        mixState.playhead = snapshot.playhead;
        mixRecalculateDuration();
        mixRenderAll();
        mixSaveToStorage();
      }

      function mixUndo() {
        if (mixState.isPlaying || mixState.history.length === 0) return;
        const snapshot = mixState.history.pop();
        if (!snapshot) return;
        mixState.future.push(mixCloneState());
        if (mixState.future.length > MIX_HISTORY_LIMIT) mixState.future.shift();
        mixRestoreFromSnapshot(snapshot);
      }

      function mixRedo() {
        if (mixState.isPlaying || mixState.future.length === 0) return;
        const snapshot = mixState.future.pop();
        if (!snapshot) return;
        mixState.history.push(mixCloneState());
        if (mixState.history.length > MIX_HISTORY_LIMIT) mixState.history.shift();
        mixRestoreFromSnapshot(snapshot);
      }

      function mixUpdatePlayButton() {
        if (!els.mixPlayPauseBtn) return;
        els.mixPlayPauseBtn.textContent = mixState.isPlaying ? 'â¸' : 'â–¶';
        els.mixPlayPauseBtn.setAttribute('aria-label', mixState.isPlaying ? 'æš«åœæ··éŸ³' : 'æ’­æ”¾æ··éŸ³');
      }

      function mixUpdateControlStates() {
        const playing = mixState.isPlaying;
        const hasClips = mixHasClips();
        if (els.mixUndoBtn) els.mixUndoBtn.disabled = playing || mixState.history.length === 0;
        if (els.mixRedoBtn) els.mixRedoBtn.disabled = playing || mixState.future.length === 0;
        if (els.mixPlayPauseBtn) {
          els.mixPlayPauseBtn.disabled = !hasClips;
          mixUpdatePlayButton();
        }
        if (els.mixClearBtn) els.mixClearBtn.disabled = playing || !hasClips;
        if (els.mixToStartBtn) els.mixToStartBtn.disabled = !hasClips;
        if (els.mixToEndBtn) els.mixToEndBtn.disabled = !hasClips;
      }

      function mixFindClipById(id) {
        for (let trackIndex = 0; trackIndex < MIX_TRACK_COUNT; trackIndex++) {
          const track = mixState.tracks[trackIndex];
          const index = track.findIndex(c => c.id === id);
          if (index !== -1) {
            return { clip: track[index], trackIndex, index };
          }
        }
        return null;
      }

      function mixRemoveClipById(clipId, { silent = false, recordHistory = true } = {}) {
        if (!clipId) return null;
        if (mixState.isPlaying) return null;
        const loc = mixFindClipById(clipId);
        if (!loc) return null;
        if (recordHistory) mixStageHistory();
        const track = mixState.tracks[loc.trackIndex];
        const [removed] = track.splice(loc.index, 1);
        mixRecalculateDuration();
        mixSaveToStorage();
        mixRenderAll();
        if (!silent) toast('å·²ç§»é™¤éŸ³æ•ˆ');
        return removed;
      }

      function mixClearAllTracks({ silent = false } = {}) {
        if (mixState.isPlaying || !mixHasClips()) return;
        mixStageHistory();
        mixState.tracks = mixResetTracks();
        mixState.playhead = 0;
        mixRecalculateDuration();
        mixSaveToStorage();
        mixRenderAll();
        if (!silent) toast('å·²æ¸…é™¤æ‰€æœ‰éŸ³æ•ˆ');
      }

      function mixSetPlayhead(seconds, { scroll = true, persist = true } = {}) {
        const clamped = mixRoundSeconds(Math.max(0, Math.min(seconds, mixState.timelineDuration)));
        mixState.playhead = clamped;
        mixRenderPlayhead();
        if (scroll) mixScrollPlayheadIntoView();
        if (persist && !mixState.isPlaying) mixSaveToStorage();
      }

      function mixJumpToStart() {
        let earliest = Infinity;
        mixState.tracks.forEach(track => track.forEach(clip => {
          if (clip.start < earliest) earliest = clip.start;
        }));
        if (!isFinite(earliest)) earliest = 0;
        const wasPlaying = mixState.isPlaying;
        if (wasPlaying) mixStopPlayback(false);
        mixSetPlayhead(earliest, { scroll: true, persist: !wasPlaying });
        if (wasPlaying) {
          const upcoming = mixCollectPlayableClips();
          if (upcoming.length) mixStartPlayback();
          else mixUpdateControlStates();
        }
      }

      function mixJumpToEnd() {
        const end = Math.max(mixState.contentDuration, 0);
        const wasPlaying = mixState.isPlaying;
        if (wasPlaying) mixStopPlayback(false);
        mixSetPlayhead(end, { scroll: true, persist: !wasPlaying });
        if (wasPlaying) {
          const upcoming = mixCollectPlayableClips();
          if (upcoming.length) mixStartPlayback();
          else mixUpdateControlStates();
        }
      }

      function mixFindAvailableTrack(start, duration) {
        for (let i = 0; i < MIX_TRACK_COUNT; i++) {
          const track = mixState.tracks[i];
          const conflict = track.some(clip => !(start + duration <= clip.start || start >= clip.start + clip.duration));
          if (!conflict) return i;
        }
        return 0;
      }

      function mixOnLanesClick(event) {
        if (mixPanSuppressClick) {
          mixPanSuppressClick = false;
          return;
        }
        if (event.target.closest('.mix-clip')) return;
        const host = els.mixScrollHost;
        if (!host) return;
        const rect = host.getBoundingClientRect();
        const x = event.clientX - rect.left + host.scrollLeft;
        const seconds = x / mixState.pxPerSecond;
        const wasPlaying = mixState.isPlaying;
        if (wasPlaying) mixStopPlayback(false);
        mixSetPlayhead(seconds, { scroll: true, persist: !wasPlaying });
        if (wasPlaying) {
          const upcoming = mixCollectPlayableClips();
          if (upcoming.length) mixStartPlayback();
          else mixUpdateControlStates();
        }
      }

      function mixOpenConfirmModal() {
        if (!els.mixConfirmModal) return;
        els.mixConfirmModal.classList.remove('hidden');
        els.mixConfirmModal.setAttribute('aria-hidden', 'false');
        if (els.mixConfirmAccept) try { els.mixConfirmAccept.focus(); } catch (e) { }
      }

      function mixCloseConfirmModal() {
        if (!els.mixConfirmModal) return;
        els.mixConfirmModal.classList.add('hidden');
        els.mixConfirmModal.setAttribute('aria-hidden', 'true');
        if (els.mixClearBtn) try { els.mixClearBtn.focus(); } catch (e) { }
      }

      function mixHandleGlobalKeydown(event) {
        if (event.key === 'Escape') {
          if (els.mixConfirmModal && !els.mixConfirmModal.classList.contains('hidden')) {
            mixCloseConfirmModal();
          }
        }
      }

      // === Clip drag-and-drop ===
      function mixOnClipPointerDown(event) {
        const clipEl = event.target.closest('.mix-clip');
        if (!clipEl) {
          mixBeginPan(event);
          return;
        }
        if (event.button !== undefined && event.button !== 0) return;
        if (event.target.closest('.mix-clip-remove')) return;
        if (mixState.isPlaying) return;
        const clipId = clipEl.dataset.clipId || '';
        const loc = mixFindClipById(clipId);
        if (!loc) return;
        const host = els.mixScrollHost;
        const lanes = els.mixTrackLanes;
        if (!host || !lanes) return;
        const clipRect = clipEl.getBoundingClientRect();
        const hostRect = host.getBoundingClientRect();
        const lanesRect = lanes.getBoundingClientRect();
        const pointerOffsetX = event.clientX - clipRect.left;
        const pointerOffsetY = event.clientY - clipRect.top;
        const placeholder = document.createElement('div');
        placeholder.className = 'mix-clip-placeholder';
        placeholder.style.width = clipRect.width + 'px';
        placeholder.style.height = clipRect.height + 'px';
        const originContainer = clipEl.parentElement;
        if (originContainer) {
          const existingLeft = parseFloat(clipEl.style.left || '0');
          const fallbackLeft = loc.clip.start * mixState.pxPerSecond;
          const placeholderLeft = Number.isFinite(existingLeft) ? existingLeft : fallbackLeft;
          placeholder.style.left = placeholderLeft + 'px';
          originContainer.insertBefore(placeholder, clipEl);
        }
        lanes.appendChild(clipEl);
        const clipWidth = clipRect.width;
        const clipHeight = clipRect.height;
        clipEl.classList.add('dragging');
        clipEl.style.position = 'absolute';
        clipEl.style.zIndex = '10';
        clipEl.style.width = clipWidth + 'px';
        clipEl.style.left = `${event.clientX - lanesRect.left - pointerOffsetX + host.scrollLeft}px`;
        clipEl.style.top = `${clipRect.top - lanesRect.top}px`;

        mixDrag = {
          clip: loc.clip,
          clipEl,
          placeholder,
          pointerId: event.pointerId,
          pointerOffsetX,
          pointerOffsetY,
          clipWidth,
          clipHeight,
          hostRect,
          lanesRect,
          originTrack: loc.trackIndex,
          originStart: loc.clip.start,
          trackHeight: lanes.querySelector('.mix-track')?.offsetHeight || 36,
          historyCaptured: false,
          currentTrack: loc.trackIndex,
          currentStart: loc.clip.start
        };
        try { clipEl.setPointerCapture(event.pointerId); } catch (e) { }
        clipEl.addEventListener('pointermove', mixOnClipPointerMove);
        clipEl.addEventListener('pointerup', mixOnClipPointerUp);
        clipEl.addEventListener('pointercancel', mixOnClipPointerCancel);
        event.preventDefault();
      }

      function mixOnClipPointerMove(event) {
        if (!mixDrag || event.pointerId !== mixDrag.pointerId) return;
        const host = els.mixScrollHost;
        if (!host) return;
        const lanes = els.mixTrackLanes;
        if (!lanes) return;
        const rawLeft = event.clientX - mixDrag.hostRect.left + host.scrollLeft - mixDrag.pointerOffsetX;
        const maxLeft = Math.max(0, mixGetTimelineWidth() - mixDrag.clipWidth);
        const newLeft = Math.min(Math.max(0, rawLeft), maxLeft);
        mixDrag.clipEl.style.left = `${newLeft}px`;
        const newStart = newLeft / mixState.pxPerSecond;
        const pointerCenterY = event.clientY - mixDrag.lanesRect.top - mixDrag.pointerOffsetY + mixDrag.clipHeight / 2;
        const trackHeight = mixDrag.trackHeight;
        const newTrack = Math.min(MIX_TRACK_COUNT - 1, Math.max(0, Math.floor(pointerCenterY / trackHeight)));
        const targetTop = newTrack * trackHeight + Math.max(0, (trackHeight - mixDrag.clipHeight) / 2);
        mixDrag.clipEl.style.top = `${targetTop}px`;
        mixDrag.currentTrack = newTrack;
        mixDrag.currentStart = mixRoundSeconds(Math.max(0, newStart));
        if (!mixDrag.historyCaptured) {
          if (Math.abs(newStart - mixDrag.originStart) > 0.0005 || newTrack !== mixDrag.originTrack) {
            mixStageHistory();
            mixDrag.historyCaptured = true;
          }
        }
        const threshold = 40;
        const maxScroll = Math.max(0, host.scrollWidth - host.clientWidth);
        if (event.clientX > mixDrag.hostRect.right - threshold) {
          host.scrollLeft = Math.min(host.scrollLeft + 14, maxScroll);
        } else if (event.clientX < mixDrag.hostRect.left + threshold) {
          host.scrollLeft = Math.max(host.scrollLeft - 14, 0);
        }
        mixUpdateScrollState();
      }

      function mixCleanupDragElements() {
        if (!mixDrag) return;
        const { clipEl, placeholder } = mixDrag;
        if (placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
        if (clipEl) {
          clipEl.classList.remove('dragging');
          clipEl.style.position = '';
          clipEl.style.zIndex = '';
          clipEl.style.width = '';
          clipEl.style.left = '';
          clipEl.style.top = '';
        }
      }

      /**
       * åœ¨ç©ºç™½è»Œé“ä¸Šæ‹–æ›³ä»¥å¹³ç§»è¦–çª—ï¼ˆç­‰åŒèª¿æ•´ä½ç½®æ»‘æ¡¿ï¼‰ã€‚
       */
      function mixBeginPan(event) {
        const host = els.mixScrollHost;
        const lanes = els.mixTrackLanes;
        if (!host || !lanes) return;
        if (event.button !== undefined && event.button !== 0) return;
        mixPanSuppressClick = false;
        mixPan = {
          pointerId: event.pointerId,
          startX: event.clientX,
          startScroll: host.scrollLeft,
          lanes
        };
        try { lanes.setPointerCapture(event.pointerId); } catch (e) { }
        lanes.addEventListener('pointermove', mixOnPanPointerMove);
        lanes.addEventListener('pointerup', mixEndPan);
        lanes.addEventListener('pointercancel', mixCancelPan);
      }

      function mixOnPanPointerMove(event) {
        if (!mixPan || event.pointerId !== mixPan.pointerId) return;
        const host = els.mixScrollHost;
        if (!host) return;
        const delta = event.clientX - mixPan.startX;
        if (Math.abs(delta) > 2) mixPanSuppressClick = true;
        const maxScroll = Math.max(0, host.scrollWidth - host.clientWidth);
        const nextScroll = Math.min(Math.max(mixPan.startScroll - delta, 0), maxScroll);
        host.scrollLeft = nextScroll;
        mixUpdateScrollState();
        event.preventDefault();
      }

      function mixEndPan(event) {
        mixFinalizePan(event, false);
      }

      function mixCancelPan(event) {
        mixFinalizePan(event, true);
      }

      function mixFinalizePan(event, canceled) {
        if (!mixPan || event.pointerId !== mixPan.pointerId) return;
        const { lanes } = mixPan;
        try { lanes.releasePointerCapture(event.pointerId); } catch (e) { }
        lanes.removeEventListener('pointermove', mixOnPanPointerMove);
        lanes.removeEventListener('pointerup', mixEndPan);
        lanes.removeEventListener('pointercancel', mixCancelPan);
        mixPan = null;
        if (canceled) mixPanSuppressClick = false;
      }

      function mixFinalizeDrag(event, canceled) {
        if (!mixDrag || event.pointerId !== mixDrag.pointerId) return;
        const { clip, clipEl, placeholder, originTrack, originStart, currentTrack, currentStart, historyCaptured } = mixDrag;
        try { clipEl.releasePointerCapture(event.pointerId); } catch (e) { }
        clipEl.removeEventListener('pointermove', mixOnClipPointerMove);
        clipEl.removeEventListener('pointerup', mixOnClipPointerUp);
        clipEl.removeEventListener('pointercancel', mixOnClipPointerCancel);
        const movedMeaningful = Math.abs(currentStart - originStart) > 0.0005 || currentTrack !== originTrack;
        if (!historyCaptured || !movedMeaningful || canceled) {
          if (historyCaptured && mixState.history.length > 0) mixState.history.pop();
          mixCleanupDragElements();
          if (clipEl && clipEl.parentNode) clipEl.parentNode.removeChild(clipEl);
          mixRenderAll();
          mixDrag = null;
          return;
        }
        const originArr = mixState.tracks[originTrack];
        if (currentTrack !== originTrack) {
          const idx = originArr.indexOf(clip);
          if (idx !== -1) originArr.splice(idx, 1);
          mixState.tracks[currentTrack].push(clip);
          clip.track = currentTrack;
        }
        clip.start = mixRoundSeconds(Math.max(0, currentStart));
        mixState.tracks[currentTrack].sort((a, b) => a.start - b.start || a.id.localeCompare(b.id));
        if (currentTrack !== originTrack) {
          originArr.sort((a, b) => a.start - b.start || a.id.localeCompare(b.id));
        }
        mixCleanupDragElements();
        if (clipEl && clipEl.parentNode) clipEl.parentNode.removeChild(clipEl);
        mixRecalculateDuration();
        mixSaveToStorage();
        mixRenderAll();
        mixScrollClipIntoView(clip);
        mixDrag = null;
      }

      function mixOnClipPointerUp(event) {
        mixFinalizeDrag(event, false);
      }

      function mixOnClipPointerCancel(event) {
        mixFinalizeDrag(event, true);
      }

      // === Tone.js playback helpers ===
      function mixCollectPlayableClips() {
        const start = mixState.playhead;
        const clips = [];
        mixState.tracks.forEach(track => {
          track.forEach(clip => {
            if (clip.start + clip.duration > start) {
              clips.push(clip);
            }
          });
        });
        clips.sort((a, b) => a.start - b.start || a.id.localeCompare(b.id));
        return clips;
      }

      function isToneAvailable() {
        return typeof window !== 'undefined' && typeof Tone !== 'undefined' && Tone && typeof Tone.Transport !== 'undefined';
      }

      async function mixEnsureToneStarted() {
        if (!isToneAvailable()) throw new Error('Tone.js unavailable');
        if (!mixAudio.toneStarted) {
          await Tone.start();
          // create a master gain node so we can control mix volume from settings
          try {
            mixAudio.masterGain = new Tone.Gain(state.globalVolume || 1).toDestination();
          } catch (e) {
            mixAudio.masterGain = null;
          }
          mixAudio.toneStarted = true;
        }
      }

      function mixPlayerKey(soundId, track) {
        return `${soundId}::${track}`;
      }

      async function mixGetPlayer(sound, track) {
        const key = mixPlayerKey(sound.id, track);
        if (mixAudio.players.has(key)) return mixAudio.players.get(key);
        if (mixAudio.loading.has(key)) return mixAudio.loading.get(key);
        if (!isToneAvailable()) throw new Error('Tone.js unavailable');
        const promise = new Promise((resolve, reject) => {
          let player;
          try {
            player = new Tone.Player({
              url: sound.src,
              autostart: false,
              onload: () => {
                mixAudio.players.set(key, player);
                const dur = player.buffer?.duration;
                if (isFinite(dur) && dur > 0) {
                  const rounded = mixRoundSeconds(dur);
                  mixState.durationCache.set(sound.id, rounded);
                  mixApplyDurationToClips(sound.id, rounded);
                }
                resolve(player);
              },
              onerror: (err) => {
                try { player.dispose(); } catch (e) { }
                reject(err || new Error('load failed'));
              }
            });
            // route player output to masterGain when available so global volume can control mix playback
            try {
              if (mixAudio.masterGain && typeof mixAudio.masterGain.connect === 'function') {
                player.connect(mixAudio.masterGain);
              } else {
                player.toDestination();
              }
            } catch (e) {
              try { player.toDestination(); } catch (ee) { }
            }
          } catch (err) {
            if (player) try { player.dispose(); } catch (e) { }
            reject(err);
          }
        });
        mixAudio.loading.set(key, promise);
        return promise.finally(() => mixAudio.loading.delete(key));
      }

      async function mixEnsurePlayers(clips) {
        const tasks = clips.map(clip => {
          const sound = state.soundMap.get(clip.soundId);
          if (!sound) return Promise.resolve();
          return mixGetPlayer(sound, clip.track);
        });
        await Promise.all(tasks);
      }

      function mixStartTransportMonitor() {
        mixStopTransportMonitor();
        const tick = () => {
          if (!mixState.isPlaying || !isToneAvailable()) return;
          const elapsed = Tone.now() - mixAudio.startTime;
          const newPos = mixAudio.startPlayhead + elapsed;
          mixState.playhead = Math.min(newPos, mixState.timelineDuration);
          mixRenderPlayhead();
          mixScrollPlayheadIntoView();
          mixAudio.rafId = requestAnimationFrame(tick);
        };
        mixAudio.rafId = requestAnimationFrame(tick);
      }

      function mixStopTransportMonitor() {
        if (mixAudio.rafId) {
          cancelAnimationFrame(mixAudio.rafId);
          mixAudio.rafId = 0;
        }
      }

      async function mixStartPlayback() {
        if (mixState.isPlaying) return;
        if (!mixHasClips()) { toast('æ²’æœ‰å¯æ’­æ”¾çš„ç‰‡æ®µ'); return; }
        if (!isToneAvailable()) { toast('Tone.js è¼‰å…¥å¤±æ•—ï¼Œç„¡æ³•æ’­æ”¾'); return; }
        const clips = mixCollectPlayableClips();
        if (!clips.length) { toast('æ’­æ”¾ä½ç½®ä¹‹å¾Œæ²’æœ‰éŸ³æ•ˆ'); return; }
        try {
          await mixEnsureToneStarted();
          await mixEnsurePlayers(clips);
        } catch (err) {
          console.error('[mix] player load error', err);
          toast('éŸ³è¨Šè¼‰å…¥å¤±æ•—');
          return;
        }
        try {
          Tone.Transport.stop();
          Tone.Transport.cancel();
          mixAudio.scheduleIds.forEach(id => Tone.Transport.clear(id));
          mixAudio.scheduleIds = [];
        } catch (err) { console.warn('[mix] transport reset failed', err); }
        clips.forEach(clip => {
          const key = mixPlayerKey(clip.soundId, clip.track);
          const player = mixAudio.players.get(key);
          if (!player) return;
          const startTime = Math.max(0, clip.start - mixState.playhead);
          const offset = Math.max(0, mixState.playhead - clip.start);
          const remaining = clip.duration - offset;
          if (remaining <= 0) return;
          const id = Tone.Transport.schedule(time => {
            try { player.start(time, offset, remaining); } catch (e) { console.warn('[mix] player start failed', e); }
          }, startTime);
          mixAudio.scheduleIds.push(id);
        });
        const totalRemaining = Math.max(0, mixState.contentDuration - mixState.playhead);
        if (totalRemaining > 0) {
          const stopId = Tone.Transport.schedule(() => mixStopPlayback(true), totalRemaining + 0.05);
          mixAudio.scheduleIds.push(stopId);
        }
        mixAudio.startPlayhead = mixState.playhead;
        mixAudio.startTime = Tone.now();
        mixState.isPlaying = true;
        mixUpdateControlStates();
        try {
          Tone.Transport.start('+0.02');
        } catch (err) {
          console.error('[mix] transport start error', err);
          mixState.isPlaying = false;
          mixUpdateControlStates();
          toast('æ’­æ”¾å•Ÿå‹•å¤±æ•—');
          return;
        }
        mixStartTransportMonitor();
      }

      function mixStopPlayback(auto = false) {
        if (!isToneAvailable()) {
          mixState.isPlaying = false;
          mixUpdateControlStates();
          return;
        }
        try {
          Tone.Transport.stop();
          Tone.Transport.cancel();
          mixAudio.scheduleIds.forEach(id => Tone.Transport.clear(id));
          mixAudio.scheduleIds = [];
        } catch (err) { console.warn('[mix] transport stop error', err); }
        mixAudio.players.forEach(player => { try { player.stop(); } catch (e) { } });
        mixStopTransportMonitor();
        if (!mixState.isPlaying) return;
        const elapsed = Tone.now() - mixAudio.startTime;
        const newPos = mixAudio.startPlayhead + Math.max(0, elapsed);
        mixState.isPlaying = false;
        mixSetPlayhead(Math.min(newPos, mixState.contentDuration), { scroll: true, persist: true });
        if (auto) toast('æ’­æ”¾çµæŸ');
        mixUpdateControlStates();
      }

      function mixTogglePlayback() {
        if (mixState.isPlaying) mixStopPlayback(false);
        else mixStartPlayback();
      }

      function mixShowPanel(scrollToPlayhead = true) {
        if (!els.mixPanel) return;
        els.mixPanel.classList.remove('hidden');
        els.mixPanel.setAttribute('aria-hidden', 'false');
        mixState.isOpen = true;
        mixRenderAll();
        if (scrollToPlayhead) mixScrollPlayheadIntoView();
      }

      function mixHidePanel() {
        if (!els.mixPanel) return;
        els.mixPanel.classList.add('hidden');
        els.mixPanel.setAttribute('aria-hidden', 'true');
        mixState.isOpen = false;
      }

      function mixAddClipForSound(sound, opts = {}) {
        if (!sound) return null;
        if (!mixState.initialized) ensureMixPanelReady();
        mixStageHistory();
        const duration = mixRoundSeconds(Math.max(0.5, Number(opts.duration) || mixGetDurationForSound(sound)));
        const start = mixRoundSeconds(Math.max(0, Number.isFinite(opts.start) ? Number(opts.start) : mixState.playhead));
        let track = Number.isInteger(opts.track) ? Number(opts.track) : mixFindAvailableTrack(start, duration);
        if (track < 0 || track >= MIX_TRACK_COUNT) track = mixFindAvailableTrack(start, duration);
        const clip = { id: mixGenerateClipId(), soundId: sound.id, start, duration, track };
        mixState.tracks[track].push(clip);
        mixState.tracks[track].sort((a, b) => a.start - b.start);
        mixRecalculateDuration();
        mixSaveToStorage();
        mixRenderAll();
        mixShowPanel(false);
        mixScrollClipIntoView(clip);
        mixRequestDuration(sound, clip);
        return clip;
      }

      function handleAddSoundToMix(soundId) {
        const sound = state.soundMap.get(soundId) || state.sounds.find(s => s.id === soundId);
        if (!sound) {
          toast('æ‰¾ä¸åˆ°éŸ³æ•ˆ');
          return;
        }
        ensureMixPanelReady();
        const clip = mixAddClipForSound(sound);
        if (clip) toast('å·²åŠ å…¥æ··éŸ³è»Œé“');
      }

      function ensureMixPanelReady() {
        if (mixState.initialized) return;
        mixState.initialized = true;
        mixLoadFromStorage();
        mixRenderAll();
        if (els.mixScrollHost) {
          els.mixScrollHost.addEventListener('scroll', mixUpdateScrollState, { passive: true });
          els.mixScrollHost.addEventListener('wheel', mixOnWheelZoom, { passive: false });
        }
        if (els.mixScrollRange) {
          els.mixScrollRange.addEventListener('input', mixOnScrollRangeInput);
        }
        if (els.mixZoomRange && !els.mixZoomRange.dataset.mixBound) {
          els.mixZoomRange.dataset.mixBound = '1';
          els.mixZoomRange.setAttribute('min', String(MIX_ZOOM_MIN));
          els.mixZoomRange.setAttribute('max', String(MIX_ZOOM_MAX));
          els.mixZoomRange.setAttribute('step', '5');
          els.mixZoomRange.value = String(Math.round(mixState.pxPerSecond));
          els.mixZoomRange.addEventListener('input', (ev) => {
            mixApplyZoom(Number(ev.target.value), { persist: false, maintainCenter: true });
          });
          els.mixZoomRange.addEventListener('change', (ev) => {
            mixApplyZoom(Number(ev.target.value), { persist: true, maintainCenter: true });
          });
        } else if (els.mixZoomRange) {
          els.mixZoomRange.value = String(Math.round(mixState.pxPerSecond));
        }
        if (els.mixTrackLanes) {
          els.mixTrackLanes.addEventListener('click', mixOnLanesClick);
          els.mixTrackLanes.addEventListener('pointerdown', mixOnClipPointerDown);
          // Prevent native context menu and text selection on mobile long-press so pointer drag works
          try {
            els.mixTrackLanes.addEventListener('contextmenu', (e) => { e.preventDefault(); });
            els.mixTrackLanes.addEventListener('selectstart', (e) => { e.preventDefault(); });
          } catch (e) { /* ignore */ }
        }
        if (els.mixPlayPauseBtn) els.mixPlayPauseBtn.addEventListener('click', mixTogglePlayback);
        if (els.mixToStartBtn) els.mixToStartBtn.addEventListener('click', mixJumpToStart);
        if (els.mixToEndBtn) els.mixToEndBtn.addEventListener('click', mixJumpToEnd);
        if (els.mixUndoBtn) els.mixUndoBtn.addEventListener('click', mixUndo);
        if (els.mixRedoBtn) els.mixRedoBtn.addEventListener('click', mixRedo);
        if (els.mixClearBtn) els.mixClearBtn.addEventListener('click', mixOpenConfirmModal);
        if (els.mixCloseBtn) els.mixCloseBtn.addEventListener('click', () => { mixStopPlayback(false); mixHidePanel(); });
        if (els.mixConfirmCancel) els.mixConfirmCancel.addEventListener('click', mixCloseConfirmModal);
        if (els.mixConfirmAccept) els.mixConfirmAccept.addEventListener('click', () => { mixClearAllTracks({ silent: false }); mixCloseConfirmModal(); });
        if (els.mixConfirmModal) {
          els.mixConfirmModal.addEventListener('click', (ev) => {
            if (ev.target === els.mixConfirmModal) mixCloseConfirmModal();
          });
        }
        document.addEventListener('keydown', mixHandleGlobalKeydown);
        if (els.openMixBtn && !els.openMixBtn.dataset.mixBound) {
          els.openMixBtn.dataset.mixBound = '1';
          els.openMixBtn.addEventListener('click', () => {
            ensureMixPanelReady();
            mixShowPanel(true);
          });
        }
        mixUpdateControlStates();
      }

      /**
       * URL åŒæ­¥å·¥å…·ï¼šå°‡ç•¶å‰æœå°‹æ¢ä»¶å°è£ç‚º URLSearchParams
       */
      function buildSearchParams() {
        const { terms, tags } = utils.parseQuery();
        const params = new URLSearchParams(window.location.search);
        if (terms.length) params.set('q', terms.join(' ')); else params.delete('q');
        if (tags.size) params.set('tags', [...tags].join(',')); else params.delete('tags');
        params.delete('sound'); // ä¿®æ”¹æœå°‹æ™‚æ¸…é™¤éŸ³æ•ˆæ·±é€£çµ
        return params;
      }

      /**
       * å°‡ç‹€æ…‹å¯«å› URLã€‚
       * @param {boolean} push è‹¥ç‚º true å‰‡ä½¿ç”¨ history.pushStateï¼Œå¦å‰‡ä½¿ç”¨ replaceState
       */
      function updateURLFromState(push = false) {
        const params = buildSearchParams();
        // ä¿ç•™ list åƒæ•¸ï¼ˆåˆ†äº«æ”¶åˆ°çš„åˆ—è¡¨ï¼‰è‹¥å­˜åœ¨
        const current = new URLSearchParams(location.search);
        if (current.has('list')) params.set('list', current.get('list'));
        // é€™è¡Œæ˜¯æ­£ç¢ºçš„ï¼Œæ˜¯ç‚ºäº†ä¿è­‰åˆ†äº«ç¶²å€çš„é‚è¼¯èƒ½å¤ æ­£ç¢ºé‹ä½œ
        if (current.has('sound')) params.set('sound', current.get('sound'));
        // åŠ ä¸Š page åƒæ•¸ï¼ˆéé¦–é æ‰å¯«å…¥ï¼‰
        if (state.page && state.page !== 'home') params.set('page', state.page); else params.delete('page');
        const qs = params.toString();
        const url = `${location.pathname}${qs ? '?' + qs : ''}`;
        (push ? history.pushState : history.replaceState).call(history, null, '', url);
      }

      /**
       * å¾ç¾æœ‰ URL è®€å–æœå°‹æ¢ä»¶ä¸¦å¥—ç”¨åˆ°ç‹€æ…‹èˆ‡è¼¸å…¥æ¡†
       */
      function applyURLToState() {
        const params = new URLSearchParams(location.search);
        const q = params.get('q') || '';
        const tagsParam = params.get('tags') || '';
        state.queryTags.clear();
        const keys = tagsParam ? tagsParam.split(',').map(k => utils.slug(k)).filter(Boolean) : [];
        for (const k of keys) { state.queryTags.add(k); }
        state.queryText = q;
        // åŒæ­¥è¼¸å…¥æ¡†æ–‡å­—ï¼šå°‡ q èˆ‡ #tagTokens çµ„åˆé¡¯ç¤º
        const tagTokens = keys.map(k => '#' + (state.tags[k]?.name || k));
        els.q.value = [q, ...tagTokens].filter(Boolean).join(' ');

        // åˆ†é ï¼šè®€å– page åƒæ•¸
        const pageParam = params.get('page');
  if (pageParam === 'game' || pageParam === 'about' || pageParam === 'bg' || pageParam === 'awards') state.page = pageParam;
        else state.page = 'home';
        // åˆ†äº«åˆ—è¡¨ï¼šè®€å– list åƒæ•¸ï¼Œé€—è™Ÿåˆ†éš”
        const listParam = params.get('list');
        if (listParam) {
          state.receivedList = listParam.split(',').filter(Boolean);
        } else {
          state.receivedList = [];
        }
      }

      /**
       * è‹¥ URL æœ‰ ?sound=<id>ï¼Œå‰‡èšç„¦ä¸¦é–ƒçˆè©²å¡ç‰‡
       */
      function focusSoundFromURL() {
        const id = new URLSearchParams(location.search).get('sound');
        if (!id) return;
        const card = utils.byId('snd-' + id);
        if (card) {
          card.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // ç§»é™¤èˆŠçš„é«˜äº®
          if (state.highlightedCardId) {
            const prev = utils.byId('snd-' + state.highlightedCardId);
            if (prev) { prev.classList.remove('glow-persistent'); }
          }
          // è¨­å®šæ–°çš„é«˜äº® id
          state.highlightedCardId = id;
          // åŠ å…¥æŒçºŒå¤–å…‰æšˆ
          card.classList.add('glow-persistent');
        }
      }

      // popstate äº‹ä»¶ï¼šè¿”å›/å‰é€²æ™‚è¼‰å…¥ URL æ¢ä»¶
      window.addEventListener('popstate', () => {
        applyURLToState();
        render();
        focusSoundFromURL();
      });

      /**
       * å»ºç«‹åˆ†äº«éŸ³æ•ˆè·Ÿæœå°‹æ¢ä»¶çš„ URLï¼šåŒ…å«ç•¶å‰æœå°‹æ¢ä»¶èˆ‡é–å®šçš„ sound idã€‚
       * @param {string} id éŸ³æª”æª”å
       */
      function buildTotalSoundURL(id) {
        const params = buildSearchParams();
        params.set('sound', id);
        const qs = params.toString();
        return `${location.origin}${location.pathname}${qs ? '?' + qs : ''}`;
      }
      /**
       * å»ºç«‹åƒ…åŒ…å« sound id çš„åˆ†äº«é€£çµï¼ˆä¸æ”œå¸¶æœå°‹æ–‡å­—æˆ–æ¨™ç±¤ï¼‰ã€‚
       * æœƒä½¿ç”¨ç›®å‰æ–‡ä»¶çš„ base URLï¼ˆç§»é™¤ query/hashï¼‰å†åŠ ä¸Š ?sound=<id>
       * @param {string} id éŸ³æ•ˆ id
       */
      function buildSoundURL(id) {
        const href = String(location.href || '');
        // ç§»é™¤ query èˆ‡ hash
        const base = href.replace(/[?#].*$/, '');
        return `${base}${base.includes('?') ? '&' : '?'}sound=${encodeURIComponent(id)}`;
      }

      /**
       * å»ºç«‹åˆ†äº«åˆ—è¡¨çš„ URLï¼šåŠ å…¥ list åƒæ•¸ï¼Œä½¿ç”¨é€—è™Ÿåˆ†éš”çš„ id åˆ—è¡¨ã€‚
       * @param {string[]} ids
       */
      function buildListURL(ids) {
        const params = buildSearchParams();
        if (ids && ids.length) {
          params.set('list', ids.join(','));
        } else {
          params.delete('list');
        }
        // åˆªé™¤å–®ç¨éŸ³æ•ˆåƒæ•¸
        params.delete('sound');
        const qs = params.toString();
        return `${location.origin}${location.pathname}${qs ? '?' + qs : ''}`;
      }

      /**
       * æ ¹æ“š id è‡ªå‹•æ’­æ”¾éŸ³æ•ˆï¼ˆè‹¥å­˜åœ¨ï¼‰ã€‚æœƒä½¿ç”¨ renderSoundCard ä¸­çš„é‚è¼¯å»ºç«‹ Audioã€‚
       * @param {string} id
       */
      function playSoundById(id) {
        const snd = state.sounds.find(s => s.id === id);
        if (!snd) return;
        playSoundObject(snd);
      }


      /**
       * åˆ‡æ›é é¢ï¼šæ ¹æ“š page åç¨±é¡¯ç¤ºä¸åŒå…§å®¹ï¼Œä¸¦æ›´æ–°ç¶²å€åƒæ•¸èˆ‡å°è¦½æ¨£å¼
       * @param {'home'|'game'|'about'} pg
       */
      function showPage(pg) {
        const prevPage = state.page;
        // å»£æ’­ã€Œåˆ‡æ›å‰ã€äº‹ä»¶ï¼Œè®“éœ€è¦åœ¨é é¢è¢«éš±è—å‰åšæ¸…ç†çš„æ¨¡çµ„å…ˆè¡Œè™•ç†ã€‚
        try {
          document.dispatchEvent(
            new CustomEvent(
              'pageChange',
              { detail: { page: pg, prevPage, phase: 'before' } })
          );
        } catch (e) { }
        state.page = pg;
  els.pageHome.classList.add('hidden');
  els.pageGame.classList.add('hidden');
  els.pageAbout.classList.add('hidden');
  if (els.pageawards) els.pageawards.classList.add('hidden');
        if (els.pageBg) els.pageBg.classList.add('hidden');
        if (pg === 'home') els.pageHome.classList.remove('hidden');
        else if (pg === 'game') els.pageGame.classList.remove('hidden');
  else if (pg === 'about') els.pageAbout.classList.remove('hidden');
  else if (pg === 'awards' && els.pageawards) els.pageawards.classList.remove('hidden');
  else if (pg === 'bg' && els.pageBg) els.pageBg.classList.remove('hidden');
        // æ›´æ–°å°è¦½æ¨™ç±¤ active æ¨£å¼
        els.navTabs.forEach(tab => {
          if (tab.getAttribute('data-page') === pg) tab.classList.add('active');
          else tab.classList.remove('active');
        });
        // åˆ‡æ›èƒŒæ™¯æ»¿ç‰ˆæ¨¡å¼èˆ‡æ”¶èµ·æ‰‹æ©Ÿé¸å–®
        document.body.classList.toggle('bg-full', (pg === 'bg' || pg === 'about'));
        document.body.classList.remove('nav-open');
        if (els.navToggle) els.navToggle.setAttribute('aria-expanded', 'false');
        // æ›´æ–° URLï¼šä¿ç•™æœå°‹èˆ‡å…¶ä»–åƒæ•¸
        updateURLFromState(true);
        // å»£æ’­ã€Œåˆ‡æ›å¾Œã€äº‹ä»¶ï¼Œè®“éœ€è¦åœ¨é é¢é¡¯ç¤ºå¾Œåšåˆå§‹åŒ–çš„æ¨¡çµ„å›æ‡‰ã€‚
        try {
          document.dispatchEvent(
            new CustomEvent(
              'pageChange',
              { detail: { page: pg, prevPage, phase: 'after' } }));
        } catch (e) { }
      }

      /**
       * æ¸²æŸ“æ¨™ç±¤ä¸€è¦½ï¼šåˆ—å‡ºæ‰€æœ‰ä½¿ç”¨åˆ°çš„æ¨™ç±¤
       */
      function renderTagList() {
        const container = els.tagList;
        if (!container) return;
        container.innerHTML = '';
        state.usedTagList.forEach(t => {
          const el = dom.el('span', { class: 'tag', style: { background: t.color || '#94a3b8' } }, t.name);
          el.addEventListener('click', () => {
            addTagToQuery(t.key);
          });
          container.appendChild(el);
        });
      }

      /**
       * å˜—è©¦ä½¿ç”¨å‰ªè²¼ç°¿ APIï¼Œè‹¥ä¸æ”¯æ´å‰‡é™éšåˆ°èˆŠæ–¹å¼ã€‚
       * @param {string} text
       */
      function copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          return navigator.clipboard.writeText(text).catch(() => legacyCopy(text));
        }
        return legacyCopy(text);
      }
      function legacyCopy(text) {
        const ta = dom.el('textarea', { style: { position: 'fixed', left: '-9999px', top: '0' } }, text);
        document.body.appendChild(ta);
        ta.select();
        try { document.execCommand('copy'); } catch (e) { }
        ta.remove();
        return Promise.resolve();
      }

      /** Toast æç¤ºé¡¯ç¤ºå°è³‡è¨Š
       * å¯å‚³å…¥é¡¯ç¤ºæ™‚é–“ï¼ˆæ¯«ç§’ï¼‰ï¼›è‹¥ç‚º 0 å‰‡ä¸æœƒè‡ªå‹•éš±è—
       * @param {string} msg
       * @param {number} [duration=2200]
       */
      function toast(msg, duration = 2200) {
        const t = els.toast;
        if (!t) return;
        // æ¸…é™¤èˆŠçš„è¨ˆæ™‚å™¨
        if (state.toastTimer) { clearTimeout(state.toastTimer); state.toastTimer = null; }
        t.textContent = msg;
        t.classList.remove('hidden');
        if (duration > 0) {
          state.toastTimer = setTimeout(() => {
            t.classList.add('hidden');
            state.toastTimer = null;
          }, duration);
        }
      }

      /** æ‰“é–‹éŸ³æ•ˆçš„å³éµ/é•·æŒ‰é¸å–® */
      function openMenuForSound(snd, x, y) {
        const m = els.menu;
        if (!m) return;
        m.innerHTML = '';
        // åˆ†äº«ç¶²å€é …ç›®
        const share = dom.el('div', { class: 'menu-item', role: 'menuitem', tabindex: '0' }, 'åˆ†äº«ç¶²å€');
        share.addEventListener('click', async () => {
          const url = buildSoundURL(snd.id);
          await copyToClipboard(url);
          closeMenu();
          toast('å·²è¤‡è£½åˆ†äº«é€£çµ');
          const card = utils.byId('snd-' + snd.id);
        });
        const addToMix = dom.el('div', { class: 'menu-item', role: 'menuitem', tabindex: '0' }, 'åŠ å…¥è»Œé“');
        addToMix.addEventListener('click', () => {
          closeMenu();
          handleAddSoundToMix(snd.id);
        });
        // ä¸‹è¼‰éŸ³æª”é …ç›®
        const dl = dom.el('div', { class: 'menu-item', role: 'menuitem', tabindex: '0' }, 'ä¸‹è¼‰éŸ³æª”');
        dl.addEventListener('click', () => {
          closeMenu();
          utils.download(snd.src, snd.file);
        });
        m.append(share, addToMix, dl);
        m.classList.remove('hidden');
        // å®šä½é¸å–®ï¼šç¢ºä¿å…ƒç´ æœ‰å°ºå¯¸å¾Œå†è¨ˆç®—
        requestAnimationFrame(() => positionMenu(x, y));
      }

      /** å®šä½é¸å–®åœ¨è¦–çª—å…§ */
      function positionMenu(x, y) {
        const m = els.menu;
        if (!m) return;
        const pad = 6;
        const w = m.offsetWidth || 180;
        const h = m.offsetHeight || 100;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const left = Math.min(Math.max(0, x), vw - w - pad);
        const top = Math.min(Math.max(0, y), vh - h - pad);
        m.style.left = left + 'px';
        m.style.top = top + 'px';
      }

      /** é—œé–‰é¸å–® */
      function closeMenu() {
        const m = els.menu;
        if (!m) return;
        m.classList.add('hidden');
        m.innerHTML = '';
      }
      // é»æ“Šå¤–éƒ¨æˆ–æŒ‰ ESC é—œé–‰é¸å–®
      document.addEventListener('click', (e) => {
        const m = els.menu;
        if (m && !m.classList.contains('hidden') && !m.contains(e.target)) closeMenu();
      });
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeMenu();
      });
      window.addEventListener('resize', closeMenu);

      /** åˆ‡æ›ä¸»é¡Œ */
      function applyTheme(theme) {
        document.documentElement.classList.toggle('light', theme === 'light');
      }
      const savedTheme = localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme:light)').matches ? 'light' : 'dark');
      applyTheme(savedTheme);
      els.themeBtn.addEventListener('click', () => {
        const next = document.documentElement.classList.contains('light') ? 'dark' : 'light';
        if (next == "dark") {
          playSoundById("oNTWqg"); //ç“¦å“ˆéŸ³æ•ˆ é–‹ç‡ˆå•Š
        }
        localStorage.setItem('theme', next);
        applyTheme(next);
      });

      // è¨­å®š Modal è¡Œç‚ºï¼ˆé–‹å•Ÿ / é—œé–‰ / éŸ³é‡ç¶å®šï¼‰
      try {
        if (els.settingsBtn) {
          els.settingsBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (!els.settingsModal) return;
            els.settingsModal.classList.remove('hidden');
            els.settingsModal.setAttribute('aria-hidden', 'false');
            // initialize slider
            if (els.settingsVolume) {
              els.settingsVolume.value = String(Math.round((state.globalVolume || 1) * 100));
            }
            if (els.settingsVolumeValue) {
              els.settingsVolumeValue.textContent = `${Math.round((state.globalVolume || 1) * 100)}%`;
            }
          });
        }
        if (els.settingsClose) {
          els.settingsClose.addEventListener('click', () => {
            if (!els.settingsModal) return;
            els.settingsModal.classList.add('hidden');
            els.settingsModal.setAttribute('aria-hidden', 'true');
          });
        }
        // backdrop click closes
        document.addEventListener('click', (ev) => {
          if (!els.settingsModal) return;
          if (els.settingsModal.classList.contains('hidden')) return;
          if (ev.target === els.settingsModal) {
            els.settingsModal.classList.add('hidden');
            els.settingsModal.setAttribute('aria-hidden', 'true');
          }
        });
        // Escape closes
        document.addEventListener('keydown', (ev) => {
          if (ev.key === 'Escape' && els.settingsModal && !els.settingsModal.classList.contains('hidden')) {
            els.settingsModal.classList.add('hidden');
            els.settingsModal.setAttribute('aria-hidden', 'true');
          }
        });
        // volume slider binding
        if (els.settingsVolume) {
          els.settingsVolume.addEventListener('input', (ev) => {
            const v = Number(els.settingsVolume.value) || 0;
            const norm = Math.max(0, Math.min(100, v)) / 100;
            state.globalVolume = norm;
            try { localStorage.setItem('globalVolume', String(norm)); } catch (e) { }
            if (els.settingsVolumeValue) els.settingsVolumeValue.textContent = `${Math.round(norm * 100)}%`;
            // apply to mix master gain if Tone is started
            try {
              if (mixAudio && mixAudio.masterGain && mixAudio.masterGain.gain) {
                // Tone.Gain.gain is a Signal; set value safely
                try { mixAudio.masterGain.gain.value = norm; } catch (e) {
                  try { mixAudio.masterGain.gain.rampTo(norm, 0.02); } catch (ee) { }
                }
              }
            } catch (e) { }
          });
        }
      } catch (e) { console.warn('[settings] init failed', e); }

      /** æ’­æ”¾å½©è›‹ï¼šç•¶éŸ³æ•ˆæ’­æ”¾æ™‚é¡¯ç¤ºé ­åƒï¼Œæ’­æ”¾çµæŸå¾Œå½ˆè·³é›¢å ´ */
      const activeGroups = new Set();
      function onPlayStart(snd, audio) {
        const streamerTags = snd.tags
          .map(k => state.tags[utils.slug(k)])
          .filter(t => t && t.role === 'streamer' && t.avatar);
        if (streamerTags.length === 0) return;
        const group = dom.el('div', { class: 'group' });
        activeGroups.add(group);
        streamerTags.forEach((t, i) => {
          const avatar = dom.el('div', {
            class: 'avatar pop-in jit',
            style: { animationDelay: `${i * 60}ms` }
          }, [
            dom.el('img', { src: withV(t.avatar), alt: t.name })
          ]);
          group.appendChild(avatar);
        });
        els.stage.appendChild(group);
        audio.__group = group;
      }
      function onPlayEnd(_snd, audio) {
        const group = audio.__group;
        if (!group) return;
        const children = Array.from(group.children);
        children.forEach((av, i) => {
          av.classList.remove('jit');
          setTimeout(() => {
            av.classList.add('hop-out');
            av.addEventListener('animationend', () => {
              av.remove();
              if (group.childElementCount === 0) { group.remove(); activeGroups.delete(group); }
            }, { once: true });
          }, i * 90);
        });
      }

      /** ===== Favorites schema migration: file -> id (v1 -> v2) ===== */
      const LS_FAVORITES = 'favorites';
      const LS_FAVORITES_VERSION = 'favorites_version';        // '2' è¡¨æ–°ç‰ˆï¼ˆidï¼‰
      const LS_FAVORITES_BACKUP = 'favorites_legacy_backup';  // å‚™ä»½èˆŠè³‡æ–™ï¼ˆé™¤éŒ¯ç”¨ï¼‰
      const ID_REGEX = /^[A-Za-z0-9_-]{6}$/;

      /** å°‡å¯èƒ½çš„èˆŠè³‡æ–™å„ç¨®å‹æ…‹ï¼Œç©©å¥è½‰æˆå­—ä¸²é™£åˆ— */
      function parseLegacyFavorites(raw) {
        if (!raw) return [];
        try {
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) return parsed.map(String);
          if (parsed && typeof parsed === 'object') {
            // èˆŠç‰ˆè‹¥æ˜¯ map å½¢å¼ï¼š{ "meme/awooga.mp3": true, "x.ogg": false, ... }
            return Object.keys(parsed).filter(k => !!parsed[k]).map(String);
          }
        } catch (e) {
          // é JSONï¼šæ”¯æ´ç”¨é€—è™Ÿ/ç©ºç™½åˆ†éš”çš„èˆŠæ ¼å¼
          if (typeof raw === 'string') {
            return raw.split(/[,\s]+/).map(s => s.trim()).filter(Boolean);
          }
        }
        return [];
      }

      /** è¦ä¸€åŒ– file keyï¼šå»æ‰æŸ¥è©¢å­—ä¸²ã€å»é ­å°¾æ–œç·šã€ä¿ç•™åŸå¤§å°å¯«ï¼ˆå¦æœ‰å°å¯«å°ç…§è¡¨ï¼‰ */
      function canonFileKey(s) {
        if (!s) return '';
        let k = String(s);
        k = k.split('?')[0];           // å»é™¤ ?v=xxx
        k = k.replace(/^\.?\//, '');    // å»æ‰ ./ æˆ– /
        try { k = decodeURIComponent(k); } catch { }
        return k;
      }

      /** ç”± sounds.json å»ºç«‹å°ç…§è¡¨ï¼šfile/basename/å¤§å°å¯«é¬†å¼› -> id */
      function buildFileMapsFromConfig(soundsJson) {
        const exact = new Map();
        const lower = new Map();
        soundsJson.forEach(s => {
          const file = canonFileKey(s.file);             // ä¾‹å¦‚: "animals/cat.mp3"
          const base = file.split('/').pop();            // ä¾‹å¦‚: "cat.mp3"
          const id = s.id || base;                     // è‹¥ç¼º idï¼Œé€€å›æª”åï¼ˆæ¥µå°‘æ•¸æƒ…æ³ï¼‰
          [
            file,
            base,
            'sounds/' + file,         // æŸäº›èˆŠè³‡æ–™å¯èƒ½å¸¶æˆ–ä¸å¸¶ sounds/
            'sounds/' + base
          ].forEach(k => { exact.set(k, id); lower.set(k.toLowerCase(), id); });
        });
        return { exact, lower };
      }

      /** éœ€è¦é·ç§»å—ï¼Ÿï¼ˆfavorites ä¸æ˜¯ç´” 6 ç¢¼ id æ¸…å–®ï¼Œå°±è¦–ç‚ºéœ€è¦ï¼‰ */
      function favoritesNeedMigration(raw) {
        const list = parseLegacyFavorites(raw);
        if (list.length === 0) return false;
        return !list.every(x => ID_REGEX.test(x));
      }

      /** ä¸»ç¨‹åºï¼šåœ¨æ‹¿åˆ° soundsJsonï¼ˆå« file èˆ‡ idï¼‰å¾Œå‘¼å« */
      function migrateFavoritesFromFilesToIds(soundsJson) {
        try {
          const raw = localStorage.getItem(LS_FAVORITES);
          if (!favoritesNeedMigration(raw)) {
            localStorage.setItem(LS_FAVORITES_VERSION, '2');
            return;
          }
          const legacy = parseLegacyFavorites(raw);
          const { exact, lower } = buildFileMapsFromConfig(soundsJson);

          const out = [];
          const seen = new Set();
          const missing = [];

          legacy.forEach(k => {
            const c = canonFileKey(k);
            const base = c.split('/').pop();
            const candidates = [c, c.replace(/^sounds\//, ''), base, 'sounds/' + c, 'sounds/' + base];
            let id = null;
            for (const cand of candidates) {
              id = exact.get(cand) || lower.get(cand.toLowerCase());
              if (id) break;
            }
            if (!id) { missing.push(k); return; }
            if (!seen.has(id)) { seen.add(id); out.push(id); }
          });

          // å¯«å…¥æ–°ç‰ˆ + å‚™ä»½èˆŠç‰ˆ
          localStorage.setItem(LS_FAVORITES_BACKUP, raw);
          localStorage.setItem(LS_FAVORITES, JSON.stringify(out));
          localStorage.setItem(LS_FAVORITES_VERSION, '2');

          // åŒæ­¥åˆ° runtimeï¼ˆæœ¬æ¬¡è¼‰å…¥ç«‹å³ç”Ÿæ•ˆï¼‰
          state.favorites = out;
          state.favSet = new Set(out);
          // ä½¿ç”¨ä½ çš„ toast
          if (typeof toast === 'function') {
            toast(`å·²å‡ç´šæœ€æ„›æ ¼å¼ï¼Œå…± ${out.length} ç­†${missing.length ? `ï¼›æœªåŒ¹é… ${missing.length} ç­†` : ''}ã€‚`);
          }
          console.info('[favorites migration] done:', { converted: out.length, missing });
        } catch (err) {
          console.warn('[favorites migration] error:', err);
        }
      }

      /** è¼‰å…¥è¨­å®šæª”ï¼šä½¿ç”¨ç‰ˆæœ¬å­—ä¸²èˆ‡ no-store ä»¥é˜²å¿«å–ï¼›ä¸¦æ´—ç‰ŒéŸ³æ•ˆ */
      async function loadConfig() {
        const [tagsJson, soundsJson] = await Promise.all([
          fetch(withV('config/tags.json'), { cache: 'no-store' }).then(r => r.json()),
          fetch(withV('config/sounds.json'), { cache: 'no-store' }).then(r => r.json())
        ]);
        // è®€å–æ¨™ç±¤
        migrateFavoritesFromFilesToIds(soundsJson);
        state.tags = {};
        state.tagList = tagsJson.map(t => ({ key: utils.slug(t.key), name: t.name, color: t.color, role: t.role, avatar: t.avatar }));
        for (const t of state.tagList) { state.tags[utils.slug(t.key)] = t; }
        // è®€å–éŸ³æ•ˆã€‚è‹¥é…ç½®æª”ä¸­åŒ…å« idï¼Œå‰‡ä½¿ç”¨è©² idï¼›å¦å‰‡ fallback åˆ°æª”åã€‚åŠ ä¸Šç‰ˆæœ¬å­—ä¸²ã€‚
        state.sounds = soundsJson.map(s => {
          const id = s.id || s.file.replace(/^.*[\\\/]/, '');
          return { id, src: withV(`sounds/${s.file}`), file: s.file, title: s.title, tags: s.tags.slice() };
        });
        state.soundMap = new Map(state.sounds.map(s => [s.id, s]));
        // ä¿å­˜ä¸€ä»½åŸå§‹è¼‰å…¥é †åºçš„æ·ºæ‹·è²ï¼Œä¾›ã€Œé è¨­é †åºã€é‚„åŸä½¿ç”¨
        state.defaultSoundsSnapshot = state.sounds.map(s => ({ ...s }));
        // å˜—è©¦è¼‰å…¥ç¥¨é¸ CSVï¼Œå°‡å‰ N åä¾ CSV æ’åºç§»åˆ°æœ€å‰é¢ï¼ˆè‹¥ CSV å¯å­˜å–ä¸”å« id æ¬„ï¼‰
        try {
          const top_rank_select = 30;
          const csvUrl = withV('misc/ç¬¬ä¸€å±†éŸ³æ•ˆæ¿ç¥¨é¸çµæœ.csv');
          let csvText = '';
          try {
            const resp = await fetch(csvUrl, { cache: 'no-store' });
            if (resp.ok) csvText = await resp.text();
            else console.warn('[csv load] resp not ok', resp.status, csvUrl);
          } catch (e) {
            console.warn('[csv load] failed to fetch', csvUrl, e);
          }
          if (csvText) {
            // åŸºæœ¬ CSV è§£æï¼šæ”¯æ´é€—è™Ÿåˆ†éš”ï¼Œä¸¦å˜—è©¦æ‰¾å‡º id æ¬„ä½ï¼ˆå¤§å°å¯«ä¸æ•æ„Ÿï¼‰ã€‚è‹¥æ‰¾ä¸åˆ°å‰‡ä½¿ç”¨ç¬¬ä¸€æ¬„ã€‚
            const lines = csvText.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
            if (lines.length > 0) {
              const headerParts = lines[0].split(',').map(h => h.replace(/^\s+|\s+$/g, ''));
              // å„ªå…ˆä¾ header é—œéµå­—å°‹æ‰¾ id æ¬„ä½ï¼ˆåŒ…å«ä¸­æ–‡ 'ç¶²å€'ï¼‰
              const idHeaderRegex = /(id|url|link|ç¶²å€|code)/i;
              let idIndex = headerParts.findIndex(h => idHeaderRegex.test(h));
              // è‹¥ header ä¸­æ‰¾ä¸åˆ°ï¼Œå˜—è©¦ä»¥å…§å®¹æ¡æ¨£ä¾†æ‰¾å‡ºæœ€å¯èƒ½çš„ id æ¬„ï¼ˆçŸ­çš„è‹±æ•¸å­—ä¸²ï¼‰
              if (idIndex === -1) {
                const colCounts = new Map();
                const idLike = /^[A-Za-z0-9_-]{4,20}$/; // å‡è¨­ vote id é¡ä¼¼çŸ­ç¢¼
                for (let i = 1; i < Math.min(lines.length, 30); i++) {
                  const parts = lines[i].split(',');
                  for (let c = 0; c < parts.length; c++) {
                    const val = parts[c] ? parts[c].trim().replace(/^"|"$/g, '') : '';
                    if (idLike.test(val)) colCounts.set(c, (colCounts.get(c) || 0) + 1);
                  }
                }
                // é¸å–å‡ºç¾æ¬¡æ•¸æœ€å¤šä¸”è‡³å°‘ä¸€æ¬¡çš„æ¬„ä½
                let best = -1, bestCount = 0;
                for (const [c, cnt] of colCounts.entries()) {
                  if (cnt > bestCount) { best = c; bestCount = cnt; }
                }
                if (best !== -1) idIndex = best;
              }
              if (idIndex === -1) idIndex = 0;
              const topIds = [];
              for (let i = 1; i < lines.length && topIds.length < top_rank_select; i++) {
                const row = lines[i];
                // åˆ†å‰²æ™‚ç°¡å–®è™•ç†å¯èƒ½çš„å¼•è™Ÿï¼›é€™è£¡ä¸åšå®Œæ•´ CSV è¦æ ¼è§£æä»¥ç¶­æŒè¼•é‡
                const parts = row.split(',');
                let v = parts[idIndex] ? parts[idIndex].trim() : '';
                if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1, -1);
                v = v.trim();
                if (v) topIds.push(v);
              }
              if (topIds.length > 0) {
                // å»ºç«‹ä¸€å€‹æ›´å¯¬é¬†çš„åŒ¹é…ï¼šnormalize idï¼ˆå»ç©ºç™½ã€å°å¯«ã€å»å‰¯æª”åï¼‰ä»¥æé«˜å‘½ä¸­ç‡
                const normalize = s => String(s || '').trim().toLowerCase().replace(/\.(mp3|wav|ogg|m4a)$/i, '');
                const normMap = new Map();
                for (const s of state.sounds) {
                  normMap.set(normalize(s.id), s);
                  if (s.file) normMap.set(normalize(s.file), s);
                }
                // ä¾ç…§ CSV çš„é †åºæŠŠå­˜åœ¨çš„éŸ³æ•ˆç§»åˆ°å‰é¢
                const seen = new Set();
                const ordered = [];
                const matchedList = [];
                for (const rawId of topIds) {
                  // å…ˆå˜—è©¦ç›´æ¥ match idï¼Œå¦å‰‡ç”¨ normalize map
                  let s = state.soundMap.get(rawId);
                  if (!s) s = normMap.get(normalize(rawId));
                  if (s && !seen.has(s.id)) { ordered.push(s); seen.add(s.id); matchedList.push(s); }
                }
                for (const s of state.sounds) {
                  if (!seen.has(s.id)) ordered.push(s);
                }
                // æ›´æ–°é †åºèˆ‡ç´¢å¼•ï¼›è¼¸å‡º debug æ—¥èªŒä¾¿æ–¼ç¢ºèªåŒ¹é…æƒ…å½¢
                const matchedCount = matchedList.length;
                state.sounds = ordered;
                state.soundMap = new Map(state.sounds.map(s => [s.id, s]));
                state.defaultSoundsSnapshot = state.sounds.map(s => ({ ...s }));
                console.info('[csv reorder] applied ordering from', csvUrl, 'csvIds=', topIds.length, 'matched=', matchedCount);
                console.debug('[csv reorder] csv topIds sample:', topIds.slice(0, top_rank_select));
                if (matchedCount === 0) console.warn('[csv reorder] no ids matched; check csv id column vs sounds.json ids');
                // ä¿å­˜ç¥¨é¸çµæœä¾›é é¢ä½¿ç”¨
                state.voteResults = {
                  topIds,
                  matchedList,
                  top10: matchedList.slice(0, 10),
                  next20: matchedList.slice(10, 30)
                };
                try { if (els.awardsBanner) els.awardsBanner.src = withV('misc/ç¬¬ä¸€å±†è²“ä¸‹å».png'); } catch (e) {}
              }
            }
          }
        } catch (e) {
          console.warn('[csv reorder] unexpected error', e);
        }
        // è¨ˆç®—å“ªäº›æ¨™ç±¤è¢«ä½¿ç”¨åˆ°ï¼Œä»¥ä¾›æ¨™ç±¤ä¸€è¦½
        const usedKeys = new Set();
        state.sounds.forEach(snd => snd.tags.forEach(t => usedKeys.add(utils.slug(t))));
        state.usedTagList = state.tagList.filter(t => usedKeys.has(t.key));
      }

      /** æ¸²æŸ“ä»‹é¢ï¼šä¾æ“šæœå°‹æ¢ä»¶ç¯©é¸éŸ³æ•ˆï¼Œå€åˆ†æœ€æ„›èˆ‡å…¶ä»– */
      function render() {
        const { terms, tags } = utils.parseQuery();
        // ä¾æœå°‹æ¢ä»¶éæ¿¾æ‰€æœ‰éŸ³æ•ˆ
        const filtered = state.sounds.filter(s => utils.match(s, terms, tags));
        // æ”¶åˆ°çš„åˆ—è¡¨ï¼šè½‰æˆéŸ³æ•ˆç‰©ä»¶ä¸¦éæ¿¾ä¸å­˜åœ¨è€…
        const received = state.receivedList.map(id => state.sounds.find(s => s.id === id)).filter(Boolean);
        // æœ€æ„›èˆ‡æ”¶åˆ°çš„åˆ—è¡¨æ‡‰ç”¨æœå°‹æ¢ä»¶
        const idToSound = new Map(state.sounds.map(s => [s.id, s]));
        const allowed = new Set(filtered.map(s => s.id));
        const fav = state.favorites.map(id => idToSound.get(id)).filter(s => s && allowed.has(s.id));
        const rec = received.filter(s => filtered.includes(s) && !state.favSet.has(s.id));
        // å…¶é¤˜éŸ³æ•ˆï¼šä¸åœ¨æœ€æ„›ä¹Ÿä¸åœ¨æ”¶åˆ°çš„åˆ—è¡¨
        const rest = filtered.filter(s => !state.favSet.has(s.id) && !rec.includes(s));
        if (!state.isSorting) { renderGrid(els.favGrid, fav, { inFav: true }); }
        renderGrid(els.receivedGrid, rec);
        renderGrid(els.grid, rest);
        els.favEmpty.classList.toggle('hidden', fav.length > 0);
        els.empty.classList.toggle('hidden', filtered.length > 0);
        // é¡¯ç¤ºæˆ–éš±è—æ”¶åˆ°çš„åˆ—è¡¨å€å¡Š
        if (rec.length > 0) {
          if (els.receivedSection) { els.receivedSection.classList.remove('hidden'); }
        } else {
          if (els.receivedSection) { els.receivedSection.classList.add('hidden'); }
        }
        renderActiveChips();
      }

      // æ¸²æŸ“ç¥¨é¸é é¢ï¼ˆé‡è¤‡ä½¿ç”¨ renderGrid / renderSoundCardï¼‰
      function renderawardsPage() {
        try {
          if (!state.voteResults) {
            if (els.awardsTop10) els.awardsTop10.innerHTML = '';
            if (els.awardsNext20) els.awardsNext20.innerHTML = '';
            return;
          }
          if (els.awardsTop10) renderGrid(els.awardsTop10, state.voteResults.top10 || []);
          if (els.awardsNext20) renderGrid(els.awardsNext20, state.voteResults.next20 || []);
        } catch (e) { console.warn('[renderawardsPage] error', e); }
      }
      /** æ¸²æŸ“å–®ä¸€å€å¡Šçš„éŸ³æ•ˆåˆ—è¡¨ */
      function renderGrid(container, list, opts = { inFav: false }) {
        container.innerHTML = '';
        for (const s of list) { container.appendChild(renderSoundCard(s, opts)); }
      }
      /** å»ºç«‹éŸ³æ•ˆå¡ç‰‡å…ƒç´  */
      function renderSoundCard(snd, opts = { inFav: false }) {
        const heartDisabled = !!(state.isSorting && opts.inFav);
        const heartAttrs = {
          class: 'heart',
          'aria-pressed': String(utils.inFav(snd.id)),
          'aria-label': 'åŠ å…¥/ç§»é™¤æœ€æ„›'
        };
        if (heartDisabled) {
          heartAttrs['disabled'] = 'true';
          heartAttrs['aria-disabled'] = 'true';
          heartAttrs['title'] = 'æ­£åœ¨ç·¨è¼¯æœ€æ„›æ’åºï¼Œç„¡æ³•è®Šæ›´æœ€æ„›';
        } else {
          heartAttrs['onclick'] = (e) => { e.stopPropagation(); toggleFavorite(snd.id, heartBtn); };
        }
        const heartBtn = dom.el('button', heartAttrs, dom.svgHeart());
        const tagWrap = dom.el('div', { class: 'tags' });
        for (const t of snd.tags) {
          const tagKey = utils.slug(t);
          const tagDef = state.tags[tagKey];
          const color = tagDef?.color || '#94a3b8';
          const el = dom.el('span', { class: 'tag', style: { background: color } }, t);
          el.addEventListener('click', (e) => {
            e.stopPropagation();
            addTagToQuery(tagKey);
          });
          tagWrap.appendChild(el);
        }
        const card = dom.el('div', { id: 'snd-' + snd.id, 'data-id': snd.id, class: 'sound', role: 'button', tabindex: '0', 'aria-label': `æ’­æ”¾éŸ³æ•ˆï¼š${snd.title}` }, [
          dom.el('div', { class: 'sound-top' }, [
            dom.el('div', { class: 'title', title: snd.title }, snd.title),
            heartBtn
          ]),
          tagWrap
        ]);
        // æ’­æ”¾åŠŸèƒ½
        const play = async () => {
          try { playSoundObject(snd); } catch (e) { console.error(e); }
        };
        if (!(state.isSorting && opts.inFav)) {
          card.addEventListener('click', play);
        }
        if (!(state.isSorting && opts.inFav)) {
          card.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); play(); } });
        }
        // å³éµé–‹é¸å–®
        if (!(state.isSorting && opts.inFav)) card.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          closeMenu();
          openMenuForSound(snd, e.clientX, e.clientY);
        });
        // è¡Œå‹•é•·æŒ‰é–‹é¸å–®
        const startHold = (e) => {
          clearTimeout(state.contextTimer);
          const { clientX, clientY } = e;
          state.contextTimer = setTimeout(() => {
            closeMenu();
            openMenuForSound(snd, clientX || window.innerWidth / 2, clientY || window.innerHeight / 2);
          }, 650);
        };
        const endHold = () => { clearTimeout(state.contextTimer); };
        if (!(state.isSorting && opts.inFav)) card.addEventListener('pointerdown', startHold);
        if (!(state.isSorting && opts.inFav)) card.addEventListener('pointerup', endHold);
        if (!(state.isSorting && opts.inFav)) card.addEventListener('pointerleave', endHold);
        card.addEventListener('pointercancel', endHold);
        return card;
      }

      /** åˆ‡æ›æœ€æ„›ä¸¦é‡æ–°æ¸²æŸ“ */
      function toggleFavorite(id, btn) {
        // åœ¨æœ€æ„›æ’åºï¼ˆç·¨è¼¯ï¼‰æ¨¡å¼ä¸­ç¦æ­¢æ–°å¢æˆ–ç§»é™¤æœ€æ„›ï¼Œå¢åŠ robustæ€§
        if (state.isSorting) {
          if (typeof toast === 'function') toast('æ­£åœ¨ç·¨è¼¯æœ€æ„›æ’åºï¼Œç„¡æ³•è®Šæ›´æœ€æ„›');
          return;
        }
        if (state.favSet.has(id)) {
          state.favorites = state.favorites.filter(x => x !== id);
        } else {
          state.favorites.push(id);
        }
        state.favSet = new Set(state.favorites);
        utils.saveFav();
        if (btn) btn.setAttribute('aria-pressed', String(state.favSet.has(id)));
        render();
      }

      /** æ¸²æŸ“æœå°‹åˆ—ä¸Šçš„å·²é¸æ¨™ç±¤ chips */
      function renderActiveChips() {
        els.activeChips.innerHTML = '';
        for (const key of state.queryTags) {
          const tag = state.tags[key];
          const color = tag?.color || '#94a3b8';
          const chip = dom.el('span', { class: 'chip', style: { background: color }, onclick: () => { state.queryTags.delete(key); render(); updateURLFromState(true); } }, [
            `#${tag?.name || key}`,
            dom.el('button', { title: 'ç§»é™¤', onclick: () => { state.queryTags.delete(key); render(); updateURLFromState(true); } }, 'Ã—')
          ],
          );
          els.activeChips.appendChild(chip);
        }
      }

      /** é»æ¨™ç±¤åŠ å…¥æœå°‹ï¼špushStateï¼Œä¸¦æ¸…é™¤å»ºè­° */
      function addTagToQuery(tagKey) {
        state.queryTags.add(tagKey);
        render();
        updateURLFromState(true);
      }

      /** åˆå§‹åŒ–äº‹ä»¶ç¶å®š */
      function initEvents() {
        // æœå°‹æ¡†è¼¸å…¥ï¼ˆä½¿ç”¨ debounce é™ä½ render é »ç‡ï¼‰
        const handleSearchInput = () => {
          state.queryText = els.q.value;
          const val = els.q.value;
          const last = val.split(/\s+/).pop() || '';
          const needle = last.startsWith('#') ? last.slice(1).toLowerCase() : val.trim().toLowerCase();
          const list = needle
            ? state.tagList.filter(t => t.name.toLowerCase().includes(needle) || t.key.toLowerCase().includes(needle))
            : state.tagList.slice(0, 8);
          render();
          updateURLFromState(false);
        };
        els.q.addEventListener('input', utils.debounce(handleSearchInput, 180));

        // æ¸…é™¤æœå°‹
        els.clearBtn.addEventListener('click', () => {
          els.q.value = '';
          state.queryText = '';
          state.queryTags.clear();
          render();
          updateURLFromState(true);
        });

        // å°è¦½åˆ‡æ›
        els.navTabs.forEach(tab => {
          tab.addEventListener('click', () => {
            const pg = tab.getAttribute('data-page');
            showPage(pg || 'home');
          });
        });
        // æ‰‹æ©Ÿé¸å–®é–‹é—œ
        if (els.navToggle) {
          els.navToggle.addEventListener('click', () => {
            const open = !document.body.classList.contains('nav-open');
            document.body.classList.toggle('nav-open', open);
            els.navToggle.setAttribute('aria-expanded', String(open));
          });
        }

        // é»æ“Šé é¢å…¶ä»–åœ°æ–¹é—œé–‰æ‰‹æ©Ÿé¸å–®
        document.addEventListener('click', (e) => {
          if (document.body.classList.contains('nav-open')) {
            const headerEl = document.querySelector('header');
            if (headerEl && !headerEl.contains(e.target)) {
              document.body.classList.remove('nav-open');
              if (els.navToggle) els.navToggle.setAttribute('aria-expanded', 'false');
            }
          }
        });

        // é»æ“Šå°è¦½å¾Œåœ¨å°è¢å¹•è‡ªå‹•æ”¶åˆ
        els.navTabs.forEach(t => t.addEventListener('click', () => {
          document.body.classList.remove('nav-open');
          if (els.navToggle) els.navToggle.setAttribute('aria-expanded', 'false');
        }));

        // æ´—ç‰ŒæŒ‰éˆ•
        if (els.shuffleBtn) {
          els.shuffleBtn.addEventListener('click', () => {
            // åªæ´—ç‰Œã€Œéæœ€æ„›ã€éŸ³æ•ˆï¼Œä¸å½±éŸ¿æœ€æ„›å€çš„æ’åˆ—
            const nf = [];
            const idxs = [];
            state.sounds.forEach((s, i) => {
              if (!state.favSet.has(s.id)) { nf.push(s); idxs.push(i); }
            });
            shuffleInPlace(nf);
            idxs.forEach((i, k) => { state.sounds[i] = nf[k]; });
            render();
          });
        }
        // é è¨­é †åºæŒ‰éˆ•ï¼šå°‡éæœ€æ„›å€å¡Šæ¢å¾©ç‚ºè¼‰å…¥æ™‚çš„é †åº
        if (els.resetOrderBtn) {
          els.resetOrderBtn.addEventListener('click', () => {
            if (!state.defaultSoundsSnapshot || !state.defaultSoundsSnapshot.length) return;
            // æˆ‘å€‘åªæ¢å¾©éæœ€æ„›ï¼ˆrestï¼‰å€æ®µçš„é †åºï¼ŒåŒ shuffleBtn çš„è¡Œç‚ºç›¸å°æ‡‰
            const snapshot = state.defaultSoundsSnapshot;
            // å»ºç«‹ id->index map ä»¥ä¾¿ä¾ snapshot æ’åºç¾æœ‰ state.sounds
            const idIndex = new Map(snapshot.map((s, i) => [s.id, i]));
            state.sounds.sort((a, b) => {
              const ia = idIndex.has(a.id) ? idIndex.get(a.id) : Number.MAX_SAFE_INTEGER;
              const ib = idIndex.has(b.id) ? idIndex.get(b.id) : Number.MAX_SAFE_INTEGER;
              return ia - ib;
            });
            render();
          });
        }
        // åˆ†äº«æœ€æ„›åˆ—è¡¨

        // æ‰‹å‹•æ’åºï¼ˆæª¢æŸ¥é»Aï¼‰ï¼šå•Ÿç”¨/åœç”¨ SortableJS åƒ…é‡å°æœ€æ„›æ¸…å–®
        if (els.sortFavBtn && els.doneSortBtn) {
          els.sortFavBtn.addEventListener('click', () => {
            state.isSorting = true;
            document.body.classList.add('sorting');
            els.sortFavBtn.classList.add('hidden');
            els.doneSortBtn.classList.remove('hidden');
            // é‡æ–°æ¸²æŸ“æœ€æ„›å€å¡Šï¼Œè®“å¡ç‰‡åœ¨æ’åºæ¨¡å¼ä¸‹ä¸ç¶å®šæ’­æ”¾/é¸å–®äº‹ä»¶
            const { terms, tags } = utils.parseQuery();
            const idToSound = new Map(state.sounds.map(s => [s.id, s]));
            const allowed = new Set(state.sounds.filter(s => utils.match(s, terms, tags)).map(s => s.id));
            const fav = state.favorites.map(id => idToSound.get(id)).filter(s => s && allowed.has(s.id));
            renderGrid(els.favGrid, fav, { inFav: true });
            // å•Ÿç”¨ SortableJS
            if (typeof Sortable !== 'undefined') {
              state.sortable = Sortable.create(els.favGrid, {
                dataIdAttr: 'data-id',
                animation: 150,
                delay: 150,
                delayOnTouchOnly: true,
                ghostClass: 'drag-ghost',
                chosenClass: 'drag-chosen',
                dragClass: 'dragging',
                // å…è¨±é»æ“Š â¤ï¸ æŒ‰éˆ•ï¼ˆä¸è§¸ç™¼æ‹–æ›³ï¼‰
                filter: '.heart',
                preventOnFilter: false
              });
            } else {
              console.warn('SortableJS æœªè¼‰å…¥');
            }
          });
          els.doneSortBtn.addEventListener('click', () => {
            // è®€å–ç›®å‰ DOM ä¸­çš„æœ€æ„›é †åº
            const orderedIds = Array.from(els.favGrid.children)
              .map(el => el.getAttribute('data-id'))
              .filter(Boolean);
            if (orderedIds.length) {
              const rest = state.favorites.filter(id => !orderedIds.includes(id));
              state.favorites = orderedIds.concat(rest);
              state.favSet = new Set(state.favorites);
              utils.saveFav();
              if (typeof toast === 'function') toast('å·²å„²å­˜æœ€æ„›æ’åº');
            }
            if (state.sortable) { state.sortable.destroy(); state.sortable = null; }
            state.isSorting = false;
            document.body.classList.remove('sorting');
            els.doneSortBtn.classList.add('hidden');
            els.sortFavBtn.classList.remove('hidden');
            render();
          });
        }
        if (els.shareFavBtn) {
          els.shareFavBtn.addEventListener('click', async () => {
            const ids = [...state.favorites];
            if (ids.length === 0) { toast('æ²’æœ‰æœ€æ„›å¯åˆ†äº«'); return; }
            const url = buildListURL(ids);
            await copyToClipboard(url);
            toast('å·²è¤‡è£½åˆ†äº«æœ€æ„›åˆ—è¡¨é€£çµ');
          });
        }
      }

      // å…¥å£ï¼šè¼‰å…¥è¨­å®šå¾Œåˆå§‹åŒ–ç‹€æ…‹ã€æ¸²æŸ“ä¸¦å¥—ç”¨ URL æŸ¥è©¢
      loadConfig().then(() => {
        applyURLToState();
        renderTagList();
        ensureMixPanelReady();
        showPage(state.page);
        render();
        focusSoundFromURL();
        initEvents();
        // é»æ“Šæ¨™é¡Œæ™‚å›åˆ°ä¸»é ä¸¦æ¸…é™¤æœå°‹ï¼ˆé˜»æ­¢é è¨­çš„å…¨é å°å‘ï¼‰ï¼Œç„¶å¾Œé‡æ–°æ¸²æŸ“èˆ‡æ›´æ–° URL
        try {
          const titleLink = document.querySelector('header h1');
          if (titleLink) {
            titleLink.addEventListener('click', (e) => {
              // å¦‚æœä½¿ç”¨è€…ä½¿ç”¨ Ctrl/Cmd + click æˆ– æƒ³è¦åœ¨æ–°åˆ†é é–‹å•Ÿï¼Œä¿ç•™åŸè¡Œç‚º
              if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;
              // è‹¥å·²åœ¨ä¸»é ï¼Œå‰‡å¼·åˆ¶é‡æ–°æ•´ç†é é¢
              if (state.page === 'home') {
                // å…è¨±ç€è¦½å™¨åšå®Œæ•´ reload
                return location.reload();
              }
              e.preventDefault();
              // æ¸…é™¤æœå°‹ç‹€æ…‹ä¸¦å›é¦–é 
              state.queryText = '';
              state.queryTags.clear();
              if (els.q) els.q.value = '';
              showPage('home');
              render();
              updateURLFromState(true);
              // å¹³æ»‘æ»¾å›é ‚éƒ¨
              try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch (e) { }
            });
          }
        } catch (e) {/* ignore */ }
      }).catch(err => {
        console.error(err);
        els.grid.innerHTML = '<div class="empty">è¼‰å…¥è¨­å®šæª”å¤±æ•—ï¼Œè«‹ç¢ºèª <code>config/</code> è·¯å¾‘æ˜¯å¦æ­£ç¢ºã€‚</div>';
      });

      // ================= Concentration Game (é…å°è¨˜æ†¶å°éŠæˆ²) =================
      function setupConcentrationGame() {
        const gameEl = document.getElementById('concentration-game');
        const boardEl = document.getElementById('cg-board');
        const timerEl = document.getElementById('cg-timer');
        const accEl = document.getElementById('cg-accuracy');
        const resultEl = document.getElementById('cg-result');
        const restartBtn = document.getElementById('cg-restart');
        if (!gameEl) return;

        // æ³¨æ„ï¼šä¸è¦åœ¨æ­¤è™•é‡æ–°å®£å‘Š cgCleanup â€”â€” è«‹ä½¿ç”¨å¤–å±¤ä½œç”¨åŸŸçš„ cgCleanupï¼Œ
        // ä»¥ä¾¿åœ¨åˆ‡æ›é é¢æ™‚ï¼ˆç”± showPage å‘¼å«ï¼‰èƒ½æ­£ç¢ºåŸ·è¡Œæ¸…ç†å·¥ä½œã€‚

        // --- éŠæˆ²ç‹€æ…‹ ---
        let cards = [];
        let first = null, second = null;
        // scoring: correct = æ­£ç¢ºæ•¸ (æ¯é…å° +2), wrong = éŒ¯è§£æ•¸ (å¯ +0/+1/+2)
        let correct = 0, wrong = 0;
        // matchedPairs counts how many pairs have been solved (0..8)
        let matchedPairs = 0, tries = 0;
        let timer = 0, timerId = null, running = false;
        let allowClick = true;
        let pairs = [];
        // pending pair / timeout ç”¨æ–¼å»¶é²æª¢æŸ¥é…å°ï¼›è‹¥ä½¿ç”¨è€…åœ¨ç­‰å¾…æœŸé–“é»æ“Šå…¶ä»–å¡ï¼Œæœƒç«‹åˆ»çµç®—é€™å°ã€‚
        let pendingTimeout = null;
        let pendingPair = null; // {f, s}
        let timerStarted = false; // only start timer on first card flip

        /**
         * å¾ç¯©é¸éçš„æœ‰æ•ˆéŸ³æ•ˆä¸­é¸å‡ºæœ€å¤š 8 ç­†ä½œç‚ºé…å°ä¾†æºã€‚
         * @param {Array<{tags: string[]}>} validSounds - å·²éæ¿¾ã€å¯ç”¨æ–¼éŠæˆ²çš„éŸ³æ•ˆé™£åˆ—
         * @returns {Array<Object>} chosen - å›å‚³æœ€å¤š 8 ç­†é¸ä¸­çš„éŸ³æ•ˆç‰©ä»¶
         */
        function selectSounds(validSounds) {
          let chosen = [];
          let r1 = 0, wh = 0, mtk = 0, bzh = 0, kit = 0, bros4 = 0, others = 0;

          for (const snd of validSounds) {
            const tags = Array.isArray(snd.tags) ? snd.tags : [];

            if (r1 < 2 && tags.includes('é˜¿è¬')) {
              r1++; chosen.push(snd);
            } else if (wh < 1 && tags.includes('ç“¦å“ˆ')) {
              wh++; chosen.push(snd);
            } else if (mtk < 1 && tags.includes('Matsuko')) {
              mtk++; chosen.push(snd);
            } else if (bzh < 1 && tags.includes('è±¹å­é ­')) {
              bzh++; chosen.push(snd);
            } else if (kit < 1 && tags.includes('è²“ä¸‹å»')) {
              kit++; chosen.push(snd);
            } else if (bros4 < 1 && (tags.includes('è²“ä¸‹å»') || tags.includes('è±¹å­é ­') || tags.includes('Matsuko') || tags.includes('è±¹å­é ­') || tags.includes('ç“¦å“ˆ'))) {
              bros4++; chosen.push(snd);
            } else {
              const isKnown =
                tags.includes('é˜¿è¬') ||
                tags.includes('ç“¦å“ˆ') ||
                tags.includes('è±¹å­é ­') ||
                tags.includes('è²“ä¸‹å»') ||
                tags.includes('Matsuko');

              if (!isKnown && others < 2) {
                others++; chosen.push(snd);
              }
            }

            if (chosen.length >= 8) break; // ä¿®æ­£é‡é»ï¼šæ»¿ 8 ç­†æ™‚åœæ­¢é¸å–
          }

          // ä¿éšªåˆ‡åˆ° 8 ç­†
          return chosen.slice(0, 8);
        }



        // --- è³‡æ–™ç¯©é¸ ---
        function pickPairs() {
          // è¼”åŠ©ï¼šå¾ tagList æ“·å–æ‰€æœ‰ streamer çš„ keyï¼ˆä¸¦åš slug åŒ–ï¼‰ä»¥ä¾›å¾ŒçºŒæ¯”å°
          const streamerKeys = state.tagList
            .filter(t => t.role === 'streamer')
            .map(t => utils.slug(t.key));

          const isStreamer = t => streamerKeys.includes(t);
          // æœ‰æ•ˆéŸ³æ•ˆç¯„åœï¼šæ¯å€‹éŸ³æª”å¿…é ˆæ°å¥½åŒ…å«ä¸€å€‹ streamer æ¨™ç±¤ï¼Œä¸”ä¸åŒ…å« 'é«’è©±' æ¨™ç±¤
          let validSounds = state.sounds.filter(s => {
            const st = s.tags.filter(isStreamer);
            if (st.length !== 1) return false;
            if (s.tags.includes('é«’è©±') || s.tags.includes('SUS')) return false;
            return true;
          });

          validSounds = shuffleInPlace(validSounds);
          let chosen = selectSounds(validSounds);
          chosen = shuffleInPlace(chosen);
          // æœ€å¾Œç¢ºä¿ä¸è¶…é 8 ç­†
          chosen.splice(8);

          // æ˜ å°„åˆ°é…å°ç”¨ç‰©ä»¶ï¼ˆåŒ…å« id, audio, avatar, streamerName, title ç­‰æ¬„ä½ï¼‰
          return chosen.map(s => {
            const streamerTag = s.tags.find(isStreamer);
            const tagObj = state.tags[utils.slug(streamerTag)];
            return {
              id: s.id,
              audio: s.src,
              streamer: streamerTag,
              avatar: tagObj?.avatar || '',
              streamerName: tagObj?.name || streamerTag,
              title: s.title
            };
          });
        }

        // --- éŠæˆ²åˆå§‹åŒ– ---
        function startGame() {
          pairs = pickPairs();
          // å¦‚æœæ‰¾ä¸åˆ°è¶³å¤ çš„é…å°éŸ³æ•ˆï¼Œé¡¯ç¤ºè¨Šæ¯ä¸¦ä¸­æ­¢éŠæˆ²å•Ÿå‹•
          if (!pairs || pairs.length === 0) {
            resultEl.innerHTML = `<h3>ç„¡æ³•é–‹å§‹éŠæˆ²</h3><p style="color:var(--muted)">ç›®å‰æ²’æœ‰è¶³å¤ çš„éŸ³æ•ˆå¯ä¾›é…å°ï¼ˆéœ€è‡³å°‘ 1 çµ„ï¼‰ã€‚è«‹å›åˆ°ä¸»é æˆ–ç¨å¾Œå†è©¦ã€‚</p>`;
            resultEl.classList.remove('hidden');
            running = false;
            state.cgRunning = false;
            return;
          }
          cards = [];
          // æ¸…é™¤ä»»ä½•å…ˆå‰æ®˜ç•™çš„ pending timeout/pairï¼Œé¿å…åœ¨é‡æ–°é–‹å§‹éŠæˆ²æ™‚è§¸ç™¼èˆŠçš„ callback
          try { if (pendingTimeout) { clearTimeout(pendingTimeout); pendingTimeout = null; pendingPair = null; } } catch (e) { }
          pairs.forEach((p, i) => {
            // ç‚ºæ¯å€‹é…å°å»ºç«‹å…©å¼µç›¸åŒçš„å¡ç‰‡ï¼ˆå…©å¼µå¡ç‰‡éƒ½æœƒé¡¯ç¤º avatar ä¸¦æ’­æ”¾ç›¸åŒéŸ³æª”ï¼‰
            cards.push({ type: 'card', pairId: p.id, id: `${p.id}-0`, audio: p.audio, avatar: p.avatar, streamer: p.streamer, streamerName: p.streamerName, title: p.title, matched: false, seen: false });
            cards.push({ type: 'card', pairId: p.id, id: `${p.id}-1`, audio: p.audio, avatar: p.avatar, streamer: p.streamer, streamerName: p.streamerName, title: p.title, matched: false, seen: false });
          });
          shuffleInPlace(cards);
          matchedPairs = 0; correct = 0; wrong = 0; tries = 0; timer = 0; first = null; second = null; allowClick = true;
          // å»ºç«‹æ–°å›åˆæ™‚ä¸è‡ªå‹•å•Ÿå‹•éŠæˆ²æˆ–è¨ˆæ™‚å™¨ï¼›éŠæˆ²æœƒåœ¨ç©å®¶ç¿»é–‹ç¬¬ä¸€å¼µå¡æ™‚é–‹å§‹ã€‚
          timerStarted = false;
          running = false;
          state.cgRunning = false;
          // ç¢ºä¿è¨ˆæ™‚å™¨çš„ UI è¢«é‡ç½®ï¼Œä¸¦ç§»é™¤æ­£åœ¨é‹è¡Œçš„æ¨£å¼
          if (timerEl) { timerEl.textContent = formatTime(timer); timerEl.classList.remove('cg-running'); }
          updateBoard();
          updateStats();
          resultEl.classList.add('hidden');
          // æä¾›æ¸…ç†å‡½å¼ï¼ˆæŒ‡å®šçµ¦å¤–å±¤çš„ cgCleanupï¼Œä½¿ showPage åœ¨é›¢é–‹éŠæˆ²é æ™‚å¯ä»¥å‘¼å«ï¼‰
          cgCleanup = () => {
            running = false;
            state.cgRunning = false;
            stopTimer();
            stopCurrentAudio();
            if (timerEl) timerEl.classList.remove('cg-running');
            // é€éæ¸…ç©º board çš„ innerHTML ç§»é™¤æ‰€æœ‰äº‹ä»¶è™•ç†å™¨èˆ‡ DOM å…ƒç´ 
            boardEl.innerHTML = '';
            // æ¸…é™¤ä»»ä½•å°šæœªå®Œæˆçš„ pending timeout
            try { if (pendingTimeout) { clearTimeout(pendingTimeout); pendingTimeout = null; pendingPair = null; } } catch (e) { }
          };
        }
        function updateBoard() {
          boardEl.innerHTML = '';
          cards.forEach((card, idx) => {
            const cardEl = document.createElement('div');
            cardEl.className = 'cg-card';
            cardEl.dataset.idx = idx;
            if (card.flipped || card.matched) cardEl.classList.add('flipped');
            if (card.matched) cardEl.classList.add('matched');
            // è‹¥æä¾› avatar å‰‡é¡¯ç¤ºåœ–ç‰‡ï¼Œå¦å‰‡ä»¥å®‰å…¨æ–¹å¼é¡¯ç¤ºåå­—çš„ç¸®å¯«å­—æ¯
            const backContent = card.avatar
              ? `<img src="${withV(card.avatar)}" alt="${card.streamerName}">`
              : `<div style="font-weight:700;color:var(--muted);font-size:12px">${card.streamerName}</div>`;
            cardEl.innerHTML = `
        <div class="cg-card-inner">
          <div class="cg-card-front"></div>
          <div class="cg-card-back">
            ${backContent}
            ${card.matched ? '<div class="cg-lock">âœ“</div>' : ''}
          </div>
        </div>
      `;
            // ä¿ç•™åŸæœ¬çš„é»æ“Šè¡Œç‚ºï¼Œä¸¦åœ¨ pointerdown æ™‚å¢åŠ çŸ­æš«çš„è¦–è¦ºå›é¥‹ï¼ˆCSSï¼‰
            cardEl.onclick = () => onCardClick(idx);
            cardEl.addEventListener('pointerdown', (ev) => {
              // åŠ ä¸Š 'clicked' é¡åˆ¥ä»¥è§¸ç™¼ CSS å›é¥‹ï¼ŒçŸ­æ™‚é–“å¾Œç§»é™¤
              cardEl.classList.add('clicked');
              setTimeout(() => cardEl.classList.remove('clicked'), 160);
            });
            boardEl.appendChild(cardEl);
          });
        }

        let currentAudio = null;

        function stopCurrentAudio() {
          if (currentAudio) {
            try { currentAudio.pause(); currentAudio.currentTime = 0; } catch (e) { }
            currentAudio = null;
          }
        }

        function onCardClick(idx) {
          // å¦‚æœæœ‰å¾…è™•ç†çš„ pendingPairï¼Œä½¿ç”¨è€…æ­¤åˆ»é»æ“Šå…¶ä»–å¡ç‰‡æ™‚æ‡‰ç«‹å³çµç®—è©² pendingPair
          if (typeof pendingPair !== 'undefined' && pendingPair && (pendingPair.f || pendingPair.s)) {
            // å…ˆæ¸…é™¤ timeout ä¸¦ç«‹åˆ»çµç®—
            if (pendingTimeout) { clearTimeout(pendingTimeout); pendingTimeout = null; }
            const p = pendingPair; pendingPair = null;
            checkMatchPair(p.f, p.s);
            // é‡ç½®å…¨åŸŸ first/secondï¼Œå…è¨±ç¹¼çºŒäº’å‹•
            first = null; second = null;
            allowClick = true;
          }
          if (!allowClick) return;
          const card = cards[idx];
          if (card.flipped || card.matched) return;
          // åœ¨ç©å®¶ç¬¬ä¸€æ¬¡äº’å‹•ï¼ˆç¿»ç‰Œï¼‰æ™‚å•Ÿç”¨è¨ˆæ™‚å™¨
          if (!timerStarted) {
            timerStarted = true;
            // å°‡éŠæˆ²æ¨™è¨˜ç‚ºæ­£åœ¨é€²è¡Œä¸¦æ›´æ–° UI
            running = true;
            state.cgRunning = true;
            if (timerEl) timerEl.classList.add('cg-running');
            startTimer();
          }
          // åŸ·è¡Œç¿»ç‰Œï¼ˆæ›´æ–°è³‡æ–™ç‹€æ…‹ä¸¦é‡æ–°æ¸²æŸ“æ¿é¢ï¼Œè§¸ç™¼ CSS ç¿»ç‰Œå‹•ç•«ï¼‰
          card.flipped = true;
          updateBoard();
          if (!first) {
            // è¨˜éŒ„é€™å¼µå¡ç‰Œåœ¨ç¿»å‰æ˜¯å¦å·²è¢«ç¿»çœ‹éï¼ˆç”¨æ–¼è¨ˆåˆ†åˆ¤å®šï¼‰
            card._seenBefore = !!card.seen;
            // æ¨™è¨˜ç‚ºå·²çœ‹éï¼ˆé¿å…å¾ŒçºŒé‡è¤‡è¨ˆåˆ†ï¼‰
            card.seen = true;
            first = card;
            // æ’­æ”¾è©²å¡çš„éŸ³æ•ˆä¸¦é¡¯ç¤ºæ¨™é¡Œï¼›é¿å…éŸ³è¨Šé‡ç–Š
            stopCurrentAudio();
            currentAudio = createPlayer(card.audio, { preload: 'auto' });
            if (typeof toast === 'function' && card.title) toast(card.title, 3000);
          } else if (!second) {
            // ç¬¬äºŒå¼µå¡çš„è™•ç†ï¼šåŒæ¨£æ¨™è¨˜æ˜¯å¦å…ˆå‰çœ‹éä¸¦æ’­æ”¾éŸ³æ•ˆ
            card._seenBefore = !!card.seen;
            card.seen = true;
            second = card;
            stopCurrentAudio();
            currentAudio = createPlayer(card.audio, { preload: 'auto' });
            if (typeof toast === 'function' && card.title) toast(card.title, 3000);
            tries++;
            allowClick = false;
            // æ•ç²ç•¶å‰ç¬¬ä¸€å¼µ/ç¬¬äºŒå¼µå¡çš„å¼•ç”¨ï¼Œé¿å…åœ¨å»¶é²æœŸé–“è¢«å…¶ä»–é‚è¼¯æ”¹å¯«é€ æˆ race conditionã€‚
            const fCard = first;
            const sCard = second;
            // å„²å­˜ç‚º pendingPairï¼Œä¸¦å•Ÿå‹•è¶…æ™‚ï¼ˆ500msï¼‰ã€‚å¦‚æœä½¿ç”¨è€…åœ¨æ­¤æœŸé–“é»æ“Šå…¶ä»–å¡
            // å‰‡æœƒåœ¨ onCardClick é–‹é ­ç«‹åˆ»çµç®—é€™å°ã€‚
            pendingPair = { f: fCard, s: sCard };
            if (pendingTimeout) { clearTimeout(pendingTimeout); pendingTimeout = null; }
            pendingTimeout = setTimeout(() => {
              pendingTimeout = null;
              const p = pendingPair; pendingPair = null;
              checkMatchPair(p.f, p.s);
              // é‡ç½®å…¨åŸŸæš«å­˜ï¼Œå…è¨±ä¸‹ä¸€å›åˆäº’å‹•
              first = null;
              second = null;
              allowClick = true;
            }, 500);
          }
          updateStats();
        }

        /**
         * æª¢æŸ¥ä¸€å°å¡ç‰‡æ˜¯å¦é…å°ï¼Œåƒ…æ“ä½œå‚³å…¥çš„å¡ç‰©ä»¶ï¼ˆé¿å… race conditionï¼‰ã€‚
         * é€™å€‹å‡½å¼ä¸æœƒå»é‡ç½®å¤–å±¤çš„ first/second è®Šæ•¸ï¼Œå‘¼å«ç«¯æ‡‰è² è²¬é‡ç½®èˆ‡å…è¨±ä½¿ç”¨è€…äº’å‹•ã€‚
         * @param {object|null} f ç¬¬ä¸€å¼µå¡
         * @param {object|null} s ç¬¬äºŒå¼µå¡
         */
        function checkMatchPair(f, s) {
          if (!f || !s) return;
          if (f.pairId === s.pairId) {
            // é…å°æ­£ç¢ºï¼šå¢åŠ æ­£ç¢ºè¨ˆåˆ†ï¼ˆ+2ï¼‰
            f.matched = true;
            s.matched = true;
            correct += 2;
            matchedPairs += 1;
            // ä¿æŒç¿»é¢ç‹€æ…‹ä¸¦æ¨™è¨˜ç‚ºå·²é…å°ï¼ˆä¸å¯å†æ¬¡é»æ“Šï¼‰
          } else {
            // æœªé…å°ï¼šåˆ¤å®šæ˜¯å¦åœ¨æ­¤å›åˆå‰å·²çœ‹éä»»ä¸€å¼µå¡ï¼Œæ ¹æ“šæƒ…æ³å¢åŠ  wrong åˆ†æ•¸
            const aSeen = !!f._seenBefore;
            const bSeen = !!s._seenBefore;
            if (aSeen && bSeen) wrong += 2;
            else if (aSeen || bSeen) wrong += 1;
            // å°‡å…©å¼µå¡ç¿»å›ï¼ˆé—œé–‰ç¿»é¢ç‹€æ…‹ï¼‰

            f.flipped = false;
            s.flipped = false;

          }
          // æ¸…ç†æš«å­˜çš„ _seenBefore æ¨™è¨˜
          delete f._seenBefore;
          delete s._seenBefore;
          // æ›´æ–° UI èˆ‡çµ±è¨ˆ
          updateBoard();
          updateStats();
          if (matchedPairs === pairs.length) {
            stopCurrentAudio();
            endGame();
          }
        }

        // å‘å¾Œç›¸å®¹çš„ wrapperï¼ˆä¿ç•™åŸæœ¬ä»»ä½•ç›´æ¥å‘¼å« checkMatch çš„è¡Œç‚ºï¼‰
        function checkMatch() {
          const f = first;
          const s = second;
          checkMatchPair(f, s);
          // å‘¼å«ç«¯ï¼ˆä¾‹å¦‚å»¶é²å›å‘¼ï¼‰é€šå¸¸æœƒè² è²¬é‡ç½® first/second èˆ‡ allowClickï¼›
          // è‹¥æœ‰ç›´æ¥å‘¼å«æ­¤ wrapperï¼Œé€™è£¡ä¹Ÿç¢ºä¿æŠŠ first/second æ¸…ç©ºä»¥é¿å…æ®˜ç•™ç‹€æ…‹ã€‚
          first = null; second = null;
        }

        function updateStats() {
          timerEl.textContent = formatTime(timer);
          const denom = correct + wrong;
          const perc = denom ? Math.round((correct / denom) * 100) : null;
          accEl.textContent = perc !== null ? `æº–ç¢ºç‡ï¼š${perc}%` : 'æº–ç¢ºç‡ï¼š--%';
        }

        function formatTime(t) {
          const m = Math.floor(t / 60).toString().padStart(2, '0');
          const s = (t % 60).toString().padStart(2, '0');
          return `${m}:${s}`;
        }

        function startTimer() {
          if (timerId) clearInterval(timerId);
          timerId = setInterval(() => {
            // åªæœ‰ç•¶éŠæˆ²æ¨™è¨˜ç‚ºé€²è¡Œä¸­æ™‚æ‰æœƒæ¨é€²è¨ˆæ™‚å™¨
            if (!state.cgRunning) return;
            timer++;
            timerEl.textContent = formatTime(timer);
          }, 1000);
        }
        function stopTimer() {
          if (timerId) clearInterval(timerId);
          timerId = null;
        }

        function endGame() {
          running = false;
          state.cgRunning = false;
          stopTimer();
          stopCurrentAudio();
          if (timerEl) timerEl.classList.remove('cg-running');
          const denom = correct + wrong;
          const perc = denom ? Math.round((correct / denom) * 100) : '--';
          resultEl.innerHTML = `
            <h3>å®Œæˆï¼</h3>
            <div class="stats">
              <div><div class="big-num">${formatTime(timer)}</div><div class="muted">ç”¨æ™‚</div></div>
              <div><div class="big-num">${correct}</div><div class="muted">æ­£ç¢ºæ•¸</div></div>
              <div><div class="big-num">${wrong}</div><div class="muted">éŒ¯è§£æ•¸</div></div>
              <div><div class="big-num">${perc}%</div><div class="muted">æº–ç¢ºç‡</div></div>
            </div>
            <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
              <button class="btn small-btn" id="cg-restart-2">å†ä¾†ä¸€å±€</button>
              <button class="btn small-btn" id="cg-home">å›ä¸»é </button>
            </div>
          `;
          resultEl.classList.remove('hidden');
          // è‹¥æº–ç¢ºç‡ç‚º 100%ï¼Œéš¨æ©Ÿæ’­æ”¾ä¸€å‰‡æŒ‡å®š id çš„çå‹µéŸ³æ•ˆ
          try {
            if (perc >= 90) {
              // ç¡¬ç·¨ç¢¼çå‹µèªéŸ³ id æ¸…å–®
              const rewardIds = ['c4B1fg', 'Hv3yFA', 'JkJ9-A', '5VHtAg'];
              const reward = state.sounds && state.sounds.find(s => s.id === rewardIds[Math.floor(Math.random() * rewardIds.length)]);
              if (reward && reward.src) {
                // åœæ‰ç¾æœ‰éŸ³è¨Šä¸¦æ’­æ”¾çå‹µéŸ³æ•ˆ
                stopCurrentAudio();
                currentAudio = createPlayer(reward.src, { preload: 'auto' });
                if (typeof toast === 'function') toast('ä½ æ˜¯è¨˜æ†¶çŒ›è‚', 3000);
              }
            }

          } catch (e) { /* swallow any error to avoid breaking end-game UI */ }
          // ç‚ºçµæœé¢æ¿å…§çš„æŒ‰éˆ•ç¶å®šæœ¬åœ°äº‹ä»¶è™•ç†å™¨ï¼ˆä¾‹å¦‚å†ä¾†ä¸€å±€ã€å›ä¸»é ï¼‰
          const restart2 = document.getElementById('cg-restart-2');
          if (restart2) restart2.addEventListener('click', () => { startGame(); });
          const homeBtn = document.getElementById('cg-home');
          if (homeBtn) homeBtn.addEventListener('click', () => { showPage('home'); });
        }

        restartBtn.onclick = startGame;

        // åˆå§‹ï¼šè¼‰å…¥é é¢æ™‚é¡¯ç¤ºå¡ç‰Œï¼ˆä¸å•Ÿå‹•è¨ˆæ™‚ï¼‰ã€‚æŒ‰ã€Œé‡é–‹ä¸€å±€ã€å¯é‡æ–°å»ºç«‹ä¸€å±€ï¼›è¨ˆæ™‚çš†åœ¨ç¬¬ä¸€å¼µç¿»ç‰Œæ™‚å•Ÿå‹•ã€‚
        // é€™è£¡å‘¼å« startGame() ä»¥å»ºç«‹ä¸¦é¡¯ç¤ºå¡ç‰Œï¼ˆä½† timerStarted=falseï¼Œä¸æœƒè‡ªå‹•é–‹å§‹è¨ˆæ™‚ï¼‰
        startGame();
      }

      // åˆ‡æ›åˆ°å°éŠæˆ²åˆ†é æ™‚åˆå§‹åŒ–/æ¸…ç† Concentration Gameï¼ˆä½¿ç”¨äº‹ä»¶é©…å‹•ï¼‰
      document.addEventListener('pageChange', (ev) => {
        const pg = ev && ev.detail && ev.detail.page;
        const prev = ev && ev.detail && ev.detail.prevPage;
        try {
          const phase = ev && ev.detail && ev.detail.phase;
          // åœ¨ page è¢«éš±è—ä¹‹å‰ï¼ˆbeforeï¼‰ï¼ŒåŸ·è¡Œæ¸…ç†
          if (phase === 'before' && prev === 'game' && typeof cgCleanup === 'function') {
            try { cgCleanup(); } catch (e) { /* ignore cleanup errors */ }
          }
          // åœ¨ page é¡¯ç¤ºä¹‹å¾Œï¼ˆafterï¼‰ï¼ŒåŸ·è¡Œåˆå§‹åŒ–
          if (phase === 'after') {
            if (pg === 'game' && typeof setupConcentrationGame === 'function') setupConcentrationGame();
            if (pg === 'awards') renderawardsPage();
          }
        } catch (e) { /* swallow to avoid breaking page flow */ }
      });

    })();
  </script>
</body>

</html>