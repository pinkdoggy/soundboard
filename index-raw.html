<!--
    阿萬與動物朋友按鈕 - 粉肝製作蒐集阿萬與動物朋友語音的網站
    Copyright (C) 2025 by NaN

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->

<!doctype html>
<html lang="zh-Hant">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="assets/favicon.png" type="image/png">

  <title>阿萬與動物朋友按鈕</title>
  <style>
    /* =============================================================================
       1. CSS 變數系統（CSS Custom Properties）
       
       定義全站使用的設計 Token，包含：
       - 色彩系統（亮色/暗色主題）
       - 間距系統（4px 基礎單位）
       - 圓角系統
       - 陰影系統
       - 動畫時間系統
       ============================================================================= */

    /* -----------------------------------------------------------------------------
       1.1 暗色主題變數（預設）
       ----------------------------------------------------------------------------- */
    :root {
      /* --- 色彩：基礎 --- */
      --bg: #0b0d10;
      /* 頁面背景色 */
      --search: #0b0d1000;
      /* 搜尋列背景（透明） */
      --fg: #e9eef5;
      /* 主要文字色 */
      --muted: #a8b3c7;
      /* 次要/輔助文字色 */
      --card: #141821;
      /* 卡片背景色 */
      --card-2: #212832;
      /* 次級卡片/按鈕背景色 */
      --border: #202636;
      /* 邊框色 */

      /* --- 色彩：強調色 --- */
      --accent: #6aa9ff;
      /* 主強調色（藍） */
      --accent-2: #ff9e6a;
      /* 次強調色（橘） */
      --heart: #ff5a7a;
      /* 愛心/收藏色 */
      --chip-fg: #0b0d10;
      /* 標籤文字色（深色背景用） */

      /* --- 色彩：互動狀態 --- */
      --hover-overlay: rgba(96, 150, 255, 0.20);
      /* 懸停覆蓋層 */

      /* --- 玻璃擬態 --- */
      --glass-bg: rgba(20, 24, 33, 0.8);
      /* 玻璃背景 */
      --glass-border: rgba(255, 255, 255, 0.12);
      /* 玻璃邊框 */

      /* --- 背景圖層 --- */
      --bg-blend-mode: normal;
      /* 背景混合模式 */
      --bg-opacity: 0.25;
      /* 背景透明度 */

      /* --- 間距系統（4px 基礎單位） --- */
      --space-xs: 4px;
      /* 極小間距 */
      --space-sm: 8px;
      /* 小間距 */
      --space-md: 12px;
      /* 中間距 */
      --space-lg: 16px;
      /* 大間距 */
      --space-xl: 20px;
      /* 特大間距 */
      --space-2xl: 24px;
      /* 超大間距 */

      /* --- 圓角系統 --- */
      --radius-sm: 8px;
      /* 小圓角（小按鈕） */
      --radius-md: 10px;
      /* 中圓角（按鈕、Toast） */
      --radius-lg: 12px;
      /* 大圓角（卡片、選單） */
      --radius-xl: 16px;
      /* 特大圓角（面板） */
      --radius-pill: 999px;
      /* 膠囊圓角 */

      /* --- 陰影系統 --- */
      --shadow-sm: 0 2px 6px rgba(0, 0, 0, 0.18);
      /* 小陰影（標籤） */
      --shadow-md: 0 6px 24px rgba(0, 0, 0, 0.25);
      /* 中陰影（卡片） */
      --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.35);
      /* 大陰影（頭像） */
      --shadow: var(--shadow-md);
      /* 預設陰影（相容舊代碼） */

      /* --- 動畫時間 --- */
      --duration-fast: 0.06s;
      /* 快速動畫（點擊回饋） */
      --duration-normal: 0.15s;
      /* 正常動畫（hover） */
      --duration-slow: 0.3s;
      /* 慢速動畫（轉場） */

      /* --- 控制項尺寸 --- */
      --control-h: 44px;
      /* 控制項高度（觸控友善） */
    }

    /* -----------------------------------------------------------------------------
       1.2 亮色主題變數
       ----------------------------------------------------------------------------- */
    :root.light {
      /* --- 色彩：基礎 --- */
      --bg: #f8fafc;
      --search: #f8fafc00;
      --fg: #0d1320;
      --muted: #4b5563;
      --card: #ffffff;
      --card-2: #f3f6fb;
      --border: #e5e7eb;

      /* --- 色彩：強調色 --- */
      --accent: #2563eb;
      --accent-2: #eb7b25;
      --heart: #e11d48;
      --chip-fg: #ffffff;

      /* --- 玻璃擬態 --- */
      --glass-bg: rgba(255, 255, 255, 0.6);
      --glass-border: rgba(15, 23, 42, 0.12);

      /* --- 背景圖層 --- */
      --bg-blend-mode: normal;
      --bg-opacity: 0.35;

      /* --- 陰影系統（亮色主題較淺） --- */
      --shadow-sm: 0 2px 6px rgba(2, 6, 23, 0.06);
      --shadow-md: 0 4px 18px rgba(2, 6, 23, 0.08);
      --shadow-lg: 0 6px 24px rgba(2, 6, 23, 0.12);
      --shadow: var(--shadow-md);
    }

    /* =============================================================================
       2. CSS Reset / 基礎樣式
       
       包含：
       - Box-sizing 重設
       - Body 基礎樣式
       - 背景圖層
       - 基礎元素樣式
       ============================================================================= */

    /* --- 全域 Box-sizing --- */
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    /* --- HTML/Body 基礎 --- */
    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background-color: var(--bg);
      color: var(--fg);
      font: medium ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Noto Sans, "Helvetica Neue", Arial;
      position: relative;
      z-index: 1;
      /* 將所有內容提升到背景圖之上 */
    }

    /* --- 自訂捲軸樣式 (Webkit) --- */
    ::-webkit-scrollbar {
      width: 14px;
      height: 14px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--muted);
      border-radius: var(--radius-pill);
      border: 3px solid var(--bg); /* 創造間距感 */
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--accent);
      border-width: 2px; /* hover 時讓捲軸看起來更粗一點 */
    }

    ::-webkit-scrollbar-corner {
      background: transparent;
    }

    /* --- 背景圖層（偽元素實現固定背景） --- */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('assets/background-by-jia.avif');
      background-size: auto 90%;
      background-repeat: repeat;
      background-attachment: fixed;
      background-position: var(--bg-x, 0px) 0;
      transition: background-position 1s ease-out;
      mix-blend-mode: var(--bg-blend-mode);
      opacity: var(--bg-opacity);
      z-index: -1;
      pointer-events: none;
    }

    /* --- 連結基礎 --- */
    a {
      color: inherit;
    }

    /* =============================================================================
       3. 共用元件樣式
       
       可重用的 UI 元件，包含：
       - .glass：玻璃擬態基礎
       - .btn：按鈕系列
       - .chip：標籤膠囊
       - .tag：音效標籤
       - .grid：響應式網格
       ============================================================================= */

    /* -----------------------------------------------------------------------------
       3.1 玻璃擬態樣式
       
       統一套用半透明模糊背景效果的元件
       ----------------------------------------------------------------------------- */

    /* 套用玻璃樣式的元件 */
    .searchbar,
    .sound,
    .menu,
    #page-about .about-content,
    .bg-credit,
    .cg-header,
    .cg-board,
    .cg-result,
    .cg-rules {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: saturate(1.8) blur(12px);
      -webkit-backdrop-filter: saturate(1.8) blur(12px);
      box-shadow: var(--shadow);
    }

    /* -----------------------------------------------------------------------------
       3.2 按鈕系統
       ----------------------------------------------------------------------------- */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-xs);
      padding: var(--space-sm) var(--space-md);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      background: linear-gradient(to bottom, var(--card), var(--card-2));
      color: var(--fg);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--duration-normal) ease;
      box-shadow: var(--shadow-sm);
    }

    .btn:hover {
      background: linear-gradient(to bottom, var(--card-2), var(--border));
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: var(--shadow-sm);
    }

    /* 小型按鈕變體 */
    .btn--small,
    .small-btn {
      padding: var(--space-xs) var(--space-sm);
      font-size: 12px;
      border-radius: var(--radius-sm);
    }

    /* 圖示按鈕變體 */
    .btn--icon {
      min-width: 32px;
      padding: 6px;
    }

    /* -----------------------------------------------------------------------------
       3.3 標籤膠囊（Chip）
       
       用於搜尋列中的已選標籤
       ----------------------------------------------------------------------------- */
    .chip {
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-pill);
      font-size: 12px;
      color: var(--chip-fg);
      box-shadow: var(--shadow-sm);
      cursor: pointer;
    }

    .chip button {
      appearance: none;
      border: 0;
      background: transparent;
      color: inherit;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      padding: 0 0 0 2px;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-xs);
      margin-top: var(--space-xs);
    }

    /* -----------------------------------------------------------------------------
       3.4 音效標籤（Tag）
       
       用於音效卡片上的分類標籤
       ----------------------------------------------------------------------------- */
    .tag {
      display: inline-block;
      padding: 3px 6px;
      border-radius: var(--radius-pill);
      font-size: small;
      color: var(--chip-fg);
      white-space: nowrap;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
    }

    .tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    /* 標籤一覽區域 */
    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px var(--space-sm);
      margin: var(--space-sm) 0;
    }

    /* -----------------------------------------------------------------------------
       3.5 響應式網格系統
       
       音效卡片的網格佈局，根據螢幕寬度自動調整欄數
       ----------------------------------------------------------------------------- */
    .grid {
      display: grid;
      gap: var(--space-xs);
      grid-template-columns: repeat(6, minmax(0, 1fr));
    }

    /* =============================================================================
       4. 佈局元件
       
       頁面結構相關的佈局元件：
       - .wrap：主容器
       - header：頁首
       - .section-header：區塊標題列
       ============================================================================= */

    /* -----------------------------------------------------------------------------
       4.1 主容器
       ----------------------------------------------------------------------------- */
    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: var(--space-xl);
    }

    /* -----------------------------------------------------------------------------
       4.2 頁首（Header）
       ----------------------------------------------------------------------------- */
    header {
      display: flex;
      align-items: center;
      flex-wrap: nowrap;
      /* 保持標題與選單在同一行 */
      gap: var(--space-md);
      margin-bottom: 14px;
    }

    header h1 {
      white-space: normal;
      min-width: 0;
      overflow-wrap: anywhere;
      margin-right: auto;
      /* 將後方元素推到右側 */
    }

    h1 {
      font-size: 1.4rem;
      margin: 0 var(--space-sm) 0 0;
      letter-spacing: 0.5px;
    }

    /* 主題切換按鈕（使用通用按鈕樣式） */
    .theme-toggle {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--fg);
      border-radius: var(--radius-md);
      padding: var(--space-sm) var(--space-md);
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    /* -----------------------------------------------------------------------------
       4.3 導覽分頁（Tabs）
       ----------------------------------------------------------------------------- */
    .tabs {
      display: flex;
      gap: var(--space-sm);
      align-items: center;
      flex-wrap: wrap;
    }

    .tab {
      display: inline-block;
      padding: 6px var(--space-lg);
      font-size: 14px;
      border: 1px solid var(--border);
      border-radius: var(--radius-pill);
      background: var(--card-2);
      color: var(--fg);
      cursor: pointer;
      transition: background var(--duration-normal) ease, color var(--duration-normal) ease;
    }

    .tab:hover {
      background: var(--card);
    }

    .tab.active {
      background: var(--accent);
      border-color: var(--accent);
      color: var(--chip-fg);
    }

    /* 手機版漢堡選單按鈕 */
    .nav-toggle {
      display: none;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--fg);
      border-radius: var(--radius-md);
      padding: var(--space-sm);
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    /* -----------------------------------------------------------------------------
       4.4 區塊標題列（Section Header）
       ----------------------------------------------------------------------------- */
    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 14px 0 var(--space-sm);
    }

    .section-header h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.2px;
    }

    .section-header .actions {
      display: flex;
      gap: 3px;
    }

    .section-title {
      margin: 18px 0 10px;
      font-weight: 700;
      letter-spacing: 0.3px;
    }

    /* =============================================================================
       5. 功能模組樣式
       
       各功能區塊的專屬樣式
       ============================================================================= */

    /* -----------------------------------------------------------------------------
       5.1 搜尋列模組
       ----------------------------------------------------------------------------- */
    .anniversary-zone {
      width: 100%;
      margin-bottom: var(--space-sm);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
      /* 預留空間給未來的頭像與動畫 */
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* 三週年內容容器（面板） */
    .anniversary-content {
      width: 100%;
      padding: var(--space-md);
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      position: relative;
    }

    /* 通用 Row 樣式 */
    .anniversary-row {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Row 1: 標題行 */
    .anniversary-title-row {
      padding: var(--space-sm) 0;
    }

    .anniversary-title {
      cursor: pointer;
      transition: transform var(--duration-fast);
      padding: var(--space-xs);
    }

    .anniversary-title:active {
      transform: scale(0.98);
    }

    .anniversary-text {
      color: #fff;
      font-weight: 900;
      font-size: 1.5rem;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      user-select: none;
      letter-spacing: 1px;
      text-align: center;
    }

    /* Row 2: 壓縮檔行 */
    .anniversary-archive-row {
      padding: var(--space-sm) 0;
    }

    .anniversary-archive {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform var(--duration-fast);
      padding: var(0);
    }

    .anniversary-archive:hover {
      transform: scale(1.05);
    }

    .anniversary-archive:active {
      transform: scale(0.95);
    }

    .archive-icon {
      width: 80px;
      height: 80px;
      object-fit: contain;
      margin-bottom: 8px;
      filter: drop-shadow(0 2px 8px rgba(0,0,0,0.3));
      transition: filter var(--duration-fast);
    }

    .anniversary-archive:hover .archive-icon {
      filter: drop-shadow(0 4px 12px rgba(0,0,0,0.4));
    }

    .archive-filename {
      color: #fff;
      font-weight: 600;
      font-size: 0.9rem;
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
      user-select: none;
      font-family: monospace;
      letter-spacing: 0.5px;
    }

    /* 解壓後的音效網格區域 */
    .anniversary-sounds-grid {
      width: 100%;
      padding: var(--space-md);
      display: grid;
      gap: var(--space-sm);
      grid-template-columns: repeat(auto-fit, minmax(min(100%, 160px), 1fr));
    }

    /* 響應式：寬螢幕時顯示 4 列，窄螢幕時顯示 2 列 */
    @media (min-width: 768px) {
      .anniversary-sounds-grid {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    @media (max-width: 767px) {
      .anniversary-sounds-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* anniversary-sounds-grid 中的音效卡片置頂，不受其他顯示邏輯影響 */
    .anniversary-sounds-grid .sound {
      position: relative;
      z-index: 10;
    }

    /* 音效卡片淡入動畫 */
    @keyframes soundFadeIn {
      from {
        opacity: 0;
        transform: translateY(-10px) scale(0.9);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .anniversary-sounds-grid .sound {
      animation: soundFadeIn 0.3s ease-out forwards;
      opacity: 0;
    }

    /* Row 3: 解壓縮進度條行 */
    .extract-row {
      padding: var(--space-md) 0;
    }

    .extract-container {
      width: 100%;
      max-width: 400px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-lg);
      padding: var(--space-md) var(--space-lg);
      border: 1px solid rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(8px);
    }

    .extract-title {
      color: #fff;
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: var(--space-md);
      text-align: center;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .extract-progress-bar {
      width: 100%;
      height: 24px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: var(--radius-md);
      overflow: hidden;
      margin-bottom: var(--space-sm);
      position: relative;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .extract-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #6aa9ff, #8b5cf6);
      width: 0%;
      transition: width 0.05s linear;
      border-radius: var(--radius-md);
      position: relative;
      overflow: hidden;
    }

    .extract-progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.3),
        transparent
      );
      animation: shimmer 1s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .extract-progress-text {
      color: #fff;
      font-size: 0.9rem;
      text-align: center;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .search-row {
      display: flex;
      flex-wrap: nowrap;
      gap: 0;
      align-items: stretch;
      position: sticky;
      top: 0;
      background: var(--search);
      padding: var(--space-sm) 0 var(--space-md);
      z-index: 5;
    }

    .searchbar {
      flex: 1 1 auto;
      min-width: 0;
      display: flex;
      align-items: center;
      gap: 6px;
      border-radius: var(--radius-lg) 0 0 var(--radius-lg);
      border-right: 0;
      padding: 6px var(--space-sm);
      position: relative;
      height: var(--control-h);
      transition: box-shadow var(--duration-normal) ease, border-color var(--duration-normal) ease;
    }

    .searchbar:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(106, 169, 255, 0.25);
      z-index: 1;
    }

    .searchbar input {
      flex: 1;
      min-width: 0;
      background: transparent;
      border: 0;
      outline: 0;
      color: var(--fg);
      font-size: 16px;
      height: 100%;
      line-height: var(--control-h);
      padding: 0 6px;
    }

    /* 清除按鈕（搜尋列右側） */
    .search-row #clearBtn {
      flex: 0 0 auto;
      white-space: nowrap;
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
      border-left: 1px solid var(--glass-border);
      background: var(--glass-bg);
      backdrop-filter: saturate(1.5) blur(8px);
      -webkit-backdrop-filter: saturate(1.5) blur(8px);
      height: var(--control-h);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 14px;

      /* 覆蓋 .btn 的預設互動樣式 */
      box-shadow: none;
      transition: color var(--duration-normal) ease;
    }

    .search-row #clearBtn:hover {
      background: var(--glass-bg);
      /* 保持原邊框色，不隨 .btn:hover 變色 */
      border-top-color: var(--border);
      border-right-color: var(--border);
      border-bottom-color: var(--border);
      border-left-color: var(--glass-border);
      transform: none;
      box-shadow: none;
      color: var(--accent);
    }

    .search-row #clearBtn:active {
      transform: none;
      box-shadow: none;
    }

    /* -----------------------------------------------------------------------------
       5.2 音效卡片模組
       ----------------------------------------------------------------------------- */
    .sound {
      border-radius: var(--radius-lg);
      padding: var(--space-sm);
      display: flex;
      flex-direction: column;
      gap: 5px 2px;
      user-select: none;
      cursor: pointer;
      transition: transform var(--duration-normal) cubic-bezier(0.34, 1.56, 0.64, 1), 
                  box-shadow var(--duration-normal) ease,
                  border-color var(--duration-normal) ease;
    }

    .sound:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
      border-color: var(--accent);
      z-index: 10;
    }

    .sound:active {
      transform: scale(0.98);
      transition: transform var(--duration-fast) ease;
    }

    .sound-top {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .title {
      font-weight: 600;
      font-size: smaller;
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* 愛心按鈕 */
    .heart {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      background: var(--card-2);
      cursor: pointer;
      flex: 0 0 auto;
      padding: 0;
    }

    .heart svg {
      width: 14px;
      height: 14px;
      display: block;
      flex-shrink: 0;
    }

    .heart[aria-pressed="true"] svg path {
      fill: var(--heart);
    }

    /* -----------------------------------------------------------------------------
       5.3 播放舞台模組（頭像動畫）
       ----------------------------------------------------------------------------- */
    .stage {
      position: fixed;
      left: 0;
      right: 0;
      top: var(--space-md); /* 改為頂部定位 */
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-md) 14px;
      justify-content: center;
      pointer-events: none;
      z-index: 40;
      padding: 0 var(--space-md);
    }

    .group {
      display: inline-flex;
      gap: var(--space-sm);
      align-items: flex-start; /* 改為向下堆疊 */
    }

    .avatar {
      width: 75px;
      height: 75px;
      border-radius: var(--radius-pill);
      background: transparent;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.8);
      box-shadow: var(--shadow-lg);
      transform-origin: 50% 0%; /* 改為從頂部作為變換原點 */
    }

    .avatar>img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* -----------------------------------------------------------------------------
       5.4 右鍵選單模組
       ----------------------------------------------------------------------------- */
    .menu {
      position: fixed;
      z-index: 9999;
      min-width: 180px;
      border-radius: var(--radius-lg);
      overflow: hidden;
    }

    .menu.hidden {
      display: none;
    }

    .menu-item {
      padding: 10px var(--space-md);
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      transition: background var(--duration-normal) ease;
    }

    .menu-item:last-child {
      border-bottom: 0;
    }

    .menu-item:hover {
      background: var(--hover-overlay);
    }

    /* -----------------------------------------------------------------------------
       5.5 Toast 通知模組
       ----------------------------------------------------------------------------- */
    .toast {
      position: fixed;
      left: 50%;
      bottom: 80px;
      transform: translateX(-50%);
      background: var(--card);
      border: 1px solid var(--border);
      padding: 10px 14px;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow);
      z-index: 70;
    }

    .toast.hidden {
      display: none;
    }

    /* -----------------------------------------------------------------------------
       5.6 Modal 對話框模組
       ----------------------------------------------------------------------------- */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.45);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 120;
    }

    .modal-backdrop.hidden {
      display: none;
    }

    .modal {
      background: var(--bg);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      padding: var(--space-md);
      max-width: 320px;
      box-shadow: var(--shadow);
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: var(--space-lg);
    }


    /* -----------------------------------------------------------------------------
      5.7 週年慶祝賀面板
    ----------------------------------------------------------------------------- */

    .gradient-r1-background {
        background: linear-gradient(180deg,
          #ffc0ab, #ff893d, #ffde82, #b2f4c7,
          #60cfff, #2d7eff, #b5b1ff);
        background-size: 1400% 1400%;
        -webkit-animation: gradient-key-r1 30s ease infinite;
        -moz-animation: gradient-key-r1 30s ease infinite;
        animation: gradient-key-r1 30s ease infinite;
    }

    @-webkit-keyframes gradient-key-r1 {
        0%{background-position:50% 0%}
        50%{background-position:50% 100%}
        100%{background-position:50% 0%}
    }
    @-moz-keyframes gradient-key-r1 {
        0%{background-position:50% 0%}
        50%{background-position:50% 100%}
        100%{background-position:50% 0%}
    }
    @keyframes gradient-key-r1 {
        0%{background-position:50% 0%}
        50%{background-position:50% 100%}
        100%{background-position:50% 0%}
    }

    /* =============================================================================
       6. 頁面專屬樣式
       ============================================================================= */

    /* -----------------------------------------------------------------------------
       6.1 關於頁面
       ----------------------------------------------------------------------------- */
    #page-about .about-content {
      border-radius: 14px;
      padding: 14px var(--space-lg);
    }

    /* 背景圖署名 */
    .bg-credit {
      position: fixed;
      right: var(--space-lg);
      bottom: var(--space-lg);
      font-size: large;
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-md);
      font-weight: 800;
      z-index: 60;
    }

    .bg-credit a {
      text-decoration: underline;
    }

    /* 背景滿版模式 */
    body.bg-full {
      --bg-opacity: 1 !important;
    }

    /* =============================================================================
       7. 動畫系統（Keyframes）
       ============================================================================= */

    /* 彈入動畫：用於頭像進場（從上方進入） */
    @keyframes popIn {
      0% {
        transform: translateY(-20px) scale(0.7); /* 改為從上方進入 */
        opacity: 0;
      }

      100% {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }

    /* 抖動動畫：用於播放中的頭像 */
    @keyframes jitter {

      0%,
      100% {
        transform: translateY(0) rotate(0deg);
      }

      20% {
        transform: translateY(-2px) rotate(-1deg);
      }

      40% {
        transform: translateY(1px) rotate(1deg);
      }

      60% {
        transform: translateY(-1px) rotate(0.6deg);
      }

      80% {
        transform: translateY(1px) rotate(-0.6deg);
      }
    }

    /* 跳出動畫：用於頭像離場（向上離開） */
    @keyframes hopOut {
      0% {
        transform: translateY(0);
        opacity: 1;
      }

      22% {
        transform: translateY(12px); /* 改為先向下微動 */
        opacity: 1;
      }

      100% {
        transform: translateY(-60px); /* 改為向上離開 */
        opacity: 0;
      }
    }

    /* 動畫類別 */
    .pop-in {
      animation: popIn 0.28s cubic-bezier(0.2, 0.9, 0.18, 1) both;
    }

    .jit {
      animation: jitter 0.9s ease-in-out infinite;
    }

    .hop-out {
      animation: hopOut 0.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
    }

    /* =========================================================================
       [ADHOC] 三週年特殊機制：特定音效觸發頭像飛入動畫

       此為臨時性功能，未來可能重構為通用的音效事件系統。
       目前實作：OVA1gg 音效在第 9 秒時觸發貓下去頭像從右側飛入

       TODO (未來重構):
       - 將配置移至 sounds.json 中 (如 avatarAnimations 欄位)
       - 支援多個時間點、多個頭像、自訂動畫參數
       ========================================================================= */

    /* 特殊頭像容器：固定在螢幕中央高度，用於飛入動畫 */
    .special-avatar-container {
      position: fixed;
      top: 50%;
      right: 0;
      transform: translateY(-50%);
      z-index: 999;
      pointer-events: none;
    }

    /* 特殊頭像樣式 */
    .special-avatar {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      object-fit: cover;
    }

    /* 飛入動畫：從右側進入螢幕中央 (ease-out) */
    @keyframes flyInFromRight {
      0% {
        transform: translateX(150px);
        opacity: 0;
      }
      100% {
        transform: translateX(calc(-50vw + 60px));
        opacity: 1;
      }
    }

    /* 飛出動畫：從中央離開到左側 (ease-out) */
    @keyframes flyOutToLeft {
      0% {
        transform: translateX(calc(-50vw + 60px));
        opacity: 1;
      }
      100% {
        transform: translateX(calc(-100vw - 150px));
        opacity: 0;
      }
    }

    /* 飛入動畫類別 */
    .fly-in {
      animation: flyInFromRight 0.6s ease-out forwards;
    }

    /* 飛出動畫類別 */
    .fly-out {
      animation: flyOutToLeft 0.6s ease-out forwards;
    }

    /* =============================================================================
       8. 響應式樣式（Media Queries）
       
       統一管理所有斷點調整，從大到小排列
       ============================================================================= */

    /* --- 中等螢幕（≤1000px）：5欄網格 --- */
    @media (max-width: 1000px) {
      .grid {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }
    }

    /* --- 平板（≤800px）：4欄網格 --- */
    @media (max-width: 800px) {
      .grid {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    }

    /* --- 小型平板/手機橫向（≤760px）：漢堡選單 --- */
    @media (max-width: 760px) {
      .nav-toggle {
        display: inline-flex;
      }

      header .tabs {
        display: none;
        position: absolute;
        right: 0;
        top: 100%;
        padding: var(--space-sm);
        border-radius: var(--radius-lg);
        gap: 6px;
        flex-direction: column;
        align-items: stretch;
        min-width: 180px;
        z-index: 120;
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        backdrop-filter: saturate(1.8) blur(12px);
        -webkit-backdrop-filter: saturate(1.8) blur(12px);
        box-shadow: var(--shadow);
      }

      body.nav-open header .tabs {
        display: flex;
      }
    }

    /* --- 大型手機（≤600px）：3欄網格 --- */
    @media (max-width: 600px) {
      .grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      header .tabs {
        margin-top: var(--space-sm);
      }

      header .theme-toggle {
        margin-top: var(--space-sm);
      }
    }

    /* --- 小型手機（≤400px）：2欄網格 --- */
    @media (max-width: 400px) {
      .grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    /* =============================================================================
       9. 工具類別（Utility Classes）
       
       包含：
       - 9.0 通用工具類別
       - 9.1 記憶遊戲頁面
       - 9.2 票選結果頁面
       ============================================================================= */

    /* 隱藏元素 */
    .hidden {
      display: none;
    }

    /* 停用過渡動畫（用於主題切換時避免 lag） */
    .no-transition,
    .no-transition * {
      transition: none !important;
    }

    /* 描述文字 */
    .desc {
      color: var(--muted);
      font-size: 14px;
      margin: 0 0 6px;
    }

    /* 空狀態提示 */
    .empty {
      color: var(--muted);
      padding: var(--space-md) 0;
    }

    /* 持續發光效果（用於高亮卡片、儲存按鈕等） */
    .glow-persistent {
      box-shadow: 0 0 0 4px rgba(106, 169, 255, 0.5), 0 0 12px rgba(106, 169, 255, 0.75);
      transition: box-shadow var(--duration-slow) ease;
    }

    /* SortableJS 拖放樣式 */
    .drag-ghost {
      opacity: 0.6;
      transform: scale(0.98);
    }

    .drag-chosen {
      outline: 2px dashed var(--accent);
    }

    .dragging {
      cursor: grabbing;
    }

    body.sorting #favGrid .card {
      cursor: grab;
    }

    /* Header 相對定位（用於下拉選單） */
    header {
      position: relative;
    }

    /* -----------------------------------------------------------------------------
       9.1 記憶遊戲頁面
       ----------------------------------------------------------------------------- */
    .cg-board {
      display: grid;
      grid-template-columns: repeat(4, 70px);
      grid-template-rows: repeat(4, 70px);
      gap: var(--space-sm);
      justify-content: center;
      margin: 12px auto;
      width: min(720px, 96%);
      padding: 12px;
      border-radius: var(--radius-lg);
      justify-items: center;
    }

    .cg-card {
      width: 70px;
      height: 70px;
      background: #888;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      perspective: 600px;
      will-change: transform;
      transition: transform var(--duration-normal) ease, box-shadow var(--duration-normal) ease;
      user-select: none;
    }

    .cg-card.matched {
      opacity: 0.5;
      pointer-events: none;
    }

    .cg-card-inner {
      width: 100%;
      height: 100%;
      transition: transform 0.4s cubic-bezier(.4, 2, .6, 1);
      transform-style: preserve-3d;
      position: relative;
    }

    .cg-card.flipped .cg-card-inner {
      transform: rotateY(180deg);
    }

    .cg-card-front,
    .cg-card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .cg-card-front {
      background: #888;
    }

    .cg-card:active,
    .cg-card.clicked {
      transform: scale(1.06);
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.28);
    }

    .cg-card-back {
      background: #fff;
      transform: rotateY(180deg);
      overflow: hidden;
    }

    .cg-card-back img {
      width: 80%;
      height: 80%;
      object-fit: contain;
      border-radius: var(--radius-sm);
    }

    .cg-lock {
      position: absolute;
      right: 6px;
      top: 6px;
      background: rgba(0, 0, 0, 0.4);
      color: white;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-pill);
      font-weight: 700;
      font-size: 14px;
    }

    .cg-header {
      display: flex;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
      margin: var(--space-xs) auto;
      padding: var(--space-sm) 12px;
      width: min(720px, 96%);
      border-radius: var(--radius-lg);
      position: sticky;
      top: 12px;
      z-index: 60;
      flex-wrap: wrap;
    }

    #cg-timer {
      font-size: 1.0rem;
      font-weight: 700;
      color: var(--fg);
      letter-spacing: 0.6px;
      min-width: 25px;
      text-align: left;
    }

    #cg-timer.cg-running {
      color: #34d399;
    }

    #cg-accuracy {
      color: var(--muted);
      font-weight: 600;
      margin-left: var(--space-sm);
    }

    .cg-stats {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      flex: 1 1 auto;
      min-width: 0;
    }

    .cg-controls {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      flex: 0 0 auto;
    }

    .cg-header button {
      margin-left: var(--space-sm);
      flex: 0 0 auto;
    }

    .cg-result {
      text-align: center;
      font-size: 1.05rem;
      border-radius: 14px;
      padding: 14px var(--space-lg);
      max-width: 480px;
      margin: 18px auto 0;
    }

    .cg-result h3 {
      margin: 0 0 6px;
      font-size: 1.15rem;
    }

    .cg-result .stats {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
      color: var(--muted);
      font-weight: 600;
    }

    .cg-result .big-num {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--fg);
    }

    .cg-rules {
      width: min(720px, 96%);
      margin: 14px auto 28px;
      border-radius: var(--radius-lg);
      padding: 12px var(--space-lg);
      color: var(--fg);
    }

    .cg-rules h4 {
      margin: 0 0 var(--space-sm);
      font-size: 1.05rem;
    }

    .cg-rules ul {
      margin: 0;
      padding-left: 18px;
      color: var(--muted);
    }

    /* 遊戲頁面響應式調整 */
    @media (max-width: 420px) {
      .cg-header {
        gap: var(--space-sm);
        padding: var(--space-sm);
      }

      #cg-timer {
        font-size: 1rem;
      }

      .cg-board {
        grid-template-columns: repeat(4, 56px);
        grid-template-rows: repeat(4, 56px);
        gap: var(--space-xs);
        padding: 10px;
      }

      .cg-card {
        width: 56px;
        height: 56px;
      }
    }

    /* -----------------------------------------------------------------------------
       9.2 票選結果頁面
       ----------------------------------------------------------------------------- */
    #page-awards .awards-grid {
      display: grid;
      gap: var(--space-xs);
      grid-template-columns: repeat(4, minmax(120px, 240px));
      align-items: center;
      justify-items: center;
      justify-content: center;
    }

    #page-awards .awards-grid img {
      width: 100%;
      height: auto;
      display: block;
      max-width: 100%;
      object-fit: cover;
    }

    #page-awards .grid .title {
      text-align: left;
    }

    @media (max-width: 700px) {
      #page-awards .awards-grid {
        grid-template-columns: repeat(2, minmax(120px, 240px));
        justify-content: center;
      }
    }

    /* =============================================================================
       10. demaPanel 多軌音訊編輯器
       ============================================================================= */

    /* -----------------------------------------------------------------------------
       10.1 面板容器
       ----------------------------------------------------------------------------- */
    .dema-panel {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 100;
      background: var(--glass-bg);
      border-top: 1px solid var(--glass-border);
      backdrop-filter: saturate(1.8) blur(16px);
      -webkit-backdrop-filter: saturate(1.8) blur(16px);
      box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.25);
      transform: translateY(100%);
      transition: transform var(--duration-slow) cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      max-height: 280px;
    }

    .dema-panel.open {
      transform: translateY(0);
    }

    /* -----------------------------------------------------------------------------
       10.2 控制列
       ----------------------------------------------------------------------------- */
    .dema-controls {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-xs) var(--space-sm);
      margin: var(--space-xs) var(--space-sm);
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap;
      min-height: 45px;
      position: relative;
    }

    .dema-controls--bottom {
      border-bottom: none;
      border-top: 1px solid var(--border);
      justify-content: center;
      min-height: 28px;
      padding: 4px var(--space-sm);
    }

    .dema-controls-left {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      z-index: 1;
    }

    .dema-controls-center {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .dema-controls-right {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-left: auto;
      z-index: 1;
    }

    .dema-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 28px;
      height: 28px;
      padding: 0 var(--space-xs);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--card);
      color: var(--fg);
      font-size: 12px;
      cursor: pointer;
      transition: all var(--duration-normal) ease;
    }

    .dema-btn:hover {
      background: var(--card-2);
      border-color: var(--accent);
    }

    .dema-btn:active {
      transform: scale(0.96);
    }

    .dema-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .dema-btn--icon {
      padding: 0;
      width: 28px;
    }

    .dema-btn--play {
      width: 32px;
      height: 32px;
      border-radius: var(--radius-pill);
      background: var(--accent);
      border-color: var(--accent);
      color: var(--chip-fg);
    }

    .dema-btn--play:hover {
      filter: brightness(1.1);
      border-color: var(--accent);
    }

    .dema-time {
      font-family: ui-monospace, 'SF Mono', monospace;
      font-size: 12px;
      color: var(--muted);
      min-width: 100px;
      text-align: center;
    }

    .dema-zoom-wrap,
    .dema-volume-wrap {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .dema-zoom-label,
    .dema-volume-label {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      width: 70px;
      text-align: right;
    }

    .dema-zoom-slider,
    .dema-volume-slider {
      width: 120px;
      flex: 0 0 120px;
      height: 4px;
      accent-color: var(--accent);
      margin: 0;
      cursor: pointer;
    }

    /* -----------------------------------------------------------------------------
       10.3 音軌區域
       ----------------------------------------------------------------------------- */
    .dema-tracks-wrap {
      flex: 1;
      overflow-x: scroll;
      overflow-y: hidden;
      position: relative;
      cursor: grab;
      /* 隱藏滾動軸 */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }

    .dema-tracks-wrap::-webkit-scrollbar {
      display: none; /* Chrome/Safari/Opera */
    }

    .dema-tracks-wrap.dragging {
      cursor: grabbing;
      user-select: none;
    }

    .dema-tracks-scroll {
      display: flex;
      flex-direction: column;
      min-width: 100%;
      position: relative;
    }

    /* 時間刻度尺 */
    .dema-timeline {
      height: 25px;
      background: var(--card-2);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 5;
    }

    .dema-timeline-canvas {
      width: 100%;
      height: 100%;
    }

    /* 單一音軌 */
    .dema-track {
      height: 35px;
      position: relative;
      border-bottom: 1px solid var(--border);
      background: var(--card);
    }

    .dema-track:nth-child(odd) {
      background: var(--card-2);
    }

    .dema-track-label {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      /* ⚠️ 重要：此值必須與以下保持一致（未來重構時需同步修改）：
         - .dema-track-content 的 left 值
         - JavaScript 常數 TRACK_LABEL_WIDTH
         - Timeline canvas 繪製的起始偏移
         - Playhead 定位的偏移 */
      width: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      background: inherit;
      border-right: 1px solid var(--border);
      z-index: 3;
    }

    .dema-track-content {
      position: absolute;
      /* ⚠️ 重要：必須等於 .dema-track-label 的 width（32px） */
      left: 32px;
      top: 0;
      right: 0;
      bottom: 0;
      overflow: visible;
    }

    /* -----------------------------------------------------------------------------
       10.4 音訊片段 (Clip)
       ----------------------------------------------------------------------------- */
    .dema-clip {
      position: absolute;
      top: 2px;
      height: calc(100% - 4px);
      min-width: 20px;
      border-radius: var(--radius-sm);
      cursor: grab;
      display: flex;
      align-items: center;
      overflow: hidden;
      box-shadow: var(--shadow-sm);
      border: 1px solid rgba(255, 255, 255, 0.15);
      transition: box-shadow var(--duration-normal) ease, transform var(--duration-fast) ease;
      user-select: none;
      touch-action: none;
    }

    .dema-clip:hover {
      box-shadow: var(--shadow-md);
      z-index: 10;
    }

    .dema-clip.selected {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
      z-index: 20;
    }

    .dema-clip.dragging {
      cursor: grabbing;
      opacity: 0.85;
      z-index: 30;
      transform: scale(1.02);
    }

    .dema-clip-label {
      position: relative;
      z-index: 1;
      padding: 0 4px;
      font-size: 15px;
      font-weight: 700;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans TC', 'Microsoft JhengHei', sans-serif;
      color: rgba(0, 0, 0, 0.6);
      text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    /* Trim handles */
    .dema-clip-handle {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 20px;
      cursor: ew-resize;
      z-index: 10;
      opacity: 0;
      transition: opacity var(--duration-normal) ease;
      background: transparent;
    }

    .dema-clip-handle::after {
      content: '';
      position: absolute;
      top: 4px;
      bottom: 4px;
      width: 4px;
      background: var(--accent);
      border-radius: 2px;
    }

    .dema-clip-handle--left {
      left: -8px;
    }

    .dema-clip-handle--left::after {
      left: 8px;
    }

    .dema-clip-handle--right {
      right: -8px;
    }

    .dema-clip-handle--right::after {
      right: 8px;
    }

    /* PC: hover 顯示 handle */
    .dema-clip:hover .dema-clip-handle {
      opacity: 1;
    }

    /* 移動端: 選中時顯示 handle */
    .dema-clip.selected .dema-clip-handle {
      opacity: 1;
    }

    /* 波型 Canvas */
    .dema-clip-wave {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .dema-clip-wave canvas {
      width: 100%;
      height: 100%;
      opacity: 0.9;
    }

    /* -----------------------------------------------------------------------------
       10.5 Playhead（播放頭）
       ----------------------------------------------------------------------------- */
    .dema-playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--accent-2);
      z-index: 50;
      pointer-events: none;
      transform: translateX(-1px);
    }

    .dema-playhead::before {
      content: '';
      position: absolute;
      top: -2px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 8px solid var(--accent-2);
    }

    /* -----------------------------------------------------------------------------
       10.6 空狀態
       ----------------------------------------------------------------------------- */
    .dema-empty {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 13px;
      pointer-events: none;
    }

    /* -----------------------------------------------------------------------------
       10.7 響應式調整
       ----------------------------------------------------------------------------- */
    @media (max-width: 600px) {
      .dema-panel {
        max-height: 260px;
      }

      .dema-controls {
        padding: var(--space-xs) var(--space-sm);
        gap: var(--space-sm) var(--space-xs);
      }

      /* 手機端：取消絕對定位，改為正常流式排版 */
      .dema-controls-center {
        position: static;
        transform: none;
        order: 1;
        flex-basis: 100%;
        justify-content: center;
        padding-top: 4px;
      }

      /* left 和 right 平分第一行 */
      .dema-controls-left,
      .dema-controls-right {
        flex: 1;
        min-width: 0;
      }

      .dema-controls-right {
        justify-content: flex-end;
      }

      .dema-time { display: none; }

      /* wrap 允許折行：滑桿一行，label 一行 */
      .dema-zoom-wrap,
      .dema-volume-wrap {
        flex-wrap: wrap;
        justify-content: center;
        gap: 2px;
      }

      /* 滑桿固定長度，不隨容器伸縮 */
      .dema-zoom-slider,
      .dema-volume-slider {
        width: 100px;
        flex: 0 0 100px;
      }

      /* 更小螢幕適配 */
      @media (max-width: 380px) {
        .dema-zoom-slider,
        .dema-volume-slider {
          width: 80px;
          flex: 0 0 80px;
        }
      }

      /* label 折到第二行置中 */
      .dema-zoom-label,
      .dema-volume-label {
        font-size: 10px;
        text-align: center;
        width: auto;
      }
    }

    @media (max-width: 400px) {
      /* 更小螢幕：滑桿加長 */
      .dema-zoom-slider,
      .dema-volume-slider {
        width: 100px;
      }
    }

    /* -----------------------------------------------------------------------------
       10.8 為面板開啟時調整頁面底部間距
       ----------------------------------------------------------------------------- */
    body.dema-open .stage {
      bottom: 220px;
    }

    body.dema-open .bg-credit {
      bottom: 230px;
    }

    /* 亮色主題微調 */
    :root.light .dema-clip {
      border-color: rgba(0, 0, 0, 0.1);
    }

    :root.light .dema-clip-label {
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <h1>阿萬與動物朋友按鈕2914</h1>
      <button id="navToggle" class="nav-toggle" aria-label="打開選單" aria-expanded="false" aria-controls="primaryNav"
        title="選單">
        <svg width="22" height="22" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M3 6h18M3 12h18M3 18h18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
        </svg>
      </button>

      <!-- 導覽分頁：放置於標題與主題切換按鈕之間，靠右排版 -->
      <nav id="primaryNav" class="tabs" role="tablist" aria-label="主選單">
        <button id="tab-home" class="tab active" data-page="home" role="tab" aria-selected="true"
          aria-controls="page-home">主頁</button>
        <button id="tab-game" class="tab" data-page="game" role="tab" aria-selected="false"
          aria-controls="page-game">小遊戲</button>
        <button id="tab-about" class="tab" data-page="about" role="tab" aria-selected="false"
          aria-controls="page-about">關於</button>
        <button id="tab-awards" class="tab" data-page="awards" role="tab" aria-selected="false"
          aria-controls="page-awards">票選結果</button>
        <button id="settingsBtn" class="tab" aria-label="開啟設定面板" aria-haspopup="dialog">設定</button>
      </nav>

    </header>

    <!-- 首頁內容：音效列表 -->
    <main id="page-home" role="tabpanel" aria-labelledby="tab-home">
      <!-- 三週年慶祝專區 -->
      <div id="anniversaryZone" class="anniversary-zone gradient-r1-background">
        <div class="anniversary-content">
          <!-- Row 1: 標題（點擊觸發彩帶特效） -->
          <div class="anniversary-row anniversary-title-row">
            <div id="anniversaryTitle" class="anniversary-title" role="button" aria-label="慶祝三週年">
              <div class="anniversary-text">這是什麼壓縮檔！點它！</div>
            </div>
          </div>

          <!-- Row 2: 壓縮檔圖示（點擊觸發解壓） -->
          <div id="anniversaryArchiveRow" class="anniversary-row anniversary-archive-row">
            <div id="anniversaryArchive" class="anniversary-archive" role="button" aria-label="解壓三週年音效包">
              <img src="assets/3rd.r1r.avif" alt="三週年音效包" class="archive-icon">
              <div class="archive-filename">厭世醫師阿萬3rd.r1r</div>
            </div>
          </div>

          <!-- Row 3: 解壓縮進度條 -->
          <div id="extractModal" class="anniversary-row extract-row" style="display: none;">
            <div class="extract-container">
              <div class="extract-title">正在解壓縮...</div>
              <div class="extract-progress-bar">
                <div id="extractProgressFill" class="extract-progress-fill"></div>
              </div>
              <div id="extractProgressText" class="extract-progress-text">0%</div>
            </div>
          </div>

          <!-- Row 4: 解壓後的音效區域 -->
          <div id="anniversarySoundsGrid" class="anniversary-sounds-grid" style="display: none;">
            <!-- 解壓後的音效會動態插入這裡 -->
          </div>
        </div>
      </div>
      <!-- 搜尋列（獨立成 row） -->
      <div class="search-row">
        <div class="searchbar" role="search">
          <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
            <path fill="currentColor"
              d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16a6.471 6.471 0 0 0 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14" />
          </svg>
          <input id="q" placeholder="搜尋標題或 #標籤（可多個，用空白分隔）" autocomplete="off" aria-label="搜尋音效" />
          <div id="activeChips" class="chips" role="list" aria-label="已選取的搜尋標籤"></div>
        </div>
        <button id="clearBtn" class="btn" aria-label="清除搜尋">清除</button>
      </div>
      <!-- 標籤一覽 -->
      <div id="tagList" class="tag-list" role="list" aria-label="可點選的音效標籤"></div>
      <!-- 最愛區 -->
      <section aria-labelledby="fav-section-title">
        <div class="section-header">
          <h3 id="fav-section-title">最愛音效</h3>
          <div class="actions">
            <button id="sortFavBtn" class="btn small-btn" aria-label="開啟手動排列模式">手動排列</button>
            <button id="doneSortBtn" class="btn small-btn glow-persistent hidden" aria-label="儲存目前排列順序">儲存排列</button>
            <button id="shareFavBtn" class="btn small-btn" aria-label="分享最愛列表">分享</button>
          </div>
        </div>
        <div id="favGrid" class="grid" role="list" aria-label="最愛音效列表"></div>
        <div id="favEmpty" class="empty hidden" role="status">還沒有最愛。點音效右上的 ❤️ 加入最愛。</div>
      </section>
      <!-- 收到的列表：僅當 URL 包含 list 參數時顯示 -->
      <section id="receivedSection" class="hidden" aria-labelledby="received-section-title">
        <div id="receivedHeader" class="section-header">
          <h3 id="received-section-title">收到的列表</h3>
        </div>
        <div id="receivedGrid" class="grid" role="list" aria-label="收到的音效列表"></div>
      </section>
      <!-- 全部音效 -->
      <section aria-labelledby="all-sounds-title">
        <div class="section-header">
          <h3 id="all-sounds-title">全部音效</h3>
          <div class="actions">
            <button id="openDemaBtn" class="btn small-btn" aria-label="開啟多軌混音編輯器">混音</button>
            <button id="shuffleBtn" class="btn small-btn" aria-label="隨機排列音效順序">洗牌</button>
            <button id="resetOrderBtn" class="btn small-btn" aria-label="恢復預設排列順序">預設順序</button>
          </div>
        </div>
        <p class="desc">提示：點音效即可播放；右鍵（或行動裝置長按）可分享/下載。</p>
        <div id="grid" class="grid" role="list" aria-label="全部音效列表"></div>
        <div id="empty" class="empty hidden" role="status">沒有符合搜尋的音效。</div>
      </section>
    </main>
    <!-- 小遊戲分頁 -->
    <div id="page-game" class="hidden" role="tabpanel" aria-labelledby="tab-game">
      <div id="concentration-game" role="application" aria-label="記憶小遊戲">
        <div class="cg-header">
          <div class="cg-stats" aria-live="polite">
            <span id="cg-timer" aria-label="遊戲時間">00:00</span>
            <span id="cg-accuracy" aria-label="準確率">準確率：--%</span>
          </div>
          <div class="cg-controls">
            <button id="cg-restart" class="btn small-btn" aria-label="重新開始遊戲">重開一局</button>
          </div>
        </div>
        <div id="cg-board" class="cg-board" role="grid" aria-label="記憶卡牌面板"></div>
        <div id="cg-result" class="cg-result hidden" role="alert" aria-live="assertive"></div>
        <!-- 規則說明卡：與其他遊戲區塊同寬並置於下方 -->
        <div id="cg-rules" class="cg-rules" aria-labelledby="cg-rules-title">
          <h4 id="cg-rules-title">記憶小遊戲規則</h4>
          <ul>
            <li>第一次翻開的牌不對計分造成影響，屬於記憶提示。</li>
            <li>每翻開兩張卡，若為相同主播的相同音效即為配對，共有 8 對配對。</li>
            <li>（不會出現帶有「髒話」或「SUS」標籤的語音，但是會有尖叫，請小心耳膜。）</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- 關於分頁 -->
    <div id="page-about" class="hidden" role="tabpanel" aria-labelledby="tab-about">
      <div class="about-content">
        <p>本站由粉肝製作，並非由厭世醫師阿萬官方經營。音效內容皆是粉肝去脈絡式、斷章取義的剪輯，僅供娛樂。本站的音效皆屬於原作者厭世醫師阿萬，使用時須遵守厭世醫師阿萬的二次創作條例。</p>
        <p>最後更新時間：2025/12/24。</p>

        <p>阿萬本家→ <a href="https://x.com/drlifesucks" target="_blank">厭世醫師阿萬X</a>、<a
            href="https://www.youtube.com/@Dr.lifesucks" target="_blank">厭世醫師阿萬Youtube</a> </p>
        <p><a href="https://discord.gg/e6ch4VbRB4" target="_blank">音效板問題回報與建議區</a></p>
        <p>SNS Hashtag：#萬籟聚集</p>
        <img src="assets/art-by-sigh.png" alt=""
          style="margin: 0 auto; max-width:100%; max-height: 250px; display: block; object-fit: cover;" />
        <p style="text-align: right;">插畫：<a href="https://x.com/sigh121212" target="_blank">Minie(Sigh)</a></p>
        <h2>大德芳名錄</h2>
        <p>感謝53、Kie在DC弄了一堆音效，讓南想到可以做這個網站，並在提出這個想法的一開始就弄了一堆音效過來。還有同樣感謝在原型階段就幫忙收集音效的米糕跟薰薰草。
          <br />感謝Jia繪製超可愛的頭貼、背景圖以及收集音效。
          <br />
          <br />感謝粉肝們收集很多音效，豐富了這個網站（Word筆劃順）：
          <br />AmBinBong、Ame、CZ、HUI、Lococco de
          suzuran、MOSS、Nokimi07、Sigh、TENN、Yichen沉沉、🌙🐰月桂葉香包♏🎵、布丁(25:00)、米粉肉干、幸福柴柴、青末枝、食甜張、凌伊LingYi（01）、夏白衫、貓貓雨、ヤキィ。
          以及其他回報問題、提出建議的粉肝們，你們讓這個網站的功能更完善。
        </p>
      </div>
      <div class="bg-credit"><a href="https://x.com/jiauwu_0730" target="_blank" rel="noopener">頭貼背景插畫由 Jia 繪製</a></div>

    </div>

    <!-- 票選結果分頁 -->
    <div id="page-awards" class="hidden" role="tabpanel" aria-labelledby="tab-awards">
      <div style="max-width:1100px;margin:0 auto;padding:18px;">
        <h2 style="text-align:center">第一屆音效板爭霸戰</h2>
        <div style="text-align:center;margin:12px 0">
          <div class="awards-grid" role="img" aria-label="第一屆獲獎者圖片">
            <img src="assets/award1-1.jpg" alt="第一屆貓下去" />
            <img src="assets/award1-2.jpg" alt="第一屆Matsuko" />
            <img src="assets/award1-3.jpg" alt="第一屆豹子頭" />
            <img src="assets/award1-4.jpg" alt="第一屆瓦哈" />
          </div>
          <h3 id="awards-top10-title">獲獎區（前十名）</h3>
          <div id="awards-top10" class="grid" role="list" aria-labelledby="awards-top10-title"></div>
          <h3 id="awards-next20-title" style="margin-top:18px">入圍獎（後20名）</h3>
          <div id="awards-next20" class="grid" role="list" aria-labelledby="awards-next20-title"></div>
        </div>
      </div>
    </div>

    <!-- 設定 Modal（站內所有設定：音量 / 主題開關 等） -->
    <div id="settingsModal" class="modal-backdrop hidden" role="dialog" aria-modal="true"
      aria-labelledby="settingsTitle">
      <div class="modal">
        <h3 id="settingsTitle" style="margin-top: 0px;margin-bottom: 12px;">設定</h3>
        <div style="display:flex;flex-direction:column;gap:8px;">
          <button id="themeBtn" class="btn" type="button" aria-label="切換亮色/暗色主題">電燈開關</button>
          <label for="settingsVolume">播放音量： <span id="settingsVolumeValue" aria-live="polite">100%</span></label>
          <input id="settingsVolume" type="range" min="0" max="300" step="1" value="100"
            aria-describedby="settingsVolumeValue" />
          <div style="display:flex;justify-content:flex-end;margin-top:6px;gap:8px;">
            <button id="settingsClose" class="btn" type="button" aria-label="關閉設定面板">關閉</button>
          </div>
        </div>
      </div>
    </div>

    <!-- 播放彩蛋舞台 -->
    <div id="stage" class="stage" aria-hidden="true"></div>
    <!-- 右鍵/長按選單 -->
    <div id="menu" class="menu hidden" role="menu" aria-label="音效選單"></div>
    <!-- Toast提示 -->
    <div id="toast" class="toast hidden" role="status" aria-live="polite"></div>

    <!-- demaPanel 多軌混音面板 -->
    <div id="demaPanel" class="dema-panel" role="dialog" aria-label="多軌混音編輯器" aria-hidden="true">
      <!-- 控制列 -->
      <div class="dema-controls">
        <div class="dema-controls-left">
          <div class="dema-volume-wrap" id="demaClipVolumeWrap" style="display: none;">
            <input id="demaClipVolume" type="range" class="dema-volume-slider" min="0" max="150" value="100" step="5">
            <span class="dema-volume-label">片段音量 <span id="demaClipVolumeValue">100%</span></span>
          </div>
        </div>
        <div class="dema-controls-center">
          <button id="demaSkipBack" class="dema-btn dema-btn--icon" title="回到片段開頭">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6 8.5 6V6z"/></svg>
          </button>
          <button id="demaPlayPause" class="dema-btn dema-btn--play" title="播放/暫停">
            <svg id="demaPlayIcon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
            <svg id="demaPauseIcon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="display:none"><path d="M6 4h4v16H6zM14 4h4v16h-4z"/></svg>
          </button>
          <button id="demaSkipNext" class="dema-btn dema-btn--icon" title="跳到下個片段">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
          </button>
        </div>
        <div class="dema-controls-right">
          <div class="dema-zoom-wrap">
            <span class="dema-zoom-label">時間軸縮放</span>
            <input id="demaZoom" type="range" class="dema-zoom-slider" min="50" max="800" value="200" step="10">
          </div>
        </div>
      </div>
      <!-- 音軌區域 -->
      <div class="dema-tracks-wrap">
        <div id="demaTracksScroll" class="dema-tracks-scroll">
          <!-- 時間刻度尺 -->
          <div class="dema-timeline">
            <canvas id="demaTimelineCanvas" class="dema-timeline-canvas"></canvas>
          </div>
          <!-- 音軌 1 -->
          <div class="dema-track" data-track="0">
            <div class="dema-track-label">1</div>
            <div class="dema-track-content" data-track-content="0"></div>
          </div>
          <!-- 音軌 2 -->
          <div class="dema-track" data-track="1">
            <div class="dema-track-label">2</div>
            <div class="dema-track-content" data-track-content="1"></div>
          </div>
          <!-- 音軌 3 -->
          <div class="dema-track" data-track="2">
            <div class="dema-track-label">3</div>
            <div class="dema-track-content" data-track-content="2"></div>
          </div>
          <!-- Playhead -->
          <div id="demaPlayhead" class="dema-playhead" style="left: 32px;"></div>
        </div>
        <!-- 空狀態提示 -->
        <div id="demaEmpty" class="dema-empty">右鍵點擊音效卡片，選擇「加到音軌」來開始混音</div>
      </div>
      <!-- 底部控制列 -->
      <div class="dema-controls dema-controls--bottom">
        <div class="dema-controls-left">
          <button id="demaUndo" class="dema-btn dema-btn--icon" title="復原 (Ctrl+Z)" disabled>
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 10h10a5 5 0 0 1 5 5v2M3 10l5-5M3 10l5 5"/></svg>
          </button>
          <button id="demaRedo" class="dema-btn dema-btn--icon" title="重做 (Ctrl+Y)" disabled>
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10H11a5 5 0 0 0-5 5v2M21 10l-5-5M21 10l-5 5"/></svg>
          </button>
          <button id="demaClear" class="dema-btn" title="重置所有音軌與步驟紀錄">重置</button>
          <button id="demaRemoveSelected" class="dema-btn" title="移除選取的片段 (Delete)" disabled>移除選擇</button>
        </div>
        <div class="dema-controls-center">
          <span id="demaTime" class="dema-time">00:00.00 / 00:00.00</span>
        </div>
        <div class="dema-controls-right">
          <button id="demaClose" class="dema-btn dema-btn--icon" title="關閉面板">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6 6 18M6 6l12 12"/></svg>
          </button>
        </div>
      </div>
    </div>

    <script src="scripts/Sortable.min.js"></script>
    <script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>

    <script>
      /**
       * =============================================================================
       * 阿萬與動物朋友按鈕 - 主應用程式
       * =============================================================================
       * 
       * 單檔案應用架構，使用 IIFE 模式封裝以避免全域命名空間污染。
       * 主要功能：音效搜尋與播放、最愛收藏、記憶小遊戲、多軌混音編輯。
       * 
       * 相依套件：
       * - SortableJS：最愛排序拖放功能
       * 
       * 模組結構索引：
       * 1. 常數與設定
       * 2. 工具函式
       * 3. DOM 元素引用
       * 4. 應用程式狀態
       * 5. 音頻播放核心
       * 6. DOM 建構工具
       * 7. 通用工具函式
       * 8. 路由與 URL 管理
       * 9. UI 互動與事件處理
       * 10. UI 渲染函式
       * 11. 初始化流程
       * 12. 記憶小遊戲
       * 13. demaPanel 多軌混音編輯器
       * =============================================================================
       */
      (function () {
        'use strict';

        /* =======================================================================
           1. 常數與設定
           ======================================================================= */

        /**
         * 檔案版本字串：每次部署變更此值，可確保抓取最新資料並強制 CDN/瀏覽器重新載入。
         * @const {string}
         */
        const VERSION = 'ver2025-12-24';

        /**
         * 應用程式設定：集中管理可調整的設定值。
         * @const {Object}
         */
        const CONFIG = {
          // 資料來源路徑
          paths: {
            tags: 'config/tags.json',
            sounds: 'config/sounds.json',
            voteResults: 'config/vote-results.json'
          },

          // localStorage 鍵名
          storage: {
            favorites: 'favorites',
            favoritesVersion: 'favorites_version',
            favoritesBackup: 'favorites_legacy_backup',
            theme: 'theme',
            globalVolume: 'globalVolume'
          },

          // UI 時間設定（毫秒）
          timing: {
            toastDuration: 2500,           // Toast 顯示時長
            longPressDelay: 400,           // 長按觸發選單延遲
            searchDebounce: 180,           // 搜尋防抖延遲
            animationDelay: 60,            // 頭像動畫延遲間隔
            hopOutDelay: 90                // 頭像離場動畫延遲
          },

          // UI 渲染設定
          ui: {
            batchSize: 72                  // 每次渲染的卡片數量 (6欄 x 12列)
          },

          // 票選相關
          awards: {
            topRankCount: 30,              // 讀取前 N 名
            top10Count: 10,                // 顯示為前 10 名
            next20Count: 20                // 顯示為入圍獎
          },

          // 記憶遊戲相關
          game: {
            pairCount: 8,                  // 配對數量
            cardFlipDelay: 500,            // 翻牌檢查延遲
            rewardAccuracy: 90,            // 觸發獎勵的準確率門檻
            rewardSoundIds: ['c4B1fg', 'Hv3yFA', 'JkJ9-A', '5VHtAg']
          },

          // 預設顏色
          colors: {
            defaultTag: '#94a3b8'          // 預設標籤色
          },

          // 全域音量設定
          // 注意：HTML Audio 元素的 volume 屬性範圍為 0~1，超過 100% 需使用 Web Audio API 的 GainNode
          volume: {
            default: 1.0,                   // 預設音量（1.0 = 100%）
            max: 3.0                        // 最大音量
          }
        };

        /**
         * UI 訊息文字：集中管理顯示給使用者的文字。
         * @const {Object}
         */
        const MESSAGES = {
          // Toast 訊息
          toast: {
            linkCopied: '已複製分享連結',
            listLinkCopied: '已複製分享最愛列表連結',
            noFavorites: '沒有最愛可分享',
            sortingSaved: '已儲存最愛排序',
            sortingBlocked: '正在編輯最愛排序，無法變更最愛',
            favMigrated: (count, missing) => `已升級最愛格式，共 ${count} 筆${missing ? `；未匹配 ${missing} 筆` : ''}。`,
            gameReward: '你是記憶猛肝'
          },

          // 錯誤訊息
          errors: {
            configLoadFailed: '載入設定檔失敗，請確認 <code>config/</code> 路徑是否正確。',
            gameNoSounds: '目前沒有足夠的音效可供配對（需至少 1 組）。請回到主頁或稍後再試。'
          },

          // 空狀態提示
          empty: {
            noFavorites: '還沒有最愛。點音效右上的 ❤️ 加入最愛。',
            noResults: '沒有符合搜尋的音效。'
          }
        };

        /* =======================================================================
           2. 工具函式
           ======================================================================= */

        /** 為 URL 附加版本字串 */
        const withV = url => url + (url.includes('?') ? '&' : '?') + 'v=' + encodeURIComponent(VERSION);

        /** Fisher-Yates 洗牌演算法 */
        function shuffleInPlace(arr, rng = Math.random) {
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(rng() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr;
        }

        /* =======================================================================
           3. DOM 元素引用
           ======================================================================= */

        /** DOM 元素快取物件 */
        const els = {
          q: document.getElementById('q'),
          activeChips: document.getElementById('activeChips'),
          clearBtn: document.getElementById('clearBtn'),
          tagList: document.getElementById('tagList'),
          grid: document.getElementById('grid'),
          favGrid: document.getElementById('favGrid'),
          empty: document.getElementById('empty'),
          favEmpty: document.getElementById('favEmpty'),
          settingsBtn: document.getElementById('settingsBtn'),
          themeBtn: document.getElementById('themeBtn'),
          stage: document.getElementById('stage'),
          navToggle: document.getElementById('navToggle'),
          get menu() { return document.getElementById('menu'); },
          get toast() { return document.getElementById('toast'); },
          get navTabs() { return document.querySelectorAll('.tab[data-page]'); },
          // 分頁與設定
          pageHome: document.getElementById('page-home'),
          pageGame: document.getElementById('page-game'),
          pageAbout: document.getElementById('page-about'),
          pageawards: document.getElementById('page-awards'),
          settingsModal: document.getElementById('settingsModal'),
          settingsClose: document.getElementById('settingsClose'),
          settingsVolume: document.getElementById('settingsVolume'),
          settingsVolumeValue: document.getElementById('settingsVolumeValue'),
          receivedSection: document.getElementById('receivedSection'),
          receivedGrid: document.getElementById('receivedGrid'),
          awardsTop10: document.getElementById('awards-top10'),
          awardsNext20: document.getElementById('awards-next20'),
          sortFavBtn: document.getElementById('sortFavBtn'),
          doneSortBtn: document.getElementById('doneSortBtn'),
          shareFavBtn: document.getElementById('shareFavBtn'),
          shuffleBtn: document.getElementById('shuffleBtn'),
          resetOrderBtn: document.getElementById('resetOrderBtn'),
          openDemaBtn: document.getElementById('openDemaBtn'),
          // demaPanel 元素
          demaPanel: document.getElementById('demaPanel'),
          demaUndo: document.getElementById('demaUndo'),
          demaRedo: document.getElementById('demaRedo'),
          demaPlayPause: document.getElementById('demaPlayPause'),
          demaPlayIcon: document.getElementById('demaPlayIcon'),
          demaPauseIcon: document.getElementById('demaPauseIcon'),
          demaSkipBack: document.getElementById('demaSkipBack'),
          demaSkipNext: document.getElementById('demaSkipNext'),
          demaTime: document.getElementById('demaTime'),
          demaZoom: document.getElementById('demaZoom'),
          demaClear: document.getElementById('demaClear'),
          demaRemoveSelected: document.getElementById('demaRemoveSelected'),
          demaClose: document.getElementById('demaClose'),
          demaTracksScroll: document.getElementById('demaTracksScroll'),
          demaTimelineCanvas: document.getElementById('demaTimelineCanvas'),
          demaPlayhead: document.getElementById('demaPlayhead'),
          demaEmpty: document.getElementById('demaEmpty'),
          get demaTrackContents() { return document.querySelectorAll('[data-track-content]'); },
          // 片段音量控制
          demaClipVolumeWrap: document.getElementById('demaClipVolumeWrap'),
          demaClipVolume: document.getElementById('demaClipVolume'),
          demaClipVolumeValue: document.getElementById('demaClipVolumeValue')
        };

        /* =======================================================================
           4. 應用程式狀態
           ======================================================================= */

        /** 全域應用程式狀態物件 */
        const state = {
          tags: {},
          tagList: [],
          usedTagList: [],
          sounds: [],
          soundMap: new Map(),
          defaultSoundsSnapshot: [],
          favorites: JSON.parse(localStorage.getItem(CONFIG.storage.favorites) || '[]'),
          favSet: new Set(),
          isSorting: false,
          sortable: null,
          queryText: '',
          queryTags: new Set(),
          page: 'home',
          contextTimer: null,
          toastTimer: null,
          highlightedCardId: '',
          receivedList: [],
          cgRunning: false,
          // 虛擬滾動/分批渲染狀態
          displayList: [],
          renderedCount: 0,
          observer: null
        };

        state.favSet = new Set(state.favorites);
        /**
         * 從 localStorage 讀取全域音量設定
         * 數值範圍：0 ~ CONFIG.volume.max (每1.0等於100%)
         * 若無有效值則使用 CONFIG.volume.default（預設 1.0 = 100%）
         */
        state.globalVolume = (() => {
          const v = localStorage.getItem(CONFIG.storage.globalVolume);
          const n = Number(v);
          const max = CONFIG.volume.max;
          return (v !== null && !isNaN(n) && n >= 0 && n <= max) ? n : CONFIG.volume.default;
        })();

        let cgCleanup = null;

        /* =======================================================================
           5. 音頻播放核心
           
           注意：HTML5 Audio 的 volume 屬性範圍為 0~1，無法實現超過 100% 的音量。
           為了支援最高的音量放大，需使用 Web Audio API 的 GainNode。
           ======================================================================= */

        /**
         * 共用的 AudioContext（延遲初始化，避免自動播放政策問題）
         * @type {AudioContext|null}
         */
        let sharedAudioContext = null;

        /**
         * 取得或建立共用的 AudioContext
         * @returns {AudioContext}
         */
        const getSharedAudioContext = () => {
          if (!sharedAudioContext) {
            sharedAudioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          if (sharedAudioContext.state === 'suspended') {
            sharedAudioContext.resume();
          }
          return sharedAudioContext;
        };

        /**
         * 將全域音量設定套用到 Audio 元素
         * 使用 Web Audio API 的 GainNode 以支援超過 100% 的音量
         * @param {HTMLAudioElement} audio - 音訊元素
         * @returns {GainNode|null} - 回傳建立的 GainNode 供後續調整
         */
        const applyVolumeToAudio = (audio) => {
          if (!audio) return null;
          try {
            const ctx = getSharedAudioContext();
            // 建立 MediaElementSource（注意：同一 audio 只能建立一次）
            if (!audio._sourceNode) {
              const source = ctx.createMediaElementSource(audio);
              const gainNode = ctx.createGain();
              source.connect(gainNode);
              gainNode.connect(ctx.destination);
              audio._sourceNode = source;
              audio._gainNode = gainNode;
            }
            // 套用全域音量（可超過 1.0）
            if (audio._gainNode) {
              audio._gainNode.gain.value = state.globalVolume;
            }
            return audio._gainNode;
          } catch (e) {
            console.warn('[applyVolumeToAudio] 設定音量失敗，fallback 到原生 volume', e);
            // Fallback：使用原生 volume（限制在 0~1）
            audio.volume = Math.min(1, state.globalVolume);
            return null;
          }
        };

        /** 建立 Audio 播放器並啟動播放 */
        function createPlayer(src, opts = {}) {
          const { snd, onPlay, onEnded, preload = 'auto', loop = false, autoplay = true } = opts;
          try {
            const audio = new Audio(src);
            Object.assign(audio, { preload, loop });
            onPlay && audio.addEventListener('play', () => onPlay(snd, audio));
            onEnded && audio.addEventListener('ended', () => onEnded(snd, audio));
            applyVolumeToAudio(audio);
            // 自動播放可能被瀏覽器政策阻擋（如無使用者互動），靜默處理
            autoplay && audio.play().catch(() => { /* 預期行為：瀏覽器自動播放政策 */ });
            return audio;
          } catch (e) {
            console.warn('[createPlayer] failed', e);
            return null;
          }
        }

        /** 以 Sound 物件播放音效，同時觸發舞台頭像動畫 */
        const playSoundObject = snd => snd?.src ? createPlayer(snd.src, { snd, onPlay: onPlayStart, onEnded: onPlayEnd }) : null;

        /* =======================================================================
           6. DOM 建構工具
           ======================================================================= */

        /**
         * DOM 元素建構工具集
         */
        const dom = {
          /**
           * 建立 DOM 元素。
           * @param {string} tag - 標籤名稱
           * @param {Object} attrs - 屬性物件
           * @param {Array|string} children - 子節點
           * @returns {HTMLElement}
           */
          el(tag, attrs = {}, children = []) {
            const e = document.createElement(tag);
            for (const [k, v] of Object.entries(attrs)) {
              if (k === 'class') e.className = v;
              else if (k === 'style') Object.assign(e.style, v);
              else if (k.startsWith('on') && typeof v === 'function') e.addEventListener(k.slice(2), v);
              else if (v != null) e.setAttribute(k, v);
            }
            for (const c of [].concat(children).filter(Boolean)) {
              e.append(c);
            }
            return e;
          },

          /** 建立愛心 SVG 圖示 */
          svgHeart() {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.innerHTML = '<path d="M12 21s-6.716-4.438-9.428-7.15C.59 11.868.59 8.608 2.57 6.627 4.55 4.647 7.81 4.647 9.79 6.627L12 8.838l2.21-2.21c1.98-1.98 5.24-1.98 7.22 0 1.98 1.98 1.98 5.24 0 7.223C18.716 16.562 12 21 12 21z" fill="none" stroke="currentColor" stroke-width="1.5"/>';
            return svg;
          }
        };

        /* =======================================================================
           7. 通用工具函式
           ======================================================================= */

        /**
         * 通用工具函式集合
         */
        const utils = {
          /** 正規化字串：Unicode NFKC */
          slug: s => s.normalize('NFKC').trim(),

          /** 根據 ID 取得 DOM 元素 */
          byId: id => document.getElementById(id),

          /** 儲存最愛列表到 localStorage */
          saveFav: () => localStorage.setItem(CONFIG.storage.favorites, JSON.stringify(state.favorites)),

          /** 檢查音效是否在最愛列表中 */
          inFav: id => state.favSet.has(id),

          /** 觸發檔案下載 */
          download(url, filename) {
            const a = Object.assign(document.createElement('a'), { href: url, download: filename || '' });
            document.body.appendChild(a);
            a.click();
            a.remove();
          },

          /**
           * 解析搜尋查詢字串為結構化物件。
           * 
           * @returns {Object} { terms: Array<string>, tags: Set<string> }
           */
          parseQuery() {
            const parts = state.queryText.trim().split(/\s+/).filter(Boolean);
            const tags = new Set([...state.queryTags]); // 保留已選標籤
            const terms = [];
            for (const p of parts) {
              if (p.startsWith('#')) {
                // 提取 #符號後的標籤 key，並 slug 化
                tags.add(utils.slug(p.slice(1)));
              } else {
                // 一般搜尋詞
                terms.push(utils.slug(p));
              }
            }
            return { terms, tags };
          },

          /**
           * 判斷單個音效是否符合搜尋條件。
           * 
           * 規則：
           * 1. tags 過濾：音效必須包含所有已選標籤（subset check）
           * 2. text 過濾：音效標題或標籤必須包含所有搜尋詞（case-insensitive）
           * 
           * @param {Object} sound - 音效物件
           * @param {Array<string>} terms - 搜尋詞陣列（已提取的文字部份）
           * @param {Set<string>} tags - 已選標籤的 key（已 slug 化）
           * @returns {boolean} 是否符合條件
           */
          match(sound, terms, tags) {
            const lowerTitle = sound.title.toLowerCase();
            const sluggedTags = sound.tags.map(t => utils.slug(t));
            // tags 過濾：檢查所有已選標籤是否都在音效的標籤清單中
            for (const t of tags) if (!sluggedTags.includes(t)) return false;
            // terms 過濾：檢查所有搜尋詞是否都能在標題或標籤中找到
            for (const term of terms) {
              const lower = term.toLowerCase();
              if (!lowerTitle.includes(lower) && !sound.tags.some(t => t.toLowerCase().includes(lower))) return false;
            }
            return true;
          },

          /** 建立防抖函式 */
          debounce(fn, wait = 200) {
            let t;
            return (...args) => {
              clearTimeout(t);
              t = setTimeout(() => fn(...args), wait);
            };
          }
        };

        /* =======================================================================
           8. 路由與 URL 管理
           
           處理瀏覽器歷史、深連結分享、搜尋條件同步。
           ======================================================================= */

        /**
         * 將當前搜尋條件封裝為 URLSearchParams。
         * @returns {URLSearchParams}
         */
        function buildSearchParams() {
          const { terms, tags } = utils.parseQuery();
          const params = new URLSearchParams(window.location.search);
          if (terms.length) params.set('q', terms.join(' ')); else params.delete('q');
          if (tags.size) params.set('tags', [...tags].join(',')); else params.delete('tags');
          params.delete('sound'); // 修改搜尋時清除音效深連結
          return params;
        }

        /**
         * 將狀態寫回 URL。
         * @param {boolean} push - 若為 true 則使用 history.pushState，否則使用 replaceState
         */
        function updateURLFromState(push = false) {
          const params = buildSearchParams();
          // 保留 list 參數（分享收到的列表）若存在
          const current = new URLSearchParams(location.search);
          if (current.has('list')) params.set('list', current.get('list'));
          // 保留 sound 參數以確保分享連結正常運作
          if (current.has('sound')) params.set('sound', current.get('sound'));
          // 加上 page 參數（非首頁才寫入）
          if (state.page && state.page !== 'home') params.set('page', state.page); else params.delete('page');
          const qs = params.toString();
          const url = `${location.pathname}${qs ? '?' + qs : ''}`;
          (push ? history.pushState : history.replaceState).call(history, null, '', url);
        }

        /**
         * 從現有 URL 讀取搜尋條件並套用到狀態與輸入框。
         */
        function applyURLToState() {
          const params = new URLSearchParams(location.search);
          const q = params.get('q') || '';
          const tagsParam = params.get('tags') || '';
          state.queryTags.clear();
          const keys = tagsParam.split(',').map(k => utils.slug(k)).filter(Boolean);
          keys.forEach(k => state.queryTags.add(k));
          state.queryText = q;
          // 同步輸入框文字
          const tagTokens = keys.map(k => '#' + (state.tags[k]?.name || k));
          els.q.value = [q, ...tagTokens].filter(Boolean).join(' ');
          // 分頁：讀取 page 參數
          const pageParam = params.get('page');
          state.page = ['game', 'about', 'awards'].includes(pageParam) ? pageParam : 'home';
          // 分享列表：讀取 list 參數
          state.receivedList = params.get('list')?.split(',').filter(Boolean) ?? [];
        }

        /**
         * 若 URL 有 ?sound=<id>，則聚焦並高亮該卡片。
         */
        function focusSoundFromURL() {
          const id = new URLSearchParams(location.search).get('sound');
          if (!id) return;
          const card = utils.byId('snd-' + id);
          if (!card) return;
          card.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // 移除舊的高亮
          if (state.highlightedCardId) utils.byId('snd-' + state.highlightedCardId)?.classList.remove('glow-persistent');
          state.highlightedCardId = id;
          card.classList.add('glow-persistent');
        }

        // popstate 事件：返回/前進時載入 URL 條件
        window.addEventListener('popstate', () => {
          applyURLToState();
          render();
          focusSoundFromURL();
        });

        /** 建立僅包含 sound id 的分享連結 */
        function buildSoundURL(id) {
          const base = location.href.replace(/[?#].*$/, '');
          return `${base}?sound=${encodeURIComponent(id)}`;
        }

        /** 建立分享列表的 URL：加入 list 參數，使用逗號分隔的 id 列表。 */
        function buildListURL(ids) {
          const params = buildSearchParams();
          ids?.length ? params.set('list', ids.join(',')) : params.delete('list');
          params.delete('sound');
          const qs = params.toString();
          return `${location.origin}${location.pathname}${qs ? '?' + qs : ''}`;
        }

        /* =======================================================================
           9. UI 互動與事件處理
           
           頁面切換、選單操作、主題切換、使用者互動。
           ======================================================================= */

        /** 根據 ID 播放音效 */
        const playSoundById = id => { const snd = state.soundMap.get(id); snd && playSoundObject(snd); };

        /**
         * 切換頁面：根據 page 名稱顯示不同內容，並更新網址參數與導覽樣式
         * @param {'home'|'game'|'about'} pg
         */
        const pageMap = { home: 'pageHome', game: 'pageGame', about: 'pageAbout', awards: 'pageawards' };
        /** 觸發頁面切換事件 */
        const dispatchPageEvent = (pg, prevPage, phase) => {
          try {
            document.dispatchEvent(new CustomEvent('pageChange', { detail: { page: pg, prevPage, phase } }));
          } catch (e) {
            console.warn('[dispatchPageEvent] 事件派發失敗', e);
          }
        };
        function showPage(pg) {
          const prevPage = state.page;
          dispatchPageEvent(pg, prevPage, 'before');
          state.page = pg;
          // 隱藏所有分頁，顯示目標分頁
          for (const [key, elKey] of Object.entries(pageMap)) els[elKey]?.classList.toggle('hidden', key !== pg);
          // 更新導覽標籤 active 樣式與 ARIA 狀態
          els.navTabs.forEach(tab => {
            const isActive = tab.getAttribute('data-page') === pg;
            tab.classList.toggle('active', isActive);
            if (tab.getAttribute('role') === 'tab') tab.setAttribute('aria-selected', String(isActive));
          });
          document.body.classList.toggle('bg-full', pg === 'about');
          document.body.classList.remove('nav-open');
          els.navToggle?.setAttribute('aria-expanded', 'false');
          updateURLFromState(true);
          dispatchPageEvent(pg, prevPage, 'after');
        }

        /**
         * 渲染標籤一覽：列出所有使用到的標籤
         */
        function renderTagList() {
          const container = els.tagList;
          if (!container) return;
          container.innerHTML = '';
          state.usedTagList.forEach(t => {
            const el = dom.el('span', { class: 'tag', style: { background: t.color || '#94a3b8' } }, t.name);
            el.addEventListener('click', () => addTagToQuery(t.key));
            container.appendChild(el);
          });
        }

        /** 複製文字到剪貼簿 */
        const copyToClipboard = text => navigator.clipboard?.writeText(text).catch(() => legacyCopy(text)) ?? legacyCopy(text);
        function legacyCopy(text) {
          const ta = Object.assign(document.createElement('textarea'), { value: text, style: 'position:fixed;left:-9999px' });
          document.body.appendChild(ta); ta.select();
          try {
            document.execCommand('copy');
          } catch {
            // execCommand 已棄用，某些瀏覽器可能不支援
            console.warn('[legacyCopy] execCommand 不支援');
          }
          ta.remove();
          return Promise.resolve();
        }

        /** Toast 提示顯示小資訊 */
        function toast(msg, duration = CONFIG.timing.toastDuration) {
          const t = els.toast;
          if (!t) return;
          clearTimeout(state.toastTimer);
          t.textContent = msg;
          t.classList.remove('hidden');
          if (duration > 0) state.toastTimer = setTimeout(() => t.classList.add('hidden'), duration);
        }

        /** 打開音效的右鍵/長按選單 */
        function openMenuForSound(snd, x, y) {
          const m = els.menu;
          if (!m) return;
          m.innerHTML = '';
          // 加到音軌項目
          const addTrack = dom.el('div', { class: 'menu-item', role: 'menuitem', tabindex: '0' }, '加到音軌');
          addTrack.addEventListener('click', () => {
            closeMenu();
            if (typeof demaPanel !== 'undefined' && demaPanel.addSoundToTrack) {
              demaPanel.addSoundToTrack(snd);
            }
          });
          // 分享網址項目
          const share = dom.el('div', { class: 'menu-item', role: 'menuitem', tabindex: '0' }, '分享網址');
          share.addEventListener('click', async () => {
            await copyToClipboard(buildSoundURL(snd.id));
            closeMenu();
            toast(MESSAGES.toast.linkCopied);
          });
          // 下載音檔項目
          const dl = dom.el('div', { class: 'menu-item', role: 'menuitem', tabindex: '0' }, '下載音檔');
          dl.addEventListener('click', () => { closeMenu(); utils.download(snd.src, snd.file); });
          m.append(addTrack, share, dl);
          m.classList.remove('hidden');
          // 定位選單：確保元素有尺寸後再計算
          requestAnimationFrame(() => positionMenu(x, y));
        }

        /** 定位選單在視窗內 */
        function positionMenu(x, y) {
          const m = els.menu;
          if (!m) return;
          const pad = 6;
          const w = m.offsetWidth || 180;
          const h = m.offsetHeight || 100;
          const vw = window.innerWidth, vh = window.innerHeight;
          m.style.left = Math.min(Math.max(0, x), vw - w - pad) + 'px';
          m.style.top = Math.min(Math.max(0, y), vh - h - pad) + 'px';
        }

        /** 關閉選單 */
        const closeMenu = () => { const m = els.menu; if (m) { m.classList.add('hidden'); m.innerHTML = ''; } };
        // 點擊外部或按 ESC 關閉選單
        document.addEventListener('click', e => { if (els.menu && !els.menu.classList.contains('hidden') && !els.menu.contains(e.target)) closeMenu(); });
        document.addEventListener('keydown', e => { if (e.key === 'Escape') closeMenu(); });
        window.addEventListener('resize', closeMenu);

        /** 切換主題 */
        /** 套用主題樣式，暫時停用 transition 以避免切換時的 lag */
        const applyTheme = theme => {
          document.body.classList.add('no-transition');
          document.documentElement.classList.toggle('light', theme === 'light');
          // 強制 reflow 後恢復 transition
          document.body.offsetHeight;
          document.body.classList.remove('no-transition');
        };
        const savedTheme = localStorage.getItem(CONFIG.storage.theme) || (matchMedia('(prefers-color-scheme:light)').matches ? 'light' : 'dark');
        applyTheme(savedTheme);
        els.themeBtn.addEventListener('click', () => {
          const next = document.documentElement.classList.contains('light') ? 'dark' : 'light';
          if (next === 'dark') playSoundById('oNTWqg'); // 瓦哈音效：開燈啊
          localStorage.setItem(CONFIG.storage.theme, next);
          applyTheme(next);
        });

        // 設定 Modal 行為
        
        /** 顯示/隱藏 Modal 並設定焦點 */
        const setModalVisible = (modal, visible, focusEl) => {
          if (!modal) return;
          modal.classList.toggle('hidden', !visible);
          modal.setAttribute('aria-hidden', String(!visible));
          if (focusEl) {
            try {
              focusEl.focus();
            } catch {
              // 焦點設定失敗不影響功能，可能是元素不可見或已移除
            }
          }
        };

        /** 隱藏設定面板 */
        const hideSettings = () => setModalVisible(els.settingsModal, false);
        /** 檢查設定面板是否開啟 */
        const isSettingsOpen = () => els.settingsModal && !els.settingsModal.classList.contains('hidden');

        /** 更新混音主音量（用於 demaPanel 的 Web Audio API）*/
        const updateMixMasterGain = norm => {
          // 注意：此函式原本用於更新某個不存在的 mixAudio 物件
          // 目前 demaPanel 使用獨立的 audioContext，不需要在此更新
          // 保留此函式以供未來擴充或整合使用
        };

        els.settingsBtn?.addEventListener('click', e => {
          e.preventDefault();
          setModalVisible(els.settingsModal, true);
          const vol = Math.round((state.globalVolume ?? 1) * 100);
          if (els.settingsVolume) els.settingsVolume.value = String(vol);
          if (els.settingsVolumeValue) els.settingsVolumeValue.textContent = `${vol}%`;
        });

        els.settingsClose?.addEventListener('click', hideSettings);
        document.addEventListener('click', e => { if (isSettingsOpen() && e.target === els.settingsModal) hideSettings(); });
        document.addEventListener('keydown', e => { if (e.key === 'Escape' && isSettingsOpen()) hideSettings(); });

        els.settingsVolume?.addEventListener('input', () => {
          const maxPercent = CONFIG.volume.max * 100;
          const rawValue = Math.max(0, Math.min(maxPercent, Number(els.settingsVolume.value) || 0));
          const norm = rawValue / 100;
          state.globalVolume = norm;
          try {
            localStorage.setItem(CONFIG.storage.globalVolume, String(norm));
          } catch (e) {
            console.warn('[settings] 儲存音量設定失敗', e);
          }
          if (els.settingsVolumeValue) els.settingsVolumeValue.textContent = `${Math.round(norm * 100)}%`;
          updateMixMasterGain(norm);
        });

        /** 播放彩蛋：音效開始時顯示主播頭像 */
        const activeGroups = new Set();
        function onPlayStart(snd, audio) {
          /* =====================================================================
             [ADHOC] 三週年特殊機制：OVA1gg 音效的頭像飛入動畫

             在第 9 秒時觸發貓下去頭像從右側飛入，停留 1 秒後飛出

             TODO (未來重構):
             - 將此邏輯抽離為通用函數
             - 支援從 sounds.json 讀取配置 (觸發時間、頭像、動畫參數)
             ===================================================================== */
          if (snd.id === 'OVA1gg') {
            // 在第 9 秒觸發頭像飛入
            const triggerTime = 8500; // 8.5 秒 = 8500 毫秒
            const displayDuration = 1500; // 停留 1.5 秒

            setTimeout(() => {
              // 建立特殊頭像容器
              const container = dom.el('div', { class: 'special-avatar-container' });
              const avatarImg = dom.el('img', {
                src: 'avatars/catdown-問號.png',
                alt: '貓下去問號頭像',
                class: 'special-avatar fly-in'
              });

              container.appendChild(avatarImg);
              document.body.appendChild(container);

              // 1 秒後觸發飛出動畫
              setTimeout(() => {
                avatarImg.classList.remove('fly-in');
                avatarImg.classList.add('fly-out');

                // 動畫結束後移除元素
                avatarImg.addEventListener('animationend', () => {
                  container.remove();
                }, { once: true });
              }, displayDuration);
            }, triggerTime);
          }
          /* ===================================================================== */

          // 原有的主播頭像邏輯
          const streamerTags = snd.tags.map(k => state.tags[utils.slug(k)]).filter(t => t?.role === 'streamer' && t.avatar);
          if (!streamerTags.length) return;
          const group = dom.el('div', { class: 'group' });
          activeGroups.add(group);
          streamerTags.forEach((t, i) => {
            const avatar = dom.el('div', { class: 'avatar pop-in jit', style: { animationDelay: `${i * 60}ms` } }, [
              dom.el('img', { src: withV(t.avatar), alt: t.name })
            ]);
            group.appendChild(avatar);
          });
          els.stage.appendChild(group);
          audio.__group = group;
        }
        /** 播放彩蛋：音效結束時播放頭像離場動畫 */
        function onPlayEnd(_snd, audio) {
          const group = audio.__group;
          if (!group) return;
          [...group.children].forEach((av, i) => {
            av.classList.remove('jit');
            setTimeout(() => {
              av.classList.add('hop-out');
              av.onanimationend = () => { av.remove(); group.childElementCount === 0 && (group.remove(), activeGroups.delete(group)); };
            }, i * CONFIG.timing.hopOutDelay);
          });
        }

        /** ===== Favorites schema migration: file -> id (v1 -> v2) ===== */
        const ID_REGEX = /^[A-Za-z0-9_-]{6}$/;

        /** 解析舊版最愛資料為字串陣列 */
        function parseLegacyFavorites(raw) {
          if (!raw) return [];
          try {
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) return parsed.map(String);
            if (parsed && typeof parsed === 'object') return Object.keys(parsed).filter(k => parsed[k]).map(String);
          } catch {
            // 預期行為：非 JSON 格式，支援用逗號/空白分隔的舊格式
            return typeof raw === 'string' ? raw.split(/[,\s]+/).map(s => s.trim()).filter(Boolean) : [];
          }
          return [];
        }

        /** 正規化檔案路徑作為查找鍵值 */
        const canonFileKey = s => {
          if (!s) return '';
          let k = String(s).split('?')[0].replace(/^\.?\//, '');
          try {
            k = decodeURIComponent(k);
          } catch {
            // 預期行為：某些字串無法解碼（如非法 % 序列），使用原始值
          }
          return k;
        };

        /** 由 sounds.json 建立對照表：file/basename/大小寫鬆弛 -> id */
        /**
         * 從 sounds.json 建立對照表用於檔案名稱轉 ID 的對應。
         * 
         * 支援多種輸入格式並進行正規化：
         * 1. 完整路徑（e.g. `sounds/subfolder/file.mp3`）
         * 2. 基礎檔名（e.g. `file.mp3`）
         * 3. 大小寫不敏感查詢
         * 
         * 返回兩張 Map：
         * - exact：精確配對（區分大小寫）
         * - lower：寬鬆配對（不區分大小寫）
         * 
         * @param {Array} soundsJson - sounds.json 陣列，每項包含 file 與 id
         * @returns {Object} { exact: Map, lower: Map }
         */
        function buildFileMapsFromConfig(soundsJson) {
          const exact = new Map(), lower = new Map();
          for (const s of soundsJson) {
            // 提取檔案路徑的基本形式
            const file = canonFileKey(s.file), base = file.split('/').pop(), id = s.id || base;
            // 針對多種路徑變體建立對應：完整路徑、基檔名、帶/不帶 sounds 前綴
            [file, base, `sounds/${file}`, `sounds/${base}`].forEach(k => { 
              exact.set(k, id); 
              lower.set(k.toLowerCase(), id); 
            });
          }
          return { exact, lower };
        }

        /** 檢查最愛是否需要遷移 */
        const favoritesNeedMigration = raw => {
          const list = parseLegacyFavorites(raw);
          return list.length > 0 && !list.every(x => ID_REGEX.test(x));
        };

        /** 執行最愛從檔名到 ID 的遷移 */
        function migrateFavoritesFromFilesToIds(soundsJson) {
          try {
            const raw = localStorage.getItem(CONFIG.storage.favorites);
            if (!favoritesNeedMigration(raw)) {
              localStorage.setItem(CONFIG.storage.favoritesVersion, '2');
              return;
            }
            const legacy = parseLegacyFavorites(raw);
            const { exact, lower } = buildFileMapsFromConfig(soundsJson);

            const out = [];
            const seen = new Set();
            const missing = [];

            legacy.forEach(k => {
              const c = canonFileKey(k);
              const base = c.split('/').pop();
              const candidates = [c, c.replace(/^sounds\//, ''), base, 'sounds/' + c, 'sounds/' + base];
              const id = candidates.map(cand => exact.get(cand) || lower.get(cand.toLowerCase())).find(Boolean);
              if (!id) { missing.push(k); return; }
              if (!seen.has(id)) { seen.add(id); out.push(id); }
            });

            // 寫入新版 + 備份舊版
            localStorage.setItem(CONFIG.storage.favoritesBackup, raw);
            localStorage.setItem(CONFIG.storage.favorites, JSON.stringify(out));
            localStorage.setItem(CONFIG.storage.favoritesVersion, '2');

            // 同步到 runtime（本次載入立即生效）
            state.favorites = out;
            state.favSet = new Set(out);
            toast(`已升級最愛格式，共 ${out.length} 筆${missing.length ? `；未匹配 ${missing.length} 筆` : ''}。`);
            console.info('[favorites migration] done:', { converted: out.length, missing });
          } catch (err) {
            console.warn('[favorites migration] error:', err);
          }
        }

        /** 從票選結果重新排序音效列表 */
        async function applyVoteResultsOrdering() {
          try {
            const resp = await fetch(withV(CONFIG.paths.voteResults), { cache: 'no-store' });
            if (!resp.ok) { console.warn('[vote load] resp not ok', resp.status); return false; }
            const voteData = await resp.json();
            const topIds = voteData.slice(0, CONFIG.awards.topRankCount).map(v => v.id).filter(Boolean);
            if (!topIds.length) return false;
            // 依票選順序收集已匹配的音效
            const seen = new Set();
            const matchedList = topIds.map(id => state.soundMap.get(id)).filter(s => s && !seen.has(s.id) && (seen.add(s.id), true));
            // 檢查未匹配的音效 ID
            const unmatchedIds = topIds.filter(id => !state.soundMap.has(id));
            // 重組：已匹配的優先，其餘保持原序
            state.sounds = [...matchedList, ...state.sounds.filter(s => !seen.has(s.id))];
            state.soundMap = new Map(state.sounds.map(s => [s.id, s]));
            state.defaultSoundsSnapshot = state.sounds.map(s => ({ ...s }));
            state.voteResults = {
              matchedList,
              top10: matchedList.slice(0, CONFIG.awards.top10Count),
              next20: matchedList.slice(CONFIG.awards.top10Count, CONFIG.awards.topRankCount)
            };
            console.info('[vote reorder] applied ordering, matched:', matchedList.length, '/', topIds.length);
            // 若有未匹配的音效，輸出錯誤訊息
            if (unmatchedIds.length > 0) {
              console.error('[vote reorder] 以下票選音效 ID 無法在 sounds.json 中找到對應項目:', unmatchedIds);
            }
            return true;
          } catch (e) { console.warn('[vote load] failed', e); return false; }
        }

        /** 載入設定檔並初始化狀態 */
        async function loadConfig() {
          const [tagsJson, soundsJson] = await Promise.all([
            fetch(withV(CONFIG.paths.tags), { cache: 'no-store' }).then(r => r.json()),
            fetch(withV(CONFIG.paths.sounds), { cache: 'no-store' }).then(r => r.json())
          ]);
          // 讀取標籤
          migrateFavoritesFromFilesToIds(soundsJson);
          state.tags = {};
          state.tagList = tagsJson.map(t => ({ key: utils.slug(t.key), name: t.name, color: t.color, role: t.role, avatar: t.avatar }));
          state.tagList.forEach(t => { state.tags[t.key] = t; });
          // 讀取音效。若配置檔中包含 id，則使用該 id；否則 fallback 到檔名。加上版本字串。
          state.sounds = soundsJson.map(s => {
            const id = s.id || s.file.replace(/^.*[\\\/]/, '');
            return { id, src: withV(`sounds/${s.file}`), file: s.file, title: s.title, tags: s.tags.slice() };
          });
          state.soundMap = new Map(state.sounds.map(s => [s.id, s]));
          // 保存一份原始載入順序的淺拷貝，供「預設順序」還原使用
          state.defaultSoundsSnapshot = state.sounds.map(s => ({ ...s }));
          // 載入票選結果 JSON，將前 N 名依票選順序移到最前面
          await applyVoteResultsOrdering();
          // 計算哪些標籤被使用到，以供標籤一覽
          const usedKeys = new Set();
          state.sounds.forEach(snd => snd.tags.forEach(t => usedKeys.add(utils.slug(t))));
          state.usedTagList = state.tagList.filter(t => usedKeys.has(t.key));
        }

        /* =======================================================================
           10. UI 渲染函式
           
           音效卡片、網格、標籤、分頁等 UI 元素的渲染邏輯。
           ======================================================================= */

        /**
         * 主渲染函式：根據搜尋條件篩選、分類、排序音效，並更新 UI。
         * 
         * 邏輯流程：
         * 1. 解析搜尋條件（詞彙 + 標籤）
         * 2. 篩選符合條件的音效
         * 3. 分類至三個區塊（按優先級）：
         *    - 最愛區（收藏的音效）
         *    - 收到的列表（分享連結含有的音效，非最愛）
         *    - 一般區（其他篩選結果）
         * 4. 更新 UI：渲染卡片網格、空狀態提示、活躍搜尋標籤
         */
        function render() {
          const { terms, tags } = utils.parseQuery();
          // 步驟 1 & 2：篩選符合條件的音效
          const filtered = state.sounds.filter(s => utils.match(s, terms, tags));
          // 解析分享列表參數（從 URL）
          const received = state.receivedList.map(id => state.soundMap.get(id)).filter(Boolean);
          const allowedIds = new Set(filtered.map(s => s.id)); // 篩選結果的 ID 集合
          
          // 步驟 3：分類區塊
          // 最愛區：在篩選結果中的收藏音效
          const fav = state.favorites.map(id => state.soundMap.get(id)).filter(s => s && allowedIds.has(s.id));
          // 收到的列表：在篩選結果中、非最愛的分享音效
          const rec = received.filter(s => allowedIds.has(s.id) && !state.favSet.has(s.id));
          // 一般區：篩選結果中既非最愛也未在分享列表的音效
          const rest = filtered.filter(s => !state.favSet.has(s.id) && !rec.includes(s));

          // [優化] 如果 URL 指定了特定音效，將其移至列表最前方以確保優先渲染
          const focusId = new URLSearchParams(location.search).get('sound');
          if (focusId) {
            const idx = rest.findIndex(s => s.id === focusId);
            if (idx > 0) {
              const [item] = rest.splice(idx, 1);
              rest.unshift(item);
            }
          }
          
          // 步驟 4：更新 UI
          // 最愛區只在非編輯模式下渲染（避免拖放時重新排序卡片）
          if (!state.isSorting) renderGrid(els.favGrid, fav, { inFav: true });
          renderGrid(els.receivedGrid, rec);
          
          // 一般區改用分批渲染（虛擬滾動優化）
          state.displayList = rest;
          state.renderedCount = 0;
          els.grid.innerHTML = ''; // 清空容器
          
          // 初始化 IntersectionObserver（如果尚未建立）
          if (!state.observer) {
            state.observer = new IntersectionObserver(entries => {
              if (entries[0].isIntersecting) renderNextBatch();
            }, { rootMargin: '400px' }); // 提早 400px 觸發載入
          } else {
            state.observer.disconnect();
          }
          
          renderNextBatch();

          // 空狀態提示
          els.favEmpty.classList.toggle('hidden', fav.length > 0);
          els.empty.classList.toggle('hidden', filtered.length > 0);
          els.receivedSection?.classList.toggle('hidden', rec.length === 0);
          // 更新搜尋標籤列（chips）
          renderActiveChips();
        }

        /** 渲染下一批次音效卡片 */
        function renderNextBatch() {
          const { displayList, renderedCount } = state;
          if (renderedCount >= displayList.length) return;

          const batch = displayList.slice(renderedCount, renderedCount + CONFIG.ui.batchSize);
          if (batch.length === 0) return;

          // 移除舊的哨兵元素
          const oldSentinel = document.getElementById('grid-sentinel');
          if (oldSentinel) oldSentinel.remove();

          const fragment = document.createDocumentFragment();
          for (const s of batch) {
            fragment.appendChild(renderSoundCard(s));
          }
          els.grid.appendChild(fragment);
          state.renderedCount += batch.length;

          // 若還有剩餘項目，加入哨兵元素以觸發下一次載入
          if (state.renderedCount < displayList.length) {
            const sentinel = dom.el('div', { id: 'grid-sentinel', style: { gridColumn: '1 / -1', height: '20px', pointerEvents: 'none' } });
            els.grid.appendChild(sentinel);
            state.observer.observe(sentinel);
          }
        }

        /** 渲染票選頁面 */
        function renderawardsPage() {
          if (!state.voteResults) {
            els.awardsTop10?.replaceChildren();
            els.awardsNext20?.replaceChildren();
            return;
          }
          if (els.awardsTop10) renderGrid(els.awardsTop10, state.voteResults.top10 ?? []);
          if (els.awardsNext20) renderGrid(els.awardsNext20, state.voteResults.next20 ?? []);
        }
        /** 渲染音效卡片列表到容器 */
        function renderGrid(container, list, opts = { inFav: false }) {
          container.innerHTML = '';
          for (const s of list) { container.appendChild(renderSoundCard(s, opts)); }
        }
        /** 建立單一音效卡片元素 */
        function renderSoundCard(snd, opts = { inFav: false }) {
          const interactive = !(state.isSorting && opts.inFav);
          const heartAttrs = {
            class: 'heart',
            'aria-pressed': String(utils.inFav(snd.id)),
            'aria-label': '加入/移除最愛',
            ...(!interactive && { disabled: 'true', 'aria-disabled': 'true', title: '正在編輯最愛排序，無法變更最愛' })
          };
          const heartBtn = dom.el('button', heartAttrs, dom.svgHeart());
          if (interactive) heartBtn.onclick = e => { e.stopPropagation(); toggleFavorite(snd.id, heartBtn); };
          const tagWrap = dom.el('div', { class: 'tags' });
          for (const t of snd.tags) {
            const tagKey = utils.slug(t);
            const color = state.tags[tagKey]?.color || '#94a3b8';
            const el = dom.el('span', { class: 'tag', style: { background: color } }, t);
            el.addEventListener('click', e => { e.stopPropagation(); addTagToQuery(tagKey); });
            tagWrap.appendChild(el);
          }
          const card = dom.el('div', { id: 'snd-' + snd.id, 'data-id': snd.id, class: 'sound', role: 'button', tabindex: '0', 'aria-label': `播放音效：${snd.title}` }, [
            dom.el('div', { class: 'sound-top' }, [
              dom.el('div', { class: 'title', title: snd.title }, snd.title),
              heartBtn
            ]),
            tagWrap
          ]);
          const play = () => { try { playSoundObject(snd); } catch (e) { console.error(e); } };
          const endHold = () => clearTimeout(state.contextTimer);
          if (interactive) {
            card.addEventListener('click', play);
            card.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); play(); } });
            card.addEventListener('contextmenu', e => { e.preventDefault(); closeMenu(); openMenuForSound(snd, e.clientX, e.clientY); });
            card.addEventListener('pointerdown', e => {
              clearTimeout(state.contextTimer);
              const { clientX, clientY } = e;
              state.contextTimer = setTimeout(() => {
                closeMenu();
                openMenuForSound(snd, clientX ?? window.innerWidth / 2, clientY ?? window.innerHeight / 2);
              }, CONFIG.timing.longPressDelay);
            });
            card.addEventListener('pointerup', endHold);
            card.addEventListener('pointerleave', endHold);
          }
          card.addEventListener('pointercancel', endHold);
          return card;
        }

        /** 切換音效的最愛狀態 */
        function toggleFavorite(id, btn) {
          if (state.isSorting) { toast(MESSAGES.toast.sortingBlocked); return; }
          if (state.favSet.has(id)) {
            state.favorites = state.favorites.filter(x => x !== id);
          } else {
            state.favorites.push(id);
          }
          state.favSet = new Set(state.favorites);
          utils.saveFav();
          if (btn) btn.setAttribute('aria-pressed', String(state.favSet.has(id)));
          render();
        }

        /** 渲染已選標籤 chips */
        function renderActiveChips() {
          els.activeChips.innerHTML = '';
          for (const key of state.queryTags) {
            const tag = state.tags[key];
            const color = tag?.color || '#94a3b8';
            const chip = dom.el('span', { class: 'chip', style: { background: color }, onclick: () => { state.queryTags.delete(key); render(); updateURLFromState(true); } }, [
              `#${tag?.name || key}`,
              dom.el('button', { title: '移除', onclick: () => { state.queryTags.delete(key); render(); updateURLFromState(true); } }, '×')
            ],
            );
            els.activeChips.appendChild(chip);
          }
        }

        /** 將標籤加入搜尋條件 */
        function addTagToQuery(tagKey) {
          state.queryTags.add(tagKey);
          render();
          updateURLFromState(true);
        }

        /* =======================================================================
           11. 週年慶祝功能模組
           
           包含：
           - 彩帶特效 (fireConfetti)
           - 音效播放
           - 互動事件綁定
           ======================================================================= */

        /** 慶祝三週年彩帶特效 */
        function fireConfetti() {
           // 播放音效
           setTimeout(() => {
             const audio = new Audio('assets/confetti-pop.mp3');
             audio.volume = 0.6;
             audio.play().catch(e => console.warn('Confetti sound failed', e));
           }, 10);

           const canvas = document.createElement('canvas');
           canvas.style.position = 'fixed';
           canvas.style.top = '0';
           canvas.style.left = '0';
           canvas.style.width = '100%';
           canvas.style.height = '100%';
           canvas.style.pointerEvents = 'none';
           canvas.style.zIndex = '9999';
           document.body.appendChild(canvas);
           
           const ctx = canvas.getContext('2d');
           canvas.width = window.innerWidth;
           canvas.height = window.innerHeight;
           
           const particles = [];
           const colors = ['#ffc0ab', '#ff893d', '#ffde82', '#b2f4c7', '#60cfff', '#2d7eff', '#b5b1ff'];
           
           // Emitters at 4 corners
           const emitters = [
             {x: 0, y: 0},
             {x: canvas.width, y: 0},
             {x: 0, y: canvas.height},
             {x: canvas.width, y: canvas.height}
           ];
           
           emitters.forEach(emitter => {
             for(let i=0; i<80; i++) {
               const angle = Math.atan2(canvas.height/2 - emitter.y, canvas.width/2 - emitter.x);
               const spread = (Math.random() - 0.5) * 1.8;
               // 降低初始速度 (原: 15 + 10)
               const velocity = Math.random() * 10 + 6;
               
               particles.push({
                 x: emitter.x,
                 y: emitter.y,
                 vx: Math.cos(angle + spread) * velocity,
                 vy: Math.sin(angle + spread) * velocity,
                 color: colors[Math.floor(Math.random() * colors.length)],
                 size: Math.random() * 8 + 4,
                 life: 2.0,
                 decay: Math.random() * 0.01 + 0.005,
                 rotation: Math.random() * 360,
                 rotationSpeed: (Math.random() - 0.5) * 6
               });
             }
           });
           
           function loop() {
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             let alive = false;
             
             particles.forEach(p => {
               if(p.life > 0) {
                 alive = true;
                 p.x += p.vx;
                 p.y += p.vy;
                 p.vy += 0.12; // Gravity (原: 0.2)
                 p.vx *= 0.95; // Friction (原: 0.96)
                 p.vy *= 0.95;
                 p.life -= p.decay;
                 p.rotation += p.rotationSpeed;
                 
                 ctx.save();
                 ctx.translate(p.x, p.y);
                 ctx.rotate(p.rotation * Math.PI / 180);
                 ctx.fillStyle = p.color;
                 ctx.globalAlpha = Math.max(0, p.life);
                 ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                 ctx.restore();
               }
             });
             
             if(alive) {
               requestAnimationFrame(loop);
             } else {
               document.body.removeChild(canvas);
             }
           }
           
           loop();
        }

        /** 解壓三週年音效包 */
        let isExtracted = false; // 防止重複解壓
        async function extractAnniversary() {
          // 確保音效已載入完成
          if (!state.sounds || state.sounds.length === 0) {
            console.warn('音效尚未載入完成');
            return;
          }

          // 防止重複解壓
          if (isExtracted) {
            console.log('已經解壓過了');
            return;
          }
          isExtracted = true;

          // 搜尋所有帶有「三週年」或「三週年」標籤的音效
          const anniversarySounds = state.sounds.filter(sound => {
            return sound.tags.some(tag =>
              tag.includes('三週年') || tag.includes('三周年')
            );
          });

          if (anniversarySounds.length === 0) {
            console.warn('找不到三週年音效');
            isExtracted = false;
            return;
          }

          // 獲取必要的元素
          const archiveRowEl = document.getElementById('anniversaryArchiveRow');
          const soundsGridEl = document.getElementById('anniversarySoundsGrid');
          const extractRowEl = document.getElementById('extractModal');
          const progressFill = document.getElementById('extractProgressFill');
          const progressText = document.getElementById('extractProgressText');

          if (!archiveRowEl || !soundsGridEl || !extractRowEl || !progressFill || !progressText) {
            console.error('找不到必要的元素');
            isExtracted = false;
            return;
          }

          // 隱藏壓縮檔 row，顯示解壓縮進度 row
          archiveRowEl.style.display = 'none';
          extractRowEl.style.display = 'flex';

          // 進度條動畫：0-100% 在 1.0 秒內完成
          const duration = 1000; // 1.0 秒
          const startTime = Date.now();

          // 同時進行進度條動畫和音效卡片出現
          const progressInterval = setInterval(() => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(100, (elapsed / duration) * 100);

            progressFill.style.width = `${progress}%`;
            progressText.textContent = `${Math.floor(progress)}%`;

            if (progress >= 100) {
              clearInterval(progressInterval);
            }
          }, 16); // ~60fps

          // 顯示音效網格區域
          soundsGridEl.style.display = 'grid';

          // 逐個添加音效卡片，與進度條同步
          const delayPerCard = duration / anniversarySounds.length; // 在 1.0 秒內均勻分配

          const addCardsPromise = (async () => {
            for (let i = 0; i < anniversarySounds.length; i++) {
              await new Promise(resolve => setTimeout(resolve, delayPerCard));

              const sound = anniversarySounds[i];
              const card = renderSoundCard(sound);
              card.style.animationDelay = '0s'; // 立即播放淡入動畫
              soundsGridEl.appendChild(card);
            }
          })();

          // 等待進度條完成
          await new Promise(resolve => setTimeout(resolve, duration));

          // 隱藏進度條 row
          extractRowEl.style.display = 'none';

          // 確保所有卡片都已添加
          await addCardsPromise;

          // 解壓縮完成後，修改標題文字並觸發慶祝動畫
          const anniversaryTextEl = document.querySelector('.anniversary-text');
          if (anniversaryTextEl) {
            anniversaryTextEl.textContent = "🎉等登！三週年語音🎉";
          }

          // 稍微延遲後播放彩帶拉炮動畫和音效
          setTimeout(() => {
            fireConfetti();
          }, 10);
        }

        /* =======================================================================
           12. 初始化流程
           
           應用程式啟動、事件綁定、資料載入。
           ======================================================================= */

        /** 初始化事件綁定 */
        function initEvents() {
          // [Anniversary] 三週年標題點擊觸發彩帶特效
          const titleBtn = document.getElementById('anniversaryTitle');
          if (titleBtn) {
            titleBtn.addEventListener('click', fireConfetti);
          }

          // [Anniversary] 三週年解壓縮互動
          const archiveBtn = document.getElementById('anniversaryArchive');
          if (archiveBtn) {
            archiveBtn.addEventListener('click', extractAnniversary);
          }

          // 搜尋框輸入（使用 debounce 降低 render 頻率）
          const handleSearchInput = () => {
            state.queryText = els.q.value;
            render();
            updateURLFromState(false);
          };
          els.q.addEventListener('input', utils.debounce(handleSearchInput, CONFIG.timing.searchDebounce));

          // 清除搜尋
          els.clearBtn.addEventListener('click', () => {
            els.q.value = '';
            state.queryText = '';
            state.queryTags.clear();
            render();
            updateURLFromState(true);
          });

          // 導覽切換
          els.navTabs.forEach(tab => {
            tab.addEventListener('click', () => {
              const pg = tab.getAttribute('data-page');
              showPage(pg || 'home');
            });
          });
          // 手機選單開關
          if (els.navToggle) {
            els.navToggle.addEventListener('click', () => {
              const open = !document.body.classList.contains('nav-open');
              document.body.classList.toggle('nav-open', open);
              els.navToggle.setAttribute('aria-expanded', String(open));
            });
          }

          const closeNavMenu = () => {
            document.body.classList.remove('nav-open');
            els.navToggle?.setAttribute('aria-expanded', 'false');
          };
          // 點擊頁面其他地方關閉手機選單
          document.addEventListener('click', e => {
            if (!document.body.classList.contains('nav-open')) return;
            const headerEl = document.querySelector('header');
            if (headerEl && !headerEl.contains(e.target)) closeNavMenu();
          });
          // 點擊導覽後在小螢幕自動收合
          els.navTabs.forEach(t => t.addEventListener('click', closeNavMenu));

          // 洗牌按鈕
          if (els.shuffleBtn) {
            els.shuffleBtn.addEventListener('click', () => {
              // 只洗牌「非最愛」音效，不影響最愛區的排列
              const nf = [];
              const idxs = [];
              state.sounds.forEach((s, i) => {
                if (!state.favSet.has(s.id)) { nf.push(s); idxs.push(i); }
              });
              shuffleInPlace(nf);
              idxs.forEach((i, k) => { state.sounds[i] = nf[k]; });
              render();
            });
          }
          // 預設順序按鈕：將非最愛區塊恢復為載入時的順序
          if (els.resetOrderBtn) {
            els.resetOrderBtn.addEventListener('click', () => {
              if (!state.defaultSoundsSnapshot || !state.defaultSoundsSnapshot.length) return;
              // 我們只恢復非最愛（rest）區段的順序，同 shuffleBtn 的行為相對應
              const snapshot = state.defaultSoundsSnapshot;
              const idIndex = new Map(snapshot.map((s, i) => [s.id, i]));
              state.sounds.sort((a, b) => (idIndex.get(a.id) ?? Infinity) - (idIndex.get(b.id) ?? Infinity));
              render();
            });
          }
          // 分享最愛列表

          // 手動排序（檢查點A）：啟用/停用 SortableJS 僅針對最愛清單
          if (els.sortFavBtn && els.doneSortBtn) {
            els.sortFavBtn.addEventListener('click', () => {
              state.isSorting = true;
              document.body.classList.add('sorting');
              els.sortFavBtn.classList.add('hidden');
              els.doneSortBtn.classList.remove('hidden');
              // 重新渲染最愛區塊
              const { terms, tags } = utils.parseQuery();
              const allowedIds = new Set(state.sounds.filter(s => utils.match(s, terms, tags)).map(s => s.id));
              const fav = state.favorites.map(id => state.soundMap.get(id)).filter(s => s && allowedIds.has(s.id));
              renderGrid(els.favGrid, fav, { inFav: true });
              // 啟用 SortableJS
              typeof Sortable !== 'undefined'
                ? state.sortable = Sortable.create(els.favGrid, {
                  dataIdAttr: 'data-id', animation: 150, delay: 150, delayOnTouchOnly: true,
                  ghostClass: 'drag-ghost', chosenClass: 'drag-chosen', dragClass: 'dragging',
                  filter: '.heart', preventOnFilter: false
                })
                : console.warn('SortableJS 未載入');
            });
            els.doneSortBtn.addEventListener('click', () => {
              const orderedIds = [...els.favGrid.children].map(el => el.dataset.id).filter(Boolean);
              if (orderedIds.length) {
                state.favorites = orderedIds.concat(state.favorites.filter(id => !orderedIds.includes(id)));
                state.favSet = new Set(state.favorites);
                utils.saveFav();
                toast(MESSAGES.toast.sortingSaved);
              }
              state.sortable?.destroy(); state.sortable = null;
              state.isSorting = false;
              document.body.classList.remove('sorting');
              els.doneSortBtn.classList.add('hidden');
              els.sortFavBtn.classList.remove('hidden');
              render();
            });
          }
          if (els.shareFavBtn) {
            els.shareFavBtn.addEventListener('click', async () => {
              const ids = [...state.favorites];
              if (ids.length === 0) { toast(MESSAGES.toast.noFavorites); return; }
              const url = buildListURL(ids);
              await copyToClipboard(url);
              toast(MESSAGES.toast.listLinkCopied);
            });
          }
        }

        /** 初始化背景動畫 */
        function initBackgroundAnimation() {
          let bgX = 0;
          setInterval(() => {
            bgX -= 75;
            document.body.style.setProperty('--bg-x', `${bgX}px`);
          }, 12000);
        }

        // 入口：載入設定後初始化狀態、渲染並套用 URL 查詢
        loadConfig().then(() => {
          initBackgroundAnimation();
          
          // [Anniversary] 預先載入慶祝音效
          fetch('assets/confetti-pop.mp3').catch(() => {});
          
          applyURLToState();
          renderTagList();
          showPage(state.page);
          render();
          focusSoundFromURL();
          initEvents();
          // 點擊標題時回到主頁並清除搜尋（阻止預設的全頁導向），然後重新渲染與更新 URL
          try {
            const titleLink = document.querySelector('header h1');
            if (titleLink) {
              titleLink.addEventListener('click', (e) => {
                // 如果使用者使用 Ctrl/Cmd + click 或 想要在新分頁開啟，保留原行為
                if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;
                // 若已在主頁，則強制重新整理頁面
                if (state.page === 'home') {
                  // 允許瀏覽器做完整 reload
                  return location.reload();
                }
                e.preventDefault();
                // 清除搜尋狀態並回首頁
                state.queryText = '';
                state.queryTags.clear();
                if (els.q) els.q.value = '';
                showPage('home');
                render();
                updateURLFromState(true);
                // 平滑滾回頂部（某些舊瀏覽器不支援 smooth）
                try {
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                } catch {
                  window.scrollTo(0, 0); // fallback
                }
              });
            }
          } catch (e) {
            console.warn('[resetOrderBtn] 重置排序失敗', e);
          }
        }).catch(err => {
          console.error(err);
          els.grid.innerHTML = `<div class="empty">${MESSAGES.errors.configLoadFailed}</div>`;
        });

        /* =======================================================================
           12. 記憶小遊戲
           
           配對記憶遊戲模組，包含遊戲邏輯、計時、計分系統。
           ======================================================================= */

        /** 初始化配對記憶遊戲 */
        function setupConcentrationGame() {
          const gameEl = document.getElementById('concentration-game');
          const boardEl = document.getElementById('cg-board');
          const timerEl = document.getElementById('cg-timer');
          const accEl = document.getElementById('cg-accuracy');
          const resultEl = document.getElementById('cg-result');
          const restartBtn = document.getElementById('cg-restart');
          if (!gameEl) return;

          // 注意：不要在此處重新宣告 cgCleanup —— 請使用外層作用域的 cgCleanup，
          // 以便在切換頁面時（由 showPage 呼叫）能正確執行清理工作。

          // --- 遊戲狀態 ---
          let cards = [];
          let first = null, second = null;
          // scoring: correct = 正確數 (每配對 +2), wrong = 錯解數 (可 +0/+1/+2)
          let correct = 0, wrong = 0;
          // matchedPairs counts how many pairs have been solved (0..pairCount)
          let matchedPairs = 0, tries = 0;
          let timer = 0, timerId = null, running = false;
          let allowClick = true;
          let pairs = [];
          // pending pair / timeout 用於延遲檢查配對；若使用者在等待期間點擊其他卡，會立刻結算這對。
          let pendingTimeout = null;
          let pendingPair = null; // {f, s}
          let timerStarted = false; // only start timer on first card flip

          /**
           * 從篩選過的有效音效中選出最多 8 筆作為配對來源。
           * 
           * 選擇策略（優先順序）：
           * 1. 已知主播（有配額）：按優先順序選取直到配額滿或無存量
           * 2. 未知主播：最多選 2 筆作為補充
           * 
           * 配額分配：
           * - 地基主阿萬：2 筆
           * - 瓦哈/Matsuko/豹子頭/貓下去：各 1 筆
           * - 其他動物朋友：2 筆
           * 
           * @param {Array} validSounds - 已篩選的音效清單（已移除髒話/SUS、只有一個 streamer 標籤）
           * @returns {Array} 最多 8 筆選中的音效
           */
          function selectSounds(validSounds) {
            const quotas = { '阿萬': 2, '瓦哈': 1, 'Matsuko': 1, '豹子頭': 1, '貓下去': 1 };
            const knownTags = new Set(Object.keys(quotas));
            const counts = Object.fromEntries(Object.keys(quotas).map(k => [k, 0]));
            let others = 0; // 其他動物朋友的計數
            const chosen = [];
            
            for (const snd of validSounds) {
              if (chosen.length >= CONFIG.game.pairCount) break; // 達配對數上限，停止
              const tags = snd.tags ?? [];
              // 優先選擇有配額且未滿的已知主播
              const knownTag = tags.find(t => knownTags.has(t) && counts[t] < quotas[t]);
              if (knownTag) { counts[knownTag]++; chosen.push(snd); }
              // 次選：其他動物朋友，必須要再 2 筆
              else if (!tags.some(t => knownTags.has(t)) && others < 2) { others++; chosen.push(snd); }
            }
            return chosen;
          }

          // --- 資料篩選 ---
          /**
           * 挑選配對遊戲的音效清單。
           * 
           * 篩選規則：
           * 1. 必須恰好包含 1 個 streamer 標籤（識別主播）
           * 2. 不能包含 '髒話' 或 'SUS' 標籤
           * 3. 應用選擇配額（地基主2個、魔法值班室其他4人各1個、其他動物朋友隨機選2）
           * 4. 再次洗牌以隨機化對牌順序
           * 
           * @returns {Array<Object>} 選定的配對物件清單，每個包含 id、audio、avatar、streamerName、title
           */
          function pickPairs() {
            // 輔助：從 tagList 擷取所有 streamer 的 key（並做 slug 化）以供後續比對
            const streamerKeys = state.tagList
              .filter(t => t.role === 'streamer')
              .map(t => utils.slug(t.key));

            // 判斷標籤是否為 streamer（已 slug 化）
            const isStreamer = t => streamerKeys.includes(t);
            
            // 篩選有效的音效：恰好 1 個 streamer，無髒話/SUS
            let validSounds = state.sounds.filter(s => {
              const st = s.tags.filter(isStreamer);
              if (st.length !== 1) return false; // 必須恰好 1 個 streamer
              if (s.tags.includes('髒話') || s.tags.includes('SUS')) return false; // 排除禁止標籤
              return true;
            });

            // 洗牌，應用配額選擇，確保多樣性
            validSounds = shuffleInPlace(validSounds);
            let chosen = selectSounds(validSounds);
            chosen = shuffleInPlace(chosen); // 再洗牌以隨機化對牌順序
            // 最後確保不超過配對數量
            chosen.splice(CONFIG.game.pairCount);

            // 映射到配對用物件（包含 id, audio, avatar, streamerName, title 等欄位）
            return chosen.map(s => {
              const streamerTag = s.tags.find(isStreamer);
              const tagObj = state.tags[utils.slug(streamerTag)];
              return {
                id: s.id,
                audio: s.src,
                streamer: streamerTag,
                avatar: tagObj?.avatar || '',
                streamerName: tagObj?.name || streamerTag,
                title: s.title
              };
            });
          }

          /** 開始新遊戲 */
          function startGame() {
            pairs = pickPairs();
            // 如果找不到足夠的配對音效，顯示訊息並中止遊戲啟動
            if (!pairs?.length) {
              resultEl.innerHTML = `<h3>無法開始遊戲</h3><p style="color:var(--muted)">${MESSAGES.errors.gameNoSounds}</p>`;
              resultEl.classList.remove('hidden');
              running = state.cgRunning = false;
              return;
            }
            [cards, pendingTimeout, pendingPair] = [[], (clearTimeout(pendingTimeout), null), null];
            // 為每個配對建立兩張相同的卡片
            for (const p of pairs) {
              const base = { type: 'card', pairId: p.id, audio: p.audio, avatar: p.avatar, streamer: p.streamer, streamerName: p.streamerName, title: p.title, matched: false, seen: false };
              cards.push({ ...base, id: `${p.id}-0` }, { ...base, id: `${p.id}-1` });
            }
            shuffleInPlace(cards);
            [matchedPairs, correct, wrong, tries, timer, first, second] = [0, 0, 0, 0, 0, null, null];
            allowClick = true;
            timerStarted = running = state.cgRunning = false;
            if (timerEl) { timerEl.textContent = formatTime(0); timerEl.classList.remove('cg-running'); }
            updateBoard();
            updateStats();
            resultEl.classList.add('hidden');
            // 提供清理函式
            cgCleanup = () => {
              running = false;
              state.cgRunning = false;
              stopTimer();
              stopCurrentAudio();
              timerEl?.classList.remove('cg-running');
              boardEl.innerHTML = '';
              clearTimeout(pendingTimeout);
              pendingTimeout = pendingPair = null;
            };
          }
          /** 重新渲染遊戲板面 */
          function updateBoard() {
            boardEl.innerHTML = '';
            for (const [idx, card] of cards.entries()) {
              const cardEl = dom.el('div', {
                class: `cg-card${card.flipped || card.matched ? ' flipped' : ''}${card.matched ? ' matched' : ''}`,
                'data-idx': idx,
                onclick: () => onCardClick(idx),
                onpointerdown: () => { cardEl.classList.add('clicked'); setTimeout(() => cardEl.classList.remove('clicked'), 160); }
              });
              const backContent = card.avatar
                ? `<img src="${withV(card.avatar)}" alt="${card.streamerName}">`
                : `<div style="font-weight:700;color:var(--muted);font-size:12px">${card.streamerName}</div>`;
              cardEl.innerHTML = `<div class="cg-card-inner"><div class="cg-card-front"></div><div class="cg-card-back">${backContent}${card.matched ? '<div class="cg-lock">✓</div>' : ''}</div></div>`;
              boardEl.appendChild(cardEl);
            }
          }

          let currentAudio = null;
          /** 停止當前播放的音效 */
          const stopCurrentAudio = () => { if (currentAudio) { try { currentAudio.pause(); currentAudio.currentTime = 0; } catch (e) { } currentAudio = null; } };

          /** 處理卡片點擊並檢查配對 */
          function onCardClick(idx) {
            // 如果有待處理的 pendingPair，使用者此刻點擊其他卡片時應立即結算該 pendingPair
            if (pendingPair?.f || pendingPair?.s) {
              clearTimeout(pendingTimeout);
              pendingTimeout = null;
              const p = pendingPair;
              pendingPair = null;
              checkMatchPair(p.f, p.s);
              first = second = null;
              allowClick = true;
            }
            if (!allowClick) return;
            const card = cards[idx];
            if (card.flipped || card.matched) return;
            // 在玩家第一次互動（翻牌）時啟用計時器
            if (!timerStarted) {
              timerStarted = running = state.cgRunning = true;
              timerEl?.classList.add('cg-running');
              startTimer();
            }
            // 執行翻牌（更新資料狀態並重新渲染板面，觸發 CSS 翻牌動畫）
            card.flipped = true;
            updateBoard();
            if (!first) {
              // 記錄這張卡牌在翻前是否已被翻看過（用於計分判定）
              card._seenBefore = !!card.seen;
              // 標記為已看過（避免後續重複計分）
              card.seen = true;
              first = card;
              // 播放該卡的音效並顯示標題
              stopCurrentAudio();
              currentAudio = createPlayer(card.audio, { preload: 'auto' });
              if (card.title) toast(card.title, 3000);
            } else if (!second) {
              // 第二張卡的處理：同樣標記是否先前看過並播放音效
              card._seenBefore = !!card.seen;
              card.seen = true;
              second = card;
              stopCurrentAudio();
              currentAudio = createPlayer(card.audio, { preload: 'auto' });
              if (card.title) toast(card.title, 3000);
              tries++;
              allowClick = false;
              // 捕獲當前第一張/第二張卡的引用，避免在延遲期間被其他邏輯改寫造成 race condition。
              const fCard = first;
              const sCard = second;
              // 儲存為 pendingPair，並啟動超時（500ms）。如果使用者在此期間點擊其他卡
              // 則會在 onCardClick 開頭立刻結算這對。
              pendingPair = { f: fCard, s: sCard };
              if (pendingTimeout) { clearTimeout(pendingTimeout); pendingTimeout = null; }
              pendingTimeout = setTimeout(() => {
                pendingTimeout = null;
                const p = pendingPair; pendingPair = null;
                checkMatchPair(p.f, p.s);
                // 重置全域暫存，允許下一回合互動
                first = null;
                second = null;
                allowClick = true;
              }, CONFIG.game.cardFlipDelay);
            }
            updateStats();
          }

          /** 檢查兩張卡片是否配對 */
          function checkMatchPair(f, s) {
            if (!f || !s) return;
            if (f.pairId === s.pairId) {
              f.matched = s.matched = true;
              correct += 2;
              matchedPairs++;
            } else {
              const seenCount = [f, s].filter(c => c._seenBefore).length;
              wrong += seenCount || 0;
              f.flipped = s.flipped = false;
            }
            delete f._seenBefore; delete s._seenBefore;
            updateBoard();
            updateStats();
            if (matchedPairs === pairs.length) { stopCurrentAudio(); endGame(); }
          }

          /** 更新遊戲統計顯示 */
          function updateStats() {
            timerEl.textContent = formatTime(timer);
            const denom = correct + wrong;
            accEl.textContent = denom ? `準確率：${Math.round((correct / denom) * 100)}%` : '準確率：--%';
          }

          /** 格式化時間為 mm:ss */
          const formatTime = t => `${String(Math.floor(t / 60)).padStart(2, '0')}:${String(t % 60).padStart(2, '0')}`;

          /** 啟動遊戲計時器 */
          function startTimer() {
            clearInterval(timerId);
            timerId = setInterval(() => { if (state.cgRunning) { timer++; timerEl.textContent = formatTime(timer); } }, 1000);
          }
          /** 停止遊戲計時器 */
          const stopTimer = () => { clearInterval(timerId); timerId = null; };

          /** 結束遊戲並顯示成績 */
          function endGame() {
            running = state.cgRunning = false;
            stopTimer();
            stopCurrentAudio();
            timerEl?.classList.remove('cg-running');
            const denom = correct + wrong;
            const perc = denom ? Math.round((correct / denom) * 100) : '--';
            const stat = (v, l) => `<div><div class="big-num">${v}</div><div class="muted">${l}</div></div>`;
            const stats = [[formatTime(timer), '用時'], [correct, '正確數'], [wrong, '錯解數'], [perc + '%', '準確率']].map(([v, l]) => stat(v, l)).join('');
            resultEl.innerHTML = `<h3>完成！</h3>
                                  <div class="stats">${stats}</div>
                                  <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
                                    <button class="btn small-btn" id="cg-restart-2">再來一局</button>
                                    <button class="btn small-btn" id="cg-home">回主頁</button>
                                  </div>`;
            resultEl.classList.remove('hidden');
            // 若準確率達標，隨機播放獎勵音效
            if (perc >= CONFIG.game.rewardAccuracy) {
              const reward = state.soundMap.get(CONFIG.game.rewardSoundIds[Math.floor(Math.random() * CONFIG.game.rewardSoundIds.length)]);
              if (reward?.src) { stopCurrentAudio(); currentAudio = createPlayer(reward.src, { preload: 'auto' }); toast(MESSAGES.toast.gameReward, 3000); }
            }
            utils.byId('cg-restart-2')?.addEventListener('click', startGame);
            utils.byId('cg-home')?.addEventListener('click', () => showPage('home'));
          }

          restartBtn.onclick = startGame;

          // 初始：載入頁面時顯示卡牌（不啟動計時）。按「重開一局」可重新建立一局；計時皆在第一張翻牌時啟動。
          // 這裡呼叫 startGame() 以建立並顯示卡牌（但 timerStarted=false，不會自動開始計時）
          startGame();
        }

        // 切換到小遊戲分頁時初始化/清理 Concentration Game（使用事件驅動）
        document.addEventListener('pageChange', ({ detail: { page, prevPage, phase } = {} }) => {
          try {
            if (phase === 'before' && prevPage === 'game') cgCleanup?.();
            if (phase === 'after') {
              page === 'game' && setupConcentrationGame?.();
              page === 'awards' && renderawardsPage();
            }
          } catch (e) {
            console.warn('[pageChange] 頁面切換處理失敗', e);
          }
        });

        /* =======================================================================
           13. demaPanel 多軌混音編輯器模組
           ======================================================================= */

        /**
         * demaPanel - 多軌音訊編輯器
         * 
         * 功能：
         * - 3 軌固定音軌，每軌 40px 高
         * - 音訊片段拖曳（含跨軌）
         * - Trim 裁剪（左右邊緣）
         * - 精確 Playhead（時間為基準，視覺為派生）
         * - Undo/Redo 歷史紀錄
         * - localStorage 持久化
         * - 移動端手勢支援
         */
        const demaPanel = (() => {
          // === 常數設定 ===
          const STORAGE_KEY = 'demaPanel_v1';
          const TRACK_COUNT = 3;

          // ⚠️ 重要：音軌標籤寬度（px）
          // 此值必須與 CSS 中以下定義保持完全一致（未來重構時需同步修改）：
          // - .dema-track-label 的 width
          // - .dema-track-content 的 left
          // 用途：Timeline canvas 繪製偏移、Playhead 定位、滾動計算等
          const TRACK_LABEL_WIDTH = 32;

          const DEFAULT_PX_PER_SEC = 200;
          const MIN_PX_PER_SEC = 50;
          const MAX_PX_PER_SEC = 800;
          const MAX_DURATION = 300; // 最大時長 5 分鐘
          const HISTORY_LIMIT = 50;
          const LONG_PRESS_DELAY = 350;
          const MOBILE_DRAG_DELAY = 200;
          const WAVEFORM_SAMPLES_PER_SEC = 120; // 波型解析度：每秒多少個樣本點

          // === 狀態 ===
          let isOpen = false;
          let isPlaying = false;
          let playheadTime = 0; // 秒（authoritative source of truth）
          let pxPerSec = DEFAULT_PX_PER_SEC;
          let totalDuration = 30; // 動態計算
          let clips = []; // { id, soundId, trackIndex, startTime, trimStart, trimEnd, duration }
          let selectedClipId = null;
          let undoStack = [];
          let redoStack = [];
          
          // 音訊播放
          let audioContext = null;
          let scheduledSources = [];
          let playStartTime = 0; // audioContext.currentTime when play started
          let playStartPosition = 0; // playheadTime when play started
          let animationFrameId = null;

          // 拖曳狀態
          let dragState = null;
          let longPressTimer = null;

          // Audio buffer 快取
          const audioBufferCache = new Map();
          // 波型資料快取
          const waveformCache = new Map();

          // === 工具函式 ===
          const genId = () => 'clip-' + Math.random().toString(36).slice(2, 10);
          const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
          const formatTime = (s) => {
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            const ms = Math.floor((s % 1) * 100);
            return `${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}.${String(ms).padStart(2, '0')}`;
          };

          // === localStorage 持久化 ===
          const saveState = () => {
            try {
              const data = {
                version: 1,
                playheadTime,
                pxPerSec,
                clips: clips.map(c => ({ ...c })),
                undoStack: undoStack.slice(-HISTORY_LIMIT),
                redoStack: redoStack.slice(-HISTORY_LIMIT)
              };
              localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch (e) { console.warn('[demaPanel] save failed', e); }
          };

          const loadState = () => {
            try {
              const raw = localStorage.getItem(STORAGE_KEY);
              if (!raw) return;
              const data = JSON.parse(raw);
              if (data.version !== 1) return;
              playheadTime = data.playheadTime ?? 0;
              pxPerSec = clamp(data.pxPerSec ?? DEFAULT_PX_PER_SEC, MIN_PX_PER_SEC, MAX_PX_PER_SEC);
              clips = (data.clips || []).filter(c => c && c.id && c.soundId);
              undoStack = data.undoStack || [];
              redoStack = data.redoStack || [];
            } catch (e) { console.warn('[demaPanel] load failed', e); }
          };

          // === 歷史紀錄（Undo/Redo）===
          /**
           * 歷史紀錄系統說明：
           * 
           * undoStack: 儲存「編輯前」的狀態快照（JSON 字串）
           * redoStack: 儲存被 undo 的狀態
           * 
           * 流程：
           * 1. 開始編輯前：呼叫 pushHistory() 儲存當前狀態
           * 2. 執行編輯：修改 clips 陣列
           * 3. 編輯完成：呼叫 saveState() 儲存到 localStorage
           * 
           * Undo 流程：
           * 1. 把當前狀態 push 到 redoStack
           * 2. 從 undoStack pop 出之前的狀態
           * 3. 套用該狀態並重新渲染
           * 
           * Redo 流程：
           * 1. 把當前狀態 push 到 undoStack
           * 2. 從 redoStack pop 出之前的狀態
           * 3. 套用該狀態並重新渲染
           */
          
          /**
           * 在編輯操作開始「之前」呼叫，儲存當前狀態作為可復原的快照
           * 注意：必須在任何修改 clips 之前呼叫
           */
          const pushHistory = () => {
            undoStack.push(JSON.stringify(clips));
            if (undoStack.length > HISTORY_LIMIT) undoStack.shift();
            // 新的編輯會清空 redo 堆疊（因為時間線分支了）
            redoStack = [];
            updateHistoryButtons();
          };

          /**
           * 復原到上一個狀態
           */
          const undo = () => {
            if (!undoStack.length) return;
            // 先儲存當前狀態到 redoStack，以便可以 redo 回來
            redoStack.push(JSON.stringify(clips));
            // 從 undoStack 取出之前的狀態
            clips = JSON.parse(undoStack.pop());
            selectedClipId = null; // 清除選擇以避免指向已刪除的 clip
            updateHistoryButtons();
            renderClips();
            saveState();
          };

          /**
           * 重做被復原的操作
           */
          const redo = () => {
            if (!redoStack.length) return;
            // 先儲存當前狀態到 undoStack
            undoStack.push(JSON.stringify(clips));
            // 從 redoStack 取出之前的狀態
            clips = JSON.parse(redoStack.pop());
            selectedClipId = null;
            updateHistoryButtons();
            renderClips();
            saveState();
          };

          /**
           * 更新 Undo/Redo 按鈕的啟用/禁用狀態
           */
          const updateHistoryButtons = () => {
            if (els.demaUndo) els.demaUndo.disabled = !undoStack.length;
            if (els.demaRedo) els.demaRedo.disabled = !redoStack.length;
          };

          // === 音訊載入與解碼 ===
          const getAudioContext = () => {
            if (!audioContext) {
              audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
              audioContext.resume();
            }
            return audioContext;
          };

          const loadAudioBuffer = async (url) => {
            if (audioBufferCache.has(url)) {
              return audioBufferCache.get(url);
            }
            const ctx = getAudioContext();
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
            audioBufferCache.set(url, audioBuffer);
            // 同時生成波型資料
            generateWaveformData(url, audioBuffer);
            return audioBuffer;
          };

          // 生成波型資料（簡化版，取樣降低解析度）
          
          const generateWaveformData = (url, audioBuffer) => {
            if (waveformCache.has(url)) return;
            const rawData = audioBuffer.getChannelData(0);
            const duration = audioBuffer.duration;
            const totalSamples = Math.ceil(duration * WAVEFORM_SAMPLES_PER_SEC);
            const blockSize = Math.floor(rawData.length / totalSamples);
            const waveform = [];
            for (let i = 0; i < totalSamples; i++) {
              let sum = 0;
              const start = i * blockSize;
              for (let j = 0; j < blockSize; j++) {
                sum += Math.abs(rawData[start + j] || 0);
              }
              waveform.push(sum / blockSize);
            }
            // 正規化
            const max = Math.max(...waveform, 0.01);
            const normalized = waveform.map(v => v / max);
            // 儲存波型資料和音訊時長
            waveformCache.set(url, { data: normalized, duration });
          };

          // 繪製波型到 Canvas（根據 trim 裁切正確區段）
          const drawWaveform = (canvas, url, trimStart, trimEnd, audioDuration) => {
            const cached = waveformCache.get(url);
            if (!cached || !canvas) return;
            
            const { data: waveform, duration: fullDuration } = cached;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerY = height / 2;
            
            ctx.clearRect(0, 0, width, height);
            // 白色波型，較高對比度
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            
            // 計算要繪製的波型範圍（根據 trim）
            const startRatio = trimStart / fullDuration;
            const endRatio = 1 - (trimEnd / fullDuration);
            const startIdx = Math.floor(startRatio * waveform.length);
            const endIdx = Math.ceil(endRatio * waveform.length);
            const visibleSamples = endIdx - startIdx;
            
            if (visibleSamples <= 0) return;
            
            // 每個樣本在 canvas 上的寬度
            const barWidth = width / visibleSamples;
            
            for (let i = 0; i < visibleSamples; i++) {
              const sampleIdx = startIdx + i;
              if (sampleIdx >= waveform.length) break;
              const x = i * barWidth;
              const barHeight = waveform[sampleIdx] * height * 0.85;
              ctx.fillRect(x, centerY - barHeight / 2, Math.max(1, barWidth - 0.5), barHeight);
            }
          };

          // === 播放控制 ===
          const play = async () => {
            if (isPlaying) return;
            if (clips.length === 0) return;

            const ctx = getAudioContext();
            isPlaying = true;
            playStartTime = ctx.currentTime;
            playStartPosition = playheadTime;
            scheduledSources = [];

            // 計算結束時間
            const endTime = calculateTotalDuration();
            if (playheadTime >= endTime) {
              playheadTime = 0;
              playStartPosition = 0;
            }

            // 為每個 clip 建立音源
            for (const clip of clips) {
              const snd = state.soundMap.get(clip.soundId);
              if (!snd) continue;

              try {
                const buffer = await loadAudioBuffer(snd.src);
                const source = ctx.createBufferSource();
                source.buffer = buffer;
                
                // 套用音量：全域音量 * 片段音量
                const gainNode = ctx.createGain();
                const clipVolume = clip.volume ?? 1;
                gainNode.gain.value = (state.globalVolume ?? 1) * clipVolume;
                source.connect(gainNode);
                gainNode.connect(ctx.destination);

                // 計算播放時間
                const clipStart = clip.startTime;
                const clipDuration = clip.duration - clip.trimStart - clip.trimEnd;
                const clipEnd = clipStart + clipDuration;

                // 如果 playhead 已經超過此 clip，跳過
                if (playheadTime >= clipEnd) continue;

                // 計算 offset 和 when
                let offset = clip.trimStart;
                let when = 0;
                let duration = clipDuration;

                if (playheadTime > clipStart) {
                  // playhead 在 clip 中間
                  offset += (playheadTime - clipStart);
                  duration = clipEnd - playheadTime;
                } else {
                  // playhead 在 clip 之前
                  when = clipStart - playheadTime;
                }

                if (duration > 0) {
                  source.start(ctx.currentTime + when, offset, duration);
                  scheduledSources.push({ source, gainNode });
                }
              } catch (e) {
                console.warn('[demaPanel] failed to play clip', clip.id, e);
              }
            }

            updatePlayPauseIcon();
            startPlayheadAnimation();
          };

          const pause = () => {
            if (!isPlaying) return;
            isPlaying = false;

            // 停止所有音源
            for (const { source } of scheduledSources) {
              try {
                source.stop();
              } catch {
                // 預期行為：音源可能已自然結束或已停止
              }
            }
            scheduledSources = [];

            // 更新 playhead 位置
            if (audioContext) {
              playheadTime = playStartPosition + (audioContext.currentTime - playStartTime);
            }

            stopPlayheadAnimation();
            updatePlayPauseIcon();
            renderPlayhead();
            saveState();
          };

          const stop = () => {
            pause();
            playheadTime = 0;
            renderPlayhead();
            updateTimeDisplay();
            saveState();
          };

          const skipToStart = () => {
            const wasPlaying = isPlaying;
            if (isPlaying) pause();

            let targetTime = 0;
            
            // 尋找 playhead 之前的所有 clips (startTime < playheadTime)
            // 加一點緩衝 (0.01s) 避免浮點數誤差，並確保如果剛好在開頭會跳到更前一個
            const previousClips = clips.filter(c => c.startTime < playheadTime - 0.01);

            if (previousClips.length > 0) {
              // 排序找出最接近 playhead 的 (startTime 最大)
              previousClips.sort((a, b) => b.startTime - a.startTime);
              targetTime = previousClips[0].startTime;
            } else {
              // 如果前面沒有 clip，跳回 0
              targetTime = 0;
            }

            playheadTime = targetTime;
            renderPlayhead();
            updateTimeDisplay();

            // 滾動視圖到 playhead 位置 (置中)
            const scrollContainer = els.demaTracksScroll?.parentElement;
            if (scrollContainer) {
              const px = playheadTime * pxPerSec;
              const scrollLeft = (px + TRACK_LABEL_WIDTH) - (scrollContainer.clientWidth / 2);
              scrollContainer.scrollLeft = Math.max(0, scrollLeft);
            }

            if (wasPlaying) play();
          };

          const skipToNext = () => {
            const wasPlaying = isPlaying;
            if (isPlaying) pause();

            let targetTime = totalDuration;
            
            // 1. 尋找 playhead 之後的所有 clips
            // 我們關注的是 clip 的 startTime
            const nextClips = clips.filter(c => c.startTime > playheadTime + 0.01); // 加一點緩衝避免原地踏步

            if (nextClips.length > 0) {
              // 排序找出最接近 playhead 的 (startTime 最小)
              nextClips.sort((a, b) => a.startTime - b.startTime);
              targetTime = nextClips[0].startTime;
            } else {
              // 如果後面沒有 clip，跳到全體軌道上時間最晚的 clip 的結尾
              if (clips.length > 0) {
                let maxEnd = 0;
                for (const clip of clips) {
                  const duration = clip.duration - clip.trimStart - clip.trimEnd;
                  const end = clip.startTime + duration;
                  if (end > maxEnd) maxEnd = end;
                }
                targetTime = maxEnd;
              } else {
                targetTime = totalDuration;
              }
            }

            playheadTime = targetTime;
            renderPlayhead();
            updateTimeDisplay();

            // 滾動視圖到 playhead 位置 (置中)
            const scrollContainer = els.demaTracksScroll?.parentElement;
            if (scrollContainer) {
              const px = playheadTime * pxPerSec;
              const scrollLeft = (px + TRACK_LABEL_WIDTH) - (scrollContainer.clientWidth / 2);
              scrollContainer.scrollLeft = Math.max(0, scrollLeft);
            }

            if (wasPlaying) play();
          };

          const updatePlayPauseIcon = () => {
            if (els.demaPlayIcon) els.demaPlayIcon.style.display = isPlaying ? 'none' : 'block';
            if (els.demaPauseIcon) els.demaPauseIcon.style.display = isPlaying ? 'block' : 'none';
            
            if (els.demaPlayPause) {
              els.demaPlayPause.style.background = isPlaying ? 'var(--accent-2)' : 'var(--accent)';
              els.demaPlayPause.style.borderColor = isPlaying ? 'var(--accent-2)' : 'var(--accent)';
            }
          };

          // === Playhead 動畫 ===
          const startPlayheadAnimation = () => {
            const animate = () => {
              if (!isPlaying) return;

              const ctx = getAudioContext();
              playheadTime = playStartPosition + (ctx.currentTime - playStartTime);

              const endTime = calculateTotalDuration();
              if (playheadTime >= endTime) {
                playheadTime = endTime;
                pause();
                return;
              }

              renderPlayhead();
              updateTimeDisplay();
              animationFrameId = requestAnimationFrame(animate);
            };
            animationFrameId = requestAnimationFrame(animate);
          };

          const stopPlayheadAnimation = () => {
            if (animationFrameId) {
              cancelAnimationFrame(animationFrameId);
              animationFrameId = null;
            }
          };

          // === 計算總時長 ===
          const calculateTotalDuration = () => {
            if (clips.length === 0) return 30;
            let maxEnd = 0;
            for (const clip of clips) {
              const end = clip.startTime + (clip.duration - clip.trimStart - clip.trimEnd);
              if (end > maxEnd) maxEnd = end;
            }
            return Math.max(30, Math.ceil(maxEnd) + 5);
          };

          // === 渲染函式 ===
          const renderTimeline = () => {
            const canvas = els.demaTimelineCanvas;
            if (!canvas) return;

            const container = canvas.parentElement;
            // Canvas 總寬度 = 時間軸寬度 + 左側標籤區寬度（TRACK_LABEL_WIDTH）
            const width = totalDuration * pxPerSec + TRACK_LABEL_WIDTH;
            // 從 CSS 取得實際高度，避免拉伸
            const cssHeight = container?.clientHeight || 25;
            const height = cssHeight;
            
            // 設定 canvas 實際像素大小（避免模糊和拉伸）
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            ctx.clearRect(0, 0, width, height);

            // 取得 CSS 變數顏色
            const style = getComputedStyle(document.documentElement);
            const fg = style.getPropertyValue('--fg').trim() || '#e9eef5';
            const muted = style.getPropertyValue('--muted').trim() || '#a8b3c7';

            ctx.font = '10px ui-sans-serif, system-ui, sans-serif';
            ctx.textBaseline = 'middle';

            // 根據縮放級別決定刻度間隔
            let interval = 1; // 秒
            if (pxPerSec < 80) interval = 5;
            else if (pxPerSec < 150) interval = 2;
            else if (pxPerSec < 300) interval = 1;
            else if (pxPerSec < 500) interval = 0.5;
            else interval = 0.25;

            const tickHeight = 6;
            const textY = height / 2; // 文字垂直置中

            for (let t = 0; t <= totalDuration; t += interval) {
              // 刻度 x 座標 = 標籤寬度偏移 + 時間對應的像素位置
              const x = TRACK_LABEL_WIDTH + t * pxPerSec;
              
              // 主刻度線（從底部向上）
              ctx.fillStyle = muted;
              ctx.fillRect(x, height - tickHeight, 1, tickHeight);
              
              // 時間文字（對齊刻度線）
              if (t % (interval < 1 ? 1 : interval) === 0 || interval >= 1) {
                const text = formatTime(t).slice(0, 5); // 只顯示 mm:ss
                ctx.fillStyle = fg;
                ctx.fillText(text, x + 3, textY);
              }
            }
          };

          const renderPlayhead = () => {
            if (!els.demaPlayhead) return;
            // Playhead x 座標 = 標籤寬度偏移 + 播放時間對應的像素位置
            const x = TRACK_LABEL_WIDTH + playheadTime * pxPerSec;
            els.demaPlayhead.style.left = x + 'px';
          };

          const updateTimeDisplay = () => {
            if (!els.demaTime) return;
            totalDuration = calculateTotalDuration();
            els.demaTime.textContent = `${formatTime(playheadTime)} / ${formatTime(totalDuration)}`;
          };

          // 用於拖曳時避免重新渲染導致事件丟失
          let isDragging = false;

          const renderClips = () => {
            // 如果正在拖曳中，只更新位置不重建 DOM
            if (isDragging) {
              updateClipPositions();
              return;
            }

            // 清空所有音軌內容
            els.demaTrackContents.forEach(tc => tc.innerHTML = '');
            
            // 更新空狀態
            if (els.demaEmpty) {
              els.demaEmpty.style.display = clips.length === 0 ? 'flex' : 'none';
            }

            // 渲染每個 clip
            for (const clip of clips) {
              const snd = state.soundMap.get(clip.soundId);
              if (!snd) continue;

              const trackContent = document.querySelector(`[data-track-content="${clip.trackIndex}"]`);
              if (!trackContent) continue;

              // 取得 streamer 標籤顏色
              let color = '#6aa9ff';
              for (const tagKey of snd.tags) {
                const tag = state.tags[utils.slug(tagKey)];
                if (tag?.role === 'streamer' && tag.color) {
                  color = tag.color;
                  break;
                }
              }

              const clipDuration = clip.duration - clip.trimStart - clip.trimEnd;
              const width = Math.max(20, clipDuration * pxPerSec);
              const left = clip.startTime * pxPerSec;

              // 建立波型 canvas（高度配合音軌高度 30px - 4px padding = 26px）
              const waveCanvas = document.createElement('canvas');
              waveCanvas.width = Math.max(20, Math.floor(width));
              waveCanvas.height = 26;
              waveCanvas.className = 'dema-clip-wave-canvas';

              const clipEl = dom.el('div', {
                class: `dema-clip${clip.id === selectedClipId ? ' selected' : ''}`,
                'data-clip-id': clip.id,
                style: {
                  left: left + 'px',
                  width: width + 'px',
                  background: color
                }
              }, [
                dom.el('div', { class: 'dema-clip-wave' }, [waveCanvas]),
                dom.el('div', { class: 'dema-clip-label' }, snd.title),
                dom.el('div', { class: 'dema-clip-handle dema-clip-handle--left' }),
                dom.el('div', { class: 'dema-clip-handle dema-clip-handle--right' })
              ]);

              // 繪製波型
              if (waveformCache.has(snd.src)) {
                drawWaveform(waveCanvas, snd.src, clip.trimStart, clip.trimEnd, clip.duration);
              } else {
                // 非同步載入並繪製
                loadAudioBuffer(snd.src).then(() => {
                  drawWaveform(waveCanvas, snd.src, clip.trimStart, clip.trimEnd, clip.duration);
                }).catch((e) => {
                  console.warn('[demaPanel] 無法載入音訊波型', snd.src, e);
                });
              }

              // 事件綁定
              clipEl.addEventListener('pointerdown', e => onClipPointerDown(e, clip));
              clipEl.addEventListener('dblclick', e => onClipDoubleClick(e, clip));

              trackContent.appendChild(clipEl);
            }

            // 更新音軌容器寬度
            updateTracksWidth();
            updateTimeDisplay();
            updateRemoveSelectedBtn();
            updateVolumeSlider();
          };

          // 只更新 clip 位置（用於拖曳時）
          const updateClipPositions = () => {
            for (const clip of clips) {
              const clipEl = document.querySelector(`[data-clip-id="${clip.id}"]`);
              if (!clipEl) continue;

              const clipDuration = clip.duration - clip.trimStart - clip.trimEnd;
              const width = Math.max(20, clipDuration * pxPerSec);
              const left = clip.startTime * pxPerSec;

              clipEl.style.left = left + 'px';
              clipEl.style.width = width + 'px';

              // 更新選中狀態
              clipEl.classList.toggle('selected', clip.id === selectedClipId);

              // 檢查是否需要移動到其他音軌
              const currentTrack = clipEl.closest('[data-track-content]');
              const targetTrack = document.querySelector(`[data-track-content="${clip.trackIndex}"]`);
              if (currentTrack && targetTrack && currentTrack !== targetTrack) {
                targetTrack.appendChild(clipEl);
              }

              // Trim 時需要重繪波型
              const waveCanvas = clipEl.querySelector('.dema-clip-wave-canvas');
              if (waveCanvas) {
                const snd = state.soundMap.get(clip.soundId);
                if (snd) {
                  // 更新 canvas 尺寸
                  waveCanvas.width = Math.max(20, Math.floor(width));
                  drawWaveform(waveCanvas, snd.src, clip.trimStart, clip.trimEnd, clip.duration);
                }
              }
            }
            updateTimeDisplay();
          };

          // 更新「移除選擇」按鈕狀態
          const updateRemoveSelectedBtn = () => {
            if (els.demaRemoveSelected) {
              els.demaRemoveSelected.disabled = !selectedClipId;
            }
          };

          // 更新片段音量滑桿
          const updateVolumeSlider = () => {
            if (!els.demaClipVolumeWrap) return;
            
            if (!selectedClipId) {
              els.demaClipVolumeWrap.style.display = 'none';
              return;
            }

            const clip = clips.find(c => c.id === selectedClipId);
            if (!clip) {
              els.demaClipVolumeWrap.style.display = 'none';
              return;
            }

            els.demaClipVolumeWrap.style.display = 'flex';
            const volumePercent = Math.round((clip.volume ?? 1) * 100);
            els.demaClipVolume.value = volumePercent;
            els.demaClipVolumeValue.textContent = volumePercent + '%';
          };

          const updateTracksWidth = () => {
            totalDuration = calculateTotalDuration();
            const width = totalDuration * pxPerSec + TRACK_LABEL_WIDTH;
            if (els.demaTracksScroll) {
              els.demaTracksScroll.style.minWidth = width + 'px';
            }
            renderTimeline();
          };

          // === Clip 操作 ===
          const addClip = async (snd, trackIndex = 0, startTime = null) => {
            // 載入音訊以取得時長
            let duration = 3; // 預設 3 秒
            try {
              const buffer = await loadAudioBuffer(snd.src);
              duration = buffer.duration;
            } catch (e) {
              console.warn('[demaPanel] failed to get duration', e);
            }

            const newClip = {
              id: genId(),
              soundId: snd.id,
              trackIndex: clamp(trackIndex, 0, TRACK_COUNT - 1),
              startTime: startTime ?? playheadTime,
              trimStart: 0,
              trimEnd: 0,
              duration,
              volume: 1.0  // 片段音量（1.0 = 100%）
            };

            pushHistory();
            clips.push(newClip);
            selectedClipId = newClip.id;
            renderClips();
            saveState();

            return newClip;
          };

          const removeClip = (clipId) => {
            const idx = clips.findIndex(c => c.id === clipId);
            if (idx === -1) return;
            pushHistory();
            clips.splice(idx, 1);
            if (selectedClipId === clipId) selectedClipId = null;
            renderClips();
            saveState();
          };

          const clearAllClips = () => {
            if (clips.length === 0 && undoStack.length === 0 && redoStack.length === 0) return;
            
            // 建立確認 Modal
            const backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop';
            backdrop.setAttribute('role', 'dialog');
            backdrop.setAttribute('aria-modal', 'true');
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
              <p style="margin: 0 0 var(--space-sm); font-size: 14px;">確定要重置所有音軌嗎？</p>
              <p style="margin: 0 0 var(--space-sm); font-size: 12px; color: var(--muted);">這將清空所有片段和步驟紀錄。</p>
              <div class="modal-actions">
                <button class="btn" data-action="cancel">取消</button>
                <button class="btn" data-action="confirm">確定重置</button>
              </div>
            `;
            backdrop.appendChild(modal);
            document.body.appendChild(backdrop);
            
            // 焦點設到取消按鈕
            modal.querySelector('[data-action="cancel"]').focus();
            
            // 事件處理
            const closeModal = () => backdrop.remove();
            
            backdrop.addEventListener('click', e => {
              if (e.target === backdrop) closeModal();
            });
            
            modal.querySelector('[data-action="cancel"]').addEventListener('click', closeModal);
            
            modal.querySelector('[data-action="confirm"]').addEventListener('click', () => {
              closeModal();
              // 重置所有狀態
              clips = [];
              selectedClipId = null;
              undoStack = [];
              redoStack = [];
              playheadTime = 0;
              renderClips();
              renderPlayhead();
              updateHistoryButtons();
              saveState();
              toast('已重置所有音軌');
            });
            
            // ESC 關閉
            const onKeydown = e => {
              if (e.key === 'Escape') {
                closeModal();
                document.removeEventListener('keydown', onKeydown);
              }
            };
            document.addEventListener('keydown', onKeydown);
          };

          // === 拖曳與 Trim ===
          const onClipPointerDown = (e, clip) => {
            e.stopPropagation();
            e.preventDefault(); // 防止選取文字等預設行為
            
            // 判斷是否在 handle 上
            const target = e.target;
            const isLeftHandle = target.classList.contains('dema-clip-handle--left');
            const isRightHandle = target.classList.contains('dema-clip-handle--right');

            // 選擇此 clip
            selectedClipId = clip.id;
            
            // 更新選中狀態（不重建 DOM）
            document.querySelectorAll('.dema-clip').forEach(el => {
              el.classList.toggle('selected', el.dataset.clipId === clip.id);
            });
            
            // 更新 UI
            updateRemoveSelectedBtn();
            updateVolumeSlider();

            // 準備拖曳
            const clipEl = e.currentTarget;
            const rect = clipEl.getBoundingClientRect();

            // 決定模式
            let mode = 'pending';
            if (isLeftHandle) {
              mode = 'trim-left';
            } else if (isRightHandle) {
              mode = 'trim-right';
            }

            dragState = {
              clipId: clip.id,
              mode: mode,
              startX: e.clientX,
              startY: e.clientY,
              initialStartTime: clip.startTime,
              initialTrimStart: clip.trimStart,
              initialTrimEnd: clip.trimEnd,
              initialTrackIndex: clip.trackIndex,
              moved: false
            };

            // 對於 trim 模式，立即啟動
            if (mode === 'trim-left' || mode === 'trim-right') {
              // 在開始編輯前儲存歷史
              pushHistory();
              isDragging = true;
              clipEl.classList.add('dragging');
            }
            // 移動端：長按才啟動拖曳
            else if (e.pointerType === 'touch') {
              longPressTimer = setTimeout(() => {
                if (dragState && dragState.mode === 'pending') {
                  // 在開始編輯前儲存歷史
                  pushHistory();
                  dragState.mode = 'move';
                  isDragging = true;
                  clipEl.classList.add('dragging');
                }
              }, MOBILE_DRAG_DELAY);
            } else {
              // PC：直接進入移動模式
              // 在開始編輯前儲存歷史
              pushHistory();
              dragState.mode = 'move';
              isDragging = true;
              clipEl.classList.add('dragging');
            }

            // 設置 pointer capture 確保拖曳不會丟失
            clipEl.setPointerCapture(e.pointerId);

            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
            document.addEventListener('pointercancel', onPointerUp);
          };

          const onPointerMove = (e) => {
            if (!dragState) return;

            const dx = e.clientX - dragState.startX;
            const dy = e.clientY - dragState.startY;
            const clip = clips.find(c => c.id === dragState.clipId);
            if (!clip) return;

            // 如果移動超過閾值，取消長按計時並確認為拖曳
            if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
              if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
              }
              if (dragState.mode === 'pending') {
                dragState.mode = 'move';
                isDragging = true;
                const clipEl = document.querySelector(`[data-clip-id="${clip.id}"]`);
                if (clipEl) clipEl.classList.add('dragging');
              }
              dragState.moved = true;
            }

            // 如果還在 pending 狀態，不執行移動
            if (dragState.mode === 'pending') return;

            if (dragState.mode === 'move') {
              // 移動 clip
              const deltaTime = dx / pxPerSec;
              clip.startTime = Math.max(0, dragState.initialStartTime + deltaTime);

              // 跨音軌檢測
              const trackEls = document.querySelectorAll('.dema-track');
              for (let i = 0; i < trackEls.length; i++) {
                const rect = trackEls[i].getBoundingClientRect();
                if (e.clientY >= rect.top && e.clientY <= rect.bottom) {
                  clip.trackIndex = i;
                  break;
                }
              }

              updateClipPositions();
            } else if (dragState.mode === 'trim-left') {
              // 左側 Trim
              const deltaTime = dx / pxPerSec;
              
              // 限制：不能讓 startTime < 0
              // startTime = initialStartTime + (newTrimStart - initialTrimStart)
              // 所以 newTrimStart >= initialTrimStart - initialStartTime
              const minTrimStart = Math.max(0, dragState.initialTrimStart - dragState.initialStartTime);

              const newTrimStart = clamp(
                dragState.initialTrimStart + deltaTime,
                minTrimStart,
                clip.duration - clip.trimEnd - 0.1
              );
              const trimDelta = newTrimStart - dragState.initialTrimStart;
              clip.trimStart = newTrimStart;
              clip.startTime = dragState.initialStartTime + trimDelta;
              updateClipPositions();
            } else if (dragState.mode === 'trim-right') {
              // 右側 Trim
              const deltaTime = dx / pxPerSec;
              clip.trimEnd = clamp(
                dragState.initialTrimEnd - deltaTime,
                0,
                clip.duration - clip.trimStart - 0.1
              );
              updateClipPositions();
            }
          };

          const onPointerUp = (e) => {
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }

            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', onPointerUp);
            document.removeEventListener('pointercancel', onPointerUp);

            // 釋放 pointer capture
            try {
              const clipEl = document.querySelector(`[data-clip-id="${dragState?.clipId}"]`);
              if (clipEl && e.pointerId) clipEl.releasePointerCapture(e.pointerId);
            } catch {
              // 預期行為：capture 可能已釋放或元素已移除
            }

            isDragging = false;

            // 如果有實際移動/編輯，儲存狀態到 localStorage
            // 注意：pushHistory 已經在拖曳開始時呼叫過了
            if (dragState?.moved) {
              saveState();
            }

            // 清除 dragging 狀態
            document.querySelectorAll('.dema-clip.dragging').forEach(el => el.classList.remove('dragging'));
            dragState = null;

            renderClips();
          };

          // === Clip 選單（移動端雙擊/PC右鍵）===
          const onClipDoubleClick = (e, clip) => {
            e.stopPropagation();
            showClipMenu(clip, e.clientX, e.clientY);
          };

          const showClipMenu = (clip, x, y) => {
            const m = els.menu;
            if (!m) return;
            m.innerHTML = '';

            const snd = state.soundMap.get(clip.soundId);
            const playItem = dom.el('div', { class: 'menu-item', role: 'menuitem' }, '▶️ 試聽');
            playItem.addEventListener('click', () => {
              closeMenu();
              if (snd) playSoundObject(snd);
            });

            const removeItem = dom.el('div', { class: 'menu-item', role: 'menuitem' }, '🗑️ 移除');
            removeItem.addEventListener('click', () => {
              closeMenu();
              removeClip(clip.id);
            });

            m.append(playItem, removeItem);
            m.classList.remove('hidden');
            requestAnimationFrame(() => positionMenu(x, y));
          };

          // === 音軌區域事件（拖曳滾動 + 點擊設定 playhead）===
          let tracksDragState = null;

          const onTracksPointerDown = (e) => {
            // 如果點擊的是 clip，不處理滾動
            if (e.target.closest('.dema-clip')) return;
            
            const scrollContainer = els.demaTracksScroll?.parentElement;
            if (!scrollContainer) return;
            
            tracksDragState = {
              startX: e.clientX,
              startY: e.clientY,
              startScrollLeft: scrollContainer.scrollLeft,
              moved: false
            };
            
            scrollContainer.classList.add('dragging');
            scrollContainer.setPointerCapture(e.pointerId);
          };

          const onTracksPointerMove = (e) => {
            if (!tracksDragState) return;
            
            const dx = e.clientX - tracksDragState.startX;
            const dy = e.clientY - tracksDragState.startY;
            
            // 如果移動超過閾值，標記為拖曳
            if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
              tracksDragState.moved = true;
            }
            
            if (tracksDragState.moved) {
              const scrollContainer = els.demaTracksScroll?.parentElement;
              if (scrollContainer) {
                scrollContainer.scrollLeft = tracksDragState.startScrollLeft - dx;
              }
            }
          };

          const onTracksPointerUp = (e) => {
            if (!tracksDragState) return;
            
            const scrollContainer = els.demaTracksScroll?.parentElement;
            if (scrollContainer) {
              scrollContainer.classList.remove('dragging');
              try {
                scrollContainer.releasePointerCapture(e.pointerId);
              } catch {
                // 預期行為：capture 可能已釋放
              }
            }
            
            // 如果沒有移動，視為點擊，設定 playhead
            if (!tracksDragState.moved) {
              onTracksClick(e);
            }
            
            tracksDragState = null;
          };

          const onTracksClick = (e) => {
            // 如果點擊的是 clip，不處理
            if (e.target.closest('.dema-clip')) return;
            
            // 取消選擇
            selectedClipId = null;
            renderClips();

            // 設定 playhead
            // 使用滾動容器（父元素）的 rect，而不是內容區域
            const scrollContainer = els.demaTracksScroll?.parentElement;
            if (!scrollContainer) return;
            
            const rect = scrollContainer.getBoundingClientRect();
            const scrollLeft = scrollContainer.scrollLeft;
            // clientX - rect.left = 點擊位置相對於滾動容器視窗的 x
            // + scrollLeft = 加上已滾動的距離，得到相對於內容起點的 x
            // - TRACK_LABEL_WIDTH = 減去左側標籤寬度，得到相對於時間軸 0 點的 x
            const x = e.clientX - rect.left + scrollLeft - TRACK_LABEL_WIDTH;
            
            if (x >= 0) {
              const wasPlaying = isPlaying;
              if (isPlaying) pause();
              playheadTime = clamp(x / pxPerSec, 0, totalDuration);
              renderPlayhead();
              updateTimeDisplay();
              saveState();
              if (wasPlaying) play();
            }
          };

          // === 縮放控制 ===
          const setZoom = (newPxPerSec) => {
            // 保持 playhead 視覺位置穩定
            const container = els.demaTracksScroll?.parentElement;
            if (!container) return;

            const scrollLeft = container.scrollLeft;
            const viewportCenter = scrollLeft + container.clientWidth / 2;
            const centerTime = (viewportCenter - TRACK_LABEL_WIDTH) / pxPerSec;

            pxPerSec = clamp(newPxPerSec, MIN_PX_PER_SEC, MAX_PX_PER_SEC);

            // 更新滾動位置以保持中心時間不變
            const newScrollLeft = (centerTime * pxPerSec + TRACK_LABEL_WIDTH) - container.clientWidth / 2;
            container.scrollLeft = Math.max(0, newScrollLeft);

            renderClips();
            renderPlayhead();
            saveState();

            if (els.demaZoom) els.demaZoom.value = pxPerSec;
          };

          // === 面板開關 ===
          const open = () => {
            if (isOpen) return;
            isOpen = true;
            els.demaPanel?.classList.add('open');
            els.demaPanel?.setAttribute('aria-hidden', 'false');
            document.body.classList.add('dema-open');
            renderClips();
            renderPlayhead();
            updateTimeDisplay();
          };

          const close = () => {
            if (!isOpen) return;
            pause();
            isOpen = false;
            els.demaPanel?.classList.remove('open');
            els.demaPanel?.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('dema-open');
          };

          const toggle = () => isOpen ? close() : open();

          // === 公開 API：加入音效 ===
          const addSoundToTrack = async (snd, trackIndex = 0) => {
            if (!isOpen) open();
            await addClip(snd, trackIndex);
          };

          // === 初始化 ===
          const init = () => {
            loadState();

            // 按鈕事件
            els.openDemaBtn?.addEventListener('click', open);
            els.demaClose?.addEventListener('click', close);
            els.demaPlayPause?.addEventListener('click', () => isPlaying ? pause() : play());
            els.demaSkipNext?.addEventListener('click', skipToNext);
            els.demaSkipBack?.addEventListener('click', skipToStart);
            els.demaUndo?.addEventListener('click', undo);
            els.demaRedo?.addEventListener('click', redo);
            els.demaClear?.addEventListener('click', clearAllClips);
            els.demaRemoveSelected?.addEventListener('click', () => {
              if (selectedClipId) removeClip(selectedClipId);
            });

            // 縮放滑桿
            els.demaZoom?.addEventListener('input', (e) => {
              setZoom(parseInt(e.target.value, 10));
            });
            if (els.demaZoom) els.demaZoom.value = pxPerSec;

            // 片段音量滑桿 - 開始拖曳時儲存歷史
            let volumeHistorySaved = false;
            els.demaClipVolume?.addEventListener('pointerdown', () => {
              volumeHistorySaved = false;
            });
            
            els.demaClipVolume?.addEventListener('input', (e) => {
              if (!selectedClipId) return;
              const clip = clips.find(c => c.id === selectedClipId);
              if (!clip) return;
              
              // 首次變更時儲存歷史
              if (!volumeHistorySaved) {
                pushHistory();
                volumeHistorySaved = true;
              }
              
              const volumePercent = parseInt(e.target.value, 10);
              clip.volume = volumePercent / 100;
              els.demaClipVolumeValue.textContent = volumePercent + '%';
              saveState();
            });

            // 音軌區域拖曳滾動 + 點擊
            const tracksWrap = els.demaTracksScroll?.parentElement;
            if (tracksWrap) {
              tracksWrap.addEventListener('pointerdown', onTracksPointerDown);
              tracksWrap.addEventListener('pointermove', onTracksPointerMove);
              tracksWrap.addEventListener('pointerup', onTracksPointerUp);
              tracksWrap.addEventListener('pointercancel', onTracksPointerUp);
            }

            // 鍵盤快捷鍵
            document.addEventListener('keydown', (e) => {
              if (!isOpen) return;
              // 檢查是否在輸入框內
              if (e.target.matches('input, textarea, [contenteditable]')) return;

              if (e.key === ' ') {
                e.preventDefault();
                isPlaying ? pause() : play();
              } else if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedClipId) {
                  e.preventDefault();
                  removeClip(selectedClipId);
                }
              } else if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') {
                  e.preventDefault();
                  if (e.shiftKey) redo();
                  else undo();
                } else if (e.key === 'y') {
                  e.preventDefault();
                  redo();
                }
              }
            });

            // 初始渲染
            updateHistoryButtons();
            updateTracksWidth();
            renderClips();
            renderPlayhead();
            updateTimeDisplay();

            console.info('[demaPanel] initialized');
          };

          // 延遲初始化（等待 DOM 準備）
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
          } else {
            setTimeout(init, 0);
          }

          // 公開 API
          return {
            open,
            close,
            toggle,
            addSoundToTrack,
            play,
            pause,
            stop
          };
        })();

        /* =======================================================================
           16. 控制台診斷系統 (SoundboardDebug)
           
           提供開發者在瀏覽器控制台檢查應用程式狀態、執行測試的工具。
           使用方式：在控制台輸入 SoundboardDebug.help() 獲取指南。
           ======================================================================= */

        const SoundboardDebug = (() => {
          const VERSION = '1.0.0';

          // ===== 工具函式 =====
          const fmt = {
            title: (text) => console.log(`%c═══ ${text} ═══`, 'color: #6aa9ff; font-weight: bold; font-size: 14px;'),
            section: (text) => console.log(`%c▸ ${text}`, 'color: #ff9e6a; font-weight: bold;'),
            ok: (text) => console.log(`%c✅ ${text}`, 'color: #4ade80;'),
            warn: (text) => console.log(`%c⚠️ ${text}`, 'color: #fbbf24;'),
            error: (text) => console.log(`%c❌ ${text}`, 'color: #f87171;'),
            info: (text) => console.log(`%cℹ️ ${text}`, 'color: #94a3b8;'),
            list: (items, indent = '   ') => items.forEach(item => console.log(`${indent}• ${item}`))
          };

          // ===== A. 狀態報告 =====
          const status = () => {
            fmt.title('📊 音效板狀態報告');

            // A.1 音效數量統計
            fmt.section('音效統計');
            console.log(`   載入音效數量: ${state.sounds.length} 筆`);
            console.log(`   soundMap 大小: ${state.soundMap.size} 筆`);
            console.log(`   最愛數量: ${state.favorites.length} 筆`);
            console.log(`   目前顯示列表: ${state.displayList.length} 筆`);
            console.log(`   已渲染數量: ${state.renderedCount} 筆`);

            // A.2 標籤統計
            fmt.section('標籤統計');
            console.log(`   tags.json 定義: ${state.tagList.length} 個`);
            console.log(`   實際被使用: ${state.usedTagList.length} 個`);

            // A.3 孤兒標籤檢測（音效使用但 tags.json 未定義）
            const definedKeys = new Set(state.tagList.map(t => t.key));
            const usedInSounds = new Set();
            state.sounds.forEach(snd => snd.tags.forEach(t => usedInSounds.add(utils.slug(t))));
            const orphanTags = [...usedInSounds].filter(k => !definedKeys.has(k));

            if (orphanTags.length > 0) {
              fmt.warn(`孤兒標籤 (音效使用但未在 tags.json 定義): ${orphanTags.length} 個`);
              fmt.list(orphanTags);
            } else {
              fmt.ok('無孤兒標籤');
            }

            // A.4 未使用標籤（tags.json 定義但沒有音效使用）
            const unusedTags = state.tagList.filter(t => !usedInSounds.has(t.key)).map(t => t.key);
            if (unusedTags.length > 0) {
              fmt.info(`未使用標籤 (已定義但無音效使用): ${unusedTags.length} 個`);
              fmt.list(unusedTags);
            }

            // A.5 重複 ID 檢測
            const idCounts = {};
            state.sounds.forEach(s => { idCounts[s.id] = (idCounts[s.id] || 0) + 1; });
            const duplicateIds = Object.entries(idCounts).filter(([, c]) => c > 1).map(([id, c]) => `${id} (${c}次)`);
            if (duplicateIds.length > 0) {
              fmt.error(`重複 ID: ${duplicateIds.length} 個`);
              fmt.list(duplicateIds);
            } else {
              fmt.ok('無重複 ID');
            }

            // A.6 其他狀態
            fmt.section('其他狀態');
            console.log(`   目前頁面: ${state.page}`);
            console.log(`   排序模式: ${state.isSorting ? '是' : '否'}`);
            console.log(`   全域音量: ${Math.round(state.globalVolume * 100)}%`);
            console.log(`   收到的分享列表: ${state.receivedList.length} 筆`);

            console.log('');
            return { soundCount: state.sounds.length, orphanTags, unusedTags, duplicateIds };
          };

          // ===== B. 測試系統 =====
          const test = {
            /**
             * 檢查所有音效檔案是否存在
             * @param {Object} options - 選項
             * @param {boolean} options.verbose - 是否顯示每個檔案的結果
             * @param {number} options.concurrency - 並發請求數量
             */
            checkFiles: (options = {}) => {
              const { verbose = false, concurrency = 10 } = options;

              fmt.title('🔍 檔案存在性測試');
              console.log(`   測試 ${state.sounds.length} 個音效檔案...`);
              console.log(`   並發數: ${concurrency}`);
              console.log('');

              const results = { ok: [], missing: [], error: [] };
              let completed = 0;

              const checkFile = async (snd) => {
                try {
                  const resp = await fetch(snd.src, { method: 'HEAD' });
                  if (resp.ok) {
                    results.ok.push(snd);
                    if (verbose) fmt.ok(`${snd.file}`);
                  } else {
                    results.missing.push({ snd, status: resp.status });
                    fmt.error(`${snd.file} (HTTP ${resp.status})`);
                  }
                } catch (e) {
                  results.error.push({ snd, error: e.message });
                  fmt.error(`${snd.file} (${e.message})`);
                }
                completed++;
                if (completed % 100 === 0 || completed === state.sounds.length) {
                  console.log(`   進度: ${completed}/${state.sounds.length}`);
                }
              };

              // 使用並發控制執行
              (async () => {
                const queue = [...state.sounds];
                const workers = [];

                for (let i = 0; i < concurrency; i++) {
                  workers.push((async () => {
                    while (queue.length > 0) {
                      const snd = queue.shift();
                      if (snd) await checkFile(snd);
                    }
                  })());
                }

                await Promise.all(workers);

                // 輸出結果摘要
                console.log('');
                fmt.section('測試結果摘要');
                fmt.ok(`正常: ${results.ok.length} 筆`);
                if (results.missing.length > 0) {
                  fmt.error(`缺失: ${results.missing.length} 筆`);
                  results.missing.forEach(({ snd, status }) => {
                    console.log(`      • ${snd.file} (HTTP ${status})`);
                  });
                }
                if (results.error.length > 0) {
                  fmt.warn(`錯誤: ${results.error.length} 筆`);
                  results.error.forEach(({ snd, error }) => {
                    console.log(`      • ${snd.file} (${error})`);
                  });
                }

                console.log('');
                console.log('💡 結果已存入: SoundboardDebug.lastTestResult');
                window.SoundboardDebug.lastTestResult = results;
              })();

              return '測試執行中，請等待結果...';
            },

            /** 檢查標籤參照完整性 */
            checkTags: () => {
              fmt.title('🏷️ 標籤完整性測試');

              const definedKeys = new Set(state.tagList.map(t => t.key));
              const issues = [];

              state.sounds.forEach(snd => {
                snd.tags.forEach(tag => {
                  const key = utils.slug(tag);
                  if (!definedKeys.has(key)) {
                    issues.push({ sound: snd.title, soundId: snd.id, tag, tagKey: key });
                  }
                });
              });

              if (issues.length === 0) {
                fmt.ok('所有標籤參照都有效');
              } else {
                fmt.error(`發現 ${issues.length} 個無效標籤參照:`);
                const grouped = {};
                issues.forEach(i => {
                  if (!grouped[i.tagKey]) grouped[i.tagKey] = [];
                  grouped[i.tagKey].push(i.sound);
                });
                Object.entries(grouped).forEach(([tagKey, sounds]) => {
                  console.log(`   • "${tagKey}" 被 ${sounds.length} 個音效使用`);
                  if (sounds.length <= 5) {
                    sounds.forEach(s => console.log(`      - ${s}`));
                  } else {
                    sounds.slice(0, 3).forEach(s => console.log(`      - ${s}`));
                    console.log(`      ... 還有 ${sounds.length - 3} 個`);
                  }
                });
              }

              console.log('');
              return { valid: issues.length === 0, issues };
            },

            /** 檢查 ID 唯一性 */
            checkIds: () => {
              fmt.title('🔑 ID 唯一性測試');

              const idMap = {};
              state.sounds.forEach(snd => {
                if (!idMap[snd.id]) idMap[snd.id] = [];
                idMap[snd.id].push(snd);
              });

              const duplicates = Object.entries(idMap).filter(([, arr]) => arr.length > 1);

              if (duplicates.length === 0) {
                fmt.ok(`所有 ${state.sounds.length} 個音效 ID 都是唯一的`);
              } else {
                fmt.error(`發現 ${duplicates.length} 組重複 ID:`);
                duplicates.forEach(([id, sounds]) => {
                  console.log(`   • ID "${id}" 出現 ${sounds.length} 次:`);
                  sounds.forEach(s => console.log(`      - ${s.title} (${s.file})`));
                });
              }

              console.log('');
              return { valid: duplicates.length === 0, duplicates };
            },

            /** 執行所有測試 */
            all: () => {
              fmt.title('🧪 執行所有測試');
              console.log('');

              test.checkIds();
              test.checkTags();

              console.log('');
              fmt.info('檔案存在性測試需要網路請求，請執行:');
              console.log('   SoundboardDebug.test.checkFiles()');
              console.log('');
            }
          };

          // ===== C. 狀態檢視器 =====
          const inspect = {
            /** 查看完整 state 物件 */
            state: () => {
              fmt.title('📦 應用程式狀態 (state)');
              console.log(state);
              return state;
            },

            /** 查看特定音效詳情 */
            sound: (idOrIndex) => {
              let snd;
              if (typeof idOrIndex === 'number') {
                snd = state.sounds[idOrIndex];
              } else {
                snd = state.soundMap.get(idOrIndex);
              }

              if (!snd) {
                fmt.error(`找不到音效: ${idOrIndex}`);
                return null;
              }

              fmt.title(`🔊 音效詳情: ${snd.title}`);
              console.log('   ID:', snd.id);
              console.log('   檔案:', snd.file);
              console.log('   來源:', snd.src);
              console.log('   標籤:', snd.tags.join(', '));
              console.log('   是否最愛:', state.favSet.has(snd.id) ? '是' : '否');
              console.log('');
              console.log('完整物件:');
              console.log(snd);
              return snd;
            },

            /** 查看特定標籤詳情 */
            tag: (key) => {
              const tagKey = utils.slug(key);
              const tagDef = state.tags[tagKey];

              if (!tagDef) {
                fmt.error(`找不到標籤定義: ${key}`);
                // 檢查是否有音效使用此標籤
                const usingSounds = state.sounds.filter(s => s.tags.some(t => utils.slug(t) === tagKey));
                if (usingSounds.length > 0) {
                  fmt.warn(`但有 ${usingSounds.length} 個音效使用此標籤`);
                }
                return null;
              }

              fmt.title(`🏷️ 標籤詳情: ${tagDef.name}`);
              console.log('   Key:', tagDef.key);
              console.log('   名稱:', tagDef.name);
              console.log('   顏色:', tagDef.color);
              console.log('   角色:', tagDef.role);
              if (tagDef.avatar) console.log('   頭像:', tagDef.avatar);

              const usingSounds = state.sounds.filter(s => s.tags.some(t => utils.slug(t) === tagKey));
              console.log(`   使用此標籤的音效: ${usingSounds.length} 個`);

              console.log('');
              return { definition: tagDef, soundCount: usingSounds.length, sounds: usingSounds };
            },

            /** 查看最愛列表詳情 */
            favorites: () => {
              fmt.title('❤️ 最愛列表');
              console.log(`   總數: ${state.favorites.length} 筆`);
              console.log('');

              if (state.favorites.length === 0) {
                fmt.info('目前沒有最愛');
                return [];
              }

              const details = state.favorites.map((id, i) => {
                const snd = state.soundMap.get(id);
                if (snd) {
                  console.log(`   ${i + 1}. ${snd.title} (${id})`);
                  return { id, title: snd.title, found: true };
                } else {
                  fmt.warn(`   ${i + 1}. [找不到] (${id})`);
                  return { id, title: null, found: false };
                }
              });

              const missing = details.filter(d => !d.found);
              if (missing.length > 0) {
                console.log('');
                fmt.warn(`有 ${missing.length} 個最愛 ID 找不到對應音效`);
              }

              console.log('');
              return details;
            },

            /** 列出所有音效（支援分頁） */
            sounds: (page = 1, pageSize = 20) => {
              const start = (page - 1) * pageSize;
              const end = start + pageSize;
              const totalPages = Math.ceil(state.sounds.length / pageSize);

              fmt.title(`📋 音效列表 (第 ${page}/${totalPages} 頁)`);
              console.log(`   顯示 ${start + 1}-${Math.min(end, state.sounds.length)} / ${state.sounds.length}`);
              console.log('');

              state.sounds.slice(start, end).forEach((snd, i) => {
                console.log(`   ${start + i + 1}. ${snd.title} [${snd.id}]`);
              });

              console.log('');
              if (page < totalPages) {
                console.log(`💡 查看下一頁: SoundboardDebug.inspect.sounds(${page + 1})`);
              }

              return state.sounds.slice(start, end);
            },

            /** 列出所有標籤 */
            tags: () => {
              fmt.title('🏷️ 標籤列表');
              console.log(`   總數: ${state.tagList.length} 個`);
              console.log('');

              const streamers = state.tagList.filter(t => t.role === 'streamer');
              const categories = state.tagList.filter(t => t.role === 'category');
              const others = state.tagList.filter(t => t.role !== 'streamer' && t.role !== 'category');

              if (streamers.length > 0) {
                fmt.section('實況主');
                streamers.forEach(t => console.log(`   • ${t.name} (${t.key}) ${t.color}`));
              }

              if (categories.length > 0) {
                fmt.section('分類');
                categories.forEach(t => console.log(`   • ${t.name} (${t.key}) ${t.color}`));
              }

              if (others.length > 0) {
                fmt.section('其他');
                others.forEach(t => console.log(`   • ${t.name} (${t.key}) ${t.color}`));
              }

              console.log('');
              return state.tagList;
            }
          };

          // ===== D. 幫助系統 =====
          const help = () => {
            console.log(`
%c╔═══════════════════════════════════════════════════════════════╗
║          🎛️ SoundboardDebug 控制台診斷工具 v${VERSION}          ║
╚═══════════════════════════════════════════════════════════════╝%c

%c【狀態報告】%c
  SoundboardDebug.status()          顯示完整狀態報告（音效數量、孤兒標籤等）

%c【測試功能】%c
  SoundboardDebug.test.checkFiles() 檢查所有音效檔案是否存在（需等待）
  SoundboardDebug.test.checkFiles({ verbose: true })  顯示每個檔案結果
  SoundboardDebug.test.checkTags()  檢查標籤參照完整性
  SoundboardDebug.test.checkIds()   檢查 ID 唯一性
  SoundboardDebug.test.all()        執行所有測試（不含檔案檢查）

%c【狀態檢視】%c
  SoundboardDebug.inspect.state()       查看完整 state 物件
  SoundboardDebug.inspect.sound(id)     查看特定音效（可用 ID 或索引）
  SoundboardDebug.inspect.sounds(page)  列出音效（分頁，每頁 20 筆）
  SoundboardDebug.inspect.tag(key)      查看特定標籤詳情
  SoundboardDebug.inspect.tags()        列出所有標籤
  SoundboardDebug.inspect.favorites()   查看最愛列表詳情

%c【其他】%c
  SoundboardDebug.help()            顯示此說明
  SoundboardDebug.lastTestResult    上次檔案測試的結果（執行 checkFiles 後）

`,
              'color: #6aa9ff; font-weight: bold;',
              '',
              'color: #ff9e6a; font-weight: bold;', 'color: inherit;',
              'color: #ff9e6a; font-weight: bold;', 'color: inherit;',
              'color: #ff9e6a; font-weight: bold;', 'color: inherit;',
              'color: #ff9e6a; font-weight: bold;', 'color: inherit;'
            );
          };

          // ===== 初始化提示 =====
          const init = () => {
            console.log(
              '%c🎛️ SoundboardDebug 已載入 %c— 輸入 %cSoundboardDebug.help()%c 獲取使用指南',
              'color: #6aa9ff; font-weight: bold;',
              'color: #94a3b8;',
              'color: #4ade80; font-weight: bold;',
              'color: #94a3b8;'
            );
          };

          // 延遲執行初始化提示（確保在其他訊息之後）
          setTimeout(init, 100);

          // ===== 公開 API =====
          return {
            status,
            test,
            inspect,
            help,
            lastTestResult: null,
            _version: VERSION
          };
        })();

        // 掛載到 window 供控制台存取
        window.SoundboardDebug = SoundboardDebug;

      })();
    </script>
</body>

</html>