<!doctype html>
<html lang="zh-Hant">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="assets/favicon.png" type="image/png">

  <title>阿萬與動物朋友按鈕</title>
  <style>
    :root {
      --bg: #0b0d10;
      --search: #0b0d1000;
      --fg: #e9eef5;
      --muted: #a8b3c7;
      --card: #141821;
      --card-2: #212832;
      --border: #202636;
      --accent: #6aa9ff;
      --accent2: #ff9e6a;
      --heart: #ff5a7a;
      --chip-fg: #0b0d10;
      --shadow: 0 6px 24px rgba(0, 0, 0, .25);

      /* 暗色主題的背景混合模式 */
      --bg-blend-mode: normal;
      --bg-opacity: 0.25;

      --control-h: 44px;
      --liquid-hover: rgba(96, 150, 255, .20);
    }

    :root.light {
      --bg: #f8fafc;
      --search: #f8fafc00;
      --fg: #0d1320;
      --muted: #4b5563;
      --card: #ffffff;
      --card-2: #f3f6fb;
      --border: #e5e7eb;
      --accent: #2563eb;
      --accent2: #eb7b25;
      --heart: #e11d48;
      --chip-fg: #ffffff;
      --shadow: 0 4px 18px rgba(2, 6, 23, .08);

      /* 亮色主題的背景混合模式和透明度 */
      --bg-blend-mode: normal;
      --bg-opacity: 0.35;
    }

    /* --- 通用樣式 --- */
    * {
      box-sizing: border-box;
    }

    html,body { height: 100%; }

    body {
      margin: 0;
      background-color: var(--bg);
      color: var(--fg);
      font: medium ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Noto Sans, "Helvetica Neue", Arial;
      position: relative;
      /* 為 ::before 提供定位上下文 */
      z-index: 1;
      /* 將所有內容提升到背景圖之上 */
    }

    /* --- 背景 --- */
    body::before {
      content: '';
      position: fixed;
      /* 背景固定在視窗 */
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('assets/background-by-jia.avif');
      background-size: auto 90%;
      background-repeat: repeat;
      background-attachment: fixed;
      mix-blend-mode: var(--bg-blend-mode);
      opacity: var(--bg-opacity);
      z-index: -1;
      /* 將背景圖層放在最底部 */
    }
    a { color: inherit }
    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px
    }
    header {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 14px;
    }

    /* 標題允許縮放，但不壓縮右側導航與按鈕。將右邊元素推到最右側 */
    header h1 {
      white-space: nowrap;
      margin-right: auto;
      /* 使用 auto margin 讓後方導覽與按鈕靠右 */
    }

    /* 導覽列樣式已整合到 .tabs 和 .tab，保留舊樣式供未來需要使用 */
    h1 {
      font-size: 1.4rem;
      margin: 0 8px 0 0;
      letter-spacing: .5px
    }

    .theme-toggle {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--fg);
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
      box-shadow: var(--shadow)
    }

    /* 搜尋列 */
    .search-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0px;
      align-items: stretch;
      position: sticky;
      top: 0;
      background: var(--search);
      padding: 8px 0 12px;
      z-index: 5
    }

    .searchbar {
      flex: 1 1 260px;
      display: flex;
      align-items: center;
      gap: 6px;
      background: var(--glass-bg) !important;
      border: 1px solid var(--glass-border) !important;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 6px 8px;
      box-shadow: var(--shadow);
      position: relative;
      height: var(--control-h);
    }

    .searchbar input {
      flex: 1;
      background: transparent;
      border: 0;
      outline: 0;
      color: var(--fg);
      font-size: 16px;
      min-width: 160px;
      height: 100%;
      line-height: var(--control-h);
      padding: 0 6px;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 12px;
      color: var(--chip-fg);
      box-shadow: 0 2px 6px rgba(0, 0, 0, .18);
    }

    .chip button {
      appearance: none;
      border: 0;
      background: transparent;
      color: inherit;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      padding: 0 0 0 2px
    }

    .searchbar .chip {
      cursor: pointer;
    }

    /* Favorites + Grid */
    .section-title {
      margin: 18px 0 10px;
      font-weight: 700;
      letter-spacing: .3px
    }

    .grid {
      display: grid;
      gap: 4px;
      grid-template-columns: repeat(6, minmax(0, 1fr));
    }

    @media (max-width:1000px) {
      .grid {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }
    }

    @media (max-width:800px) {
      .grid {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    }

    @media (max-width:600px) {
      .grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (max-width:400px) {
      .grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .sound {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: saturate(1) blur(8px);
      -webkit-backdrop-filter: saturate(1) blur(8px);
      border-radius: 12px;
      padding: 8px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 5px 2px;
      user-select: none;
      cursor: pointer;
      transition: transform .06s ease;

    }

    .sound:active {
      transform: scale(.985)
    }

    .sound-top {
      display: flex;
      align-items: center;
      gap: 4px
    }

    .title {
      font-weight: 600;
      font-size: smaller;
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis
    }

    .heart {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      place-items: center;
      border: 1px solid var(--border);
      background: var(--card-2);
      cursor: pointer;
      flex: 0 0 auto;
    }

    .heart svg {
      width: 16px;
      height: 16px;
      display: block
    }

    .heart[aria-pressed="true"] svg path {
      fill: var(--heart)
    }

    .tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px
    }

    .tag {
      border-radius: 999px;
      padding: 3px 6px;
      font-size: small;
      color: var(--chip-fg);
      cursor: pointer;
      white-space: nowrap;
      box-shadow: 0 2px 6px rgba(0, 0, 0, .16);
    }

    .stage {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px 14px;
      justify-content: center;
      pointer-events: none;
      z-index: 40;
      padding: 0 12px;
    }

    .group {
      display: inline-flex;
      gap: 8px;
      align-items: flex-end
    }

    .avatar {
      width: 75px;
      height: 75px;
      border-radius: 999px;
      background: transparent;
      /* 保持透明背景以呈現頭像 PNG 的透明區域 */
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, .8);
      box-shadow: 0 8px 24px rgba(0, 0, 0, .35);
      transform-origin: 50% 100%;
    }

    .avatar>img {
      width: 100%;
      height: 100%;
      object-fit: cover
    }

    /* Keyframes */
    @keyframes popIn {
      0% {
        transform: translateY(20px) scale(.7);
        opacity: 0
      }

      100% {
        transform: translateY(0) scale(1);
        opacity: 1
      }
    }

    @keyframes jitter {
      0%,
      100% {transform: translateY(0) rotate(0deg)}
      20% {transform: translateY(-2px) rotate(-1deg)}
      40% {transform: translateY(1px) rotate(1deg)}
      60% {transform: translateY(-1px) rotate(.6deg)}
      80% {transform: translateY(1px) rotate(-.6deg)}
    }

    /* 簡化的離場動畫：彈起後向下掉並淡出 */
    @keyframes hopOut {
      0% {
        transform: translateY(0);
        opacity: 1
      }

      22% {
        transform: translateY(-12px);
        opacity: 1
      }

      100% {
        transform: translateY(60px);
        opacity: 0
      }
    }

    .pop-in {
      animation: popIn .28s cubic-bezier(.2, .9, .18, 1) both
    }

    .jit {
      animation: jitter .9s ease-in-out infinite
    }

    .hop-out {
      animation: hopOut .5s cubic-bezier(.2, .8, .2, 1) forwards
    }

    .hidden {
      display: none
    }

    .desc {
      color: var(--muted);
      font-size: 14px;
      margin: 0 0 6px
    }

    .empty {
      color: var(--muted);
      padding: 12px 0
    }

    /* Utility */
    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap
    }

    .btn {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--fg);
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer
    }

    /* 導覽分頁 */
    /* 導覽分頁置於 header 右側，由 h1 的 margin-right:auto 推開 */
    .tabs {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      /* allow nav items to wrap on small screens */
    }

    .tab {
      display: inline-block;
      padding: 6px 16px;
      /* 更寬的間距，與其他膠囊元素一致 */
      font-size: 14px;
      border: 1px solid var(--border);
      border-radius: 999px;
      /* pill 造型，與標籤一致 */
      background: var(--card-2);
      color: var(--fg);
      cursor: pointer;
      transition: background .15s ease, color .15s ease;
    }

    .tab:hover {
      background: var(--card);
    }

    .tab.active {
      background: var(--accent);
      border-color: var(--accent);
      color: var(--chip-fg);
    }

    /* 小螢幕時導覽列與主題切換按鈕換行並增加上邊距 */
    @media (max-width: 600px) {
      header .tabs {
        margin-top: 8px;
      }

      header .theme-toggle {
        margin-top: 8px;
      }
    }

    /* 區塊標題與控制按鈕 */
    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 14px 0 8px;
    }

    .section-header .actions {
      display: flex;
      gap: 3px;
    }

    .section-header h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: .2px;
    }

    .small-btn {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 8px;
    }

    /* 標籤一覽 */
    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 8px;
      margin: 8px 0;
    }

    .tag-list .tag {
      cursor: pointer;
    }

    /* Context Menu */
    .menu {
      position: fixed;
      z-index: 9999;
      min-width: 180px;
      background: var(--glass-bg) !important;
      border: 1px solid var(--glass-border) !important;
      backdrop-filter: saturate(1.8) blur(12px);
      -webkit-backdrop-filter: saturate(1.8) blur(12px);
      border-radius: 12px;
      overflow: hidden;
    }

    .menu.hidden {
      display: none
    }

    .menu-item {
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid var(--border)
    }

    .menu-item:last-child {
      border-bottom: 0
    }

    .menu-item:hover {
      background: var(--liquid-hover);
    }

    /* Toast */
    .toast {
      position: fixed;
      left: 50%;
      bottom: 80px;
      transform: translateX(-50%);
      background: var(--card);
      border: 1px solid var(--border);
      padding: 10px 14px;
      border-radius: 10px;
      box-shadow: var(--shadow);
      z-index: 70
    }

    .toast.hidden {
      display: none
    }

    /* 混音面板 */
    .mix-panel {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 16px;
      width: min(980px, calc(100% - 32px));
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: saturate(1.6) blur(18px);
      -webkit-backdrop-filter: saturate(1.6) blur(18px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px 14px 14px;
      z-index: 80;
    }

    .mix-panel.hidden {
      display: none
    }

    .mix-header {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .mix-scroll-host {
      position: relative;
      overflow-x: auto;
      overflow-y: hidden;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.22);
      border: 1px solid rgba(255, 255, 255, 0.12);
      scrollbar-width: none;
    }

    .mix-scroll-host::-webkit-scrollbar {
      display: none
    }

    .mix-scroll-content {
      position: relative;
      min-height: 75px;
    }

    .mix-track-lanes {
      position: relative;
    }

    .mix-track {
      position: relative;
      height: 25px;
      border-bottom: 1px dashed var(--glass-border);
      background-color: var(--glass-bg);
      overflow: hidden;
    }

    .mix-track:last-of-type {
      border-bottom: 0;
    }

    .mix-track::before {
      content: attr(data-label);
      position: absolute;
      left: 0;
      top: 50%;
      transform: translate(-110%, -50%);
      font-size: 12px;
      color: var(--muted);
    }

    .mix-clip {
      position: absolute;
      top: 1px;
      height: 23px;
      border-radius: 8px;
      padding: 4px 26px 4px 8px;
      font-size: 12px;
      font-weight: 600;
      color: var(--chip-fg);
      display: flex;
      align-items: center;
      cursor: grab;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.35);
    }

    .mix-clip:active {
      cursor: grabbing;
    }

    .mix-clip.dragging {
      opacity: 0.85;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.55);
      cursor: grabbing;
    }

    /* Touch / selection tweaks to ensure mobile can drag clips instead of opening native menus */
    .mix-scroll-host,
    .mix-track-lanes,
    .mix-clip {
      -webkit-touch-callout: none;
      /* iOS: disable callout on long press */
      -webkit-user-select: none;
      /* Safari */
      user-select: none;
      /* Prevent text selection while dragging */
    }

    /* For pointer-based dragging we disable default touch actions inside the timeline
     and implement panning/dragging via pointer events. This prevents long-press
     context menus on many mobile browsers. */
    .mix-scroll-host,
    .mix-track-lanes,
    .mix-clip {
      touch-action: none;
    }

    .mix-clip-title {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
    }

    .mix-clip-remove {
      position: absolute;
      right: 4px;
      top: 4px;
      border: 0;
      width: 15px;
      height: 15px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.6);
      color: var(--chip-fg);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .mix-clip-remove:hover {
      background: rgba(15, 23, 42, 0.8);
    }

    .mix-clip-placeholder {
      height: 23px;
      margin: 0;
      position: absolute;
      top: 1px;
      left: 0;
      right: 0;
      pointer-events: none;
    }

    .mix-playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--accent);
      z-index: 3;
      pointer-events: none;
    }

    .mix-bar-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 0 4px;
    }

    .mix-bar-row>.mix-bar {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 0;
    }

    .mix-bar input[type="range"] {
      flex: 1;
      min-width: 0;
    }

    .mix-controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
    }

    .mix-controls-left {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .mix-controls-center {
      display: flex;
      align-items: center;
      gap: 2px;
    }

    .mix-controls-right {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .mix-btn {
      border: 1px solid var(--glass-border);
      background: var(--card-2);
      color: var(--fg);
      border-radius: 8px;
      padding: 6px 6px;
      cursor: pointer;
      min-width: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
      font-size: 13px;
    }

    .mix-btn:hover {
      background: rgba(15, 23, 42, 0.55);
    }

    .mix-btn[disabled] {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .mix-muted {
      color: var(--muted);
      font-size: 12px;
    }

    .mix-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.45);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 120;
    }

    .mix-modal-backdrop.hidden {
      display: none;
    }

    .mix-modal {
      background: var(--bg);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 12px 12px;
      max-width: 320px;
      box-shadow: var(--shadow);
    }

    .mix-modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 16px;
    }

    /* 播放/分享聚焦高亮 */
    /* 外光暈高光效果：持續發光 */
    .glow-persistent {
      box-shadow: 0 0 0 4px rgba(106, 169, 255, 0.5), 0 0 12px rgba(106, 169, 255, 0.75);
      /* transition added to avoid abrupt appearance */
      transition: box-shadow 0.3s ease;
    }


    :root {
      --glass-bg: rgba(20, 24, 33, .8);
      --glass-border: rgba(255, 255, 255, .12);
    }

    :root.light {
      --glass-bg: rgba(255, 255, 255, .6);
      --glass-border: rgba(15, 23, 42, .12);
    }

    .glass {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(3px);
      -webkit-backdrop-filter: blur(3px);
      background-clip: padding-box;
      box-shadow: var(--shadow);
    }

    .searchbar,
    .sound,
    .menu {
      background: var(--glass-bg) !important;
      border-color: var(--glass-border) !important;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
    }

    /* Navbar enhancements */
    header {
      position: relative;
    }

    .nav-toggle {
      display: none;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--fg);
      border-radius: 10px;
      padding: 8px;
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    @media (max-width: 760px) {
      .nav-toggle {
        display: inline-flex;
      }

      header .tabs {
        display: none;
        position: absolute;
        right: 0;
        top: 100%;
        padding: 8px;
        border-radius: 12px;
        gap: 6px;
        flex-direction: column;
        align-items: stretch;
        min-width: 180px;
        z-index: 120;
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        backdrop-filter: saturate(1.8) blur(12px);
        -webkit-backdrop-filter: saturate(1.8) blur(12px);
        box-shadow: var(--shadow);
      }

      body.nav-open header .tabs {
        display: flex;
      }
    }

    /* Background page tweaks */
    body.bg-full {
      --bg-opacity: 1 !important;
    }

    .bg-page {
      min-height: 50vh;
    }

    .bg-credit {
      position: fixed;
      right: 16px;
      bottom: 16px;
      font-size: large;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 800;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: saturate(1.8) blur(10px);
      -webkit-backdrop-filter: saturate(1.8) blur(10px);
      box-shadow: var(--shadow);
      z-index: 60;
    }

    .bg-credit a {
      text-decoration: underline;
    }



    #clearBtn.btn {
      height: var(--control-h);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 14px;
    }

    .search-row .searchbar {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
      border-right: 0 !important;
    }

    .search-row #clearBtn {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
      border-left: 1px solid var(--glass-border);
      background: var(--glass-bg);
      backdrop-filter: saturate(1.5) blur(8px);
      -webkit-backdrop-filter: saturate(1.5) blur(8px);
    }

    #page-about .about-content {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: saturate(1.8) blur(12px);
      -webkit-backdrop-filter: saturate(1.8) blur(12px);
      border-radius: 14px;
      padding: 14px 16px;
      box-shadow: var(--shadow);
    }


    /* --- Layout fixes (per request) --- */
    /* Keep h1 and nav-toggle on the same row; let the h1 text wrap internally */
    header {
      flex-wrap: nowrap;
    }

    header h1 {
      white-space: normal;
      min-width: 0;
      overflow-wrap: anywhere;
    }

    /* Keep searchbar and clearBtn on the same row; let the searchbar shrink first */
    .search-row {
      flex-wrap: nowrap;
    }

    .search-row .searchbar {
      flex: 1 1 auto;
      min-width: 0;
    }

    .search-row .searchbar input {
      min-width: 0;
    }

    .search-row #clearBtn {
      flex: 0 0 auto;
      white-space: nowrap;
    }


    /* SortableJS drag styles & sorting mode cursor */
    .drag-ghost {
      opacity: .6;
      transform: scale(.98);
    }

    .drag-chosen {
      outline: 2px dashed var(--accent);
    }

    .dragging {
      cursor: grabbing;
    }

    body.sorting #favGrid .card {
      cursor: grab;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <h1>阿萬與動物朋友按鈕₂₀₀₀</h1>
      <button id="navToggle" class="nav-toggle" aria-label="打開選單" aria-expanded="false" aria-controls="primaryNav"
        title="選單">
        <svg width="22" height="22" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M3 6h18M3 12h18M3 18h18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
        </svg>
      </button>

      <!-- 導覽分頁：放置於標題與主題切換按鈕之間，靠右排版 -->
      <nav id="primaryNav" class="tabs" aria-label="主選單">
        <button class="tab active" data-page="home">主頁</button>
        <button class="tab" data-page="game">小遊戲</button>
        <!-- <button class="tab" data-page="bg" id="tab-bg">背景</button> -->
  <button class="tab" data-page="about">關於</button>
  <button class="tab" data-page="awards">票選結果</button>
  <button id="settingsBtn" class="tab" aria-label="設定">設定</button>
      </nav>

    </header>

    <!-- 首頁內容：音效列表 -->
    <div id="page-home">
      <!-- 搜尋列（獨立成 row） -->
      <div class="search-row">
        <div class="searchbar" role="search">
          <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
            <path fill="currentColor"
              d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16a6.471 6.471 0 0 0 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14" />
          </svg>
          <input id="q" placeholder="搜尋標題或 #標籤（可多個，用空白分隔）" autocomplete="off" />
          <div id="activeChips" class="chips"></div>
        </div>
        <button id="clearBtn" class="btn" aria-label="清除搜尋">清除</button>
      </div>
      <!-- 標籤一覽 -->
      <div id="tagList" class="tag-list"></div>
      <!-- 最愛區 -->
      <div class="section-header">
        <h3>最愛音效</h3>
        <div class="actions">
          <button id="sortFavBtn" class="btn small-btn">手動排列</button>
          <button id="doneSortBtn" class="btn small-btn glow-persistent hidden">儲存排列</button>
          <button id="shareFavBtn" class="btn small-btn">分享</button>
        </div>
      </div>
      <div id="favGrid" class="grid"></div>
      <div id="favEmpty" class="empty hidden">還沒有最愛。點音效右上的 ❤️ 加入最愛。</div>
      <!-- 收到的列表：僅當 URL 包含 list 參數時顯示 -->
      <div id="receivedSection" class="hidden">
        <div id="receivedHeader" class="section-header">
          <h3>收到的列表</h3>
        </div>
        <div id="receivedGrid" class="grid"></div>
      </div>
      <!-- 全部音效 -->
      <div class="section-header">
        <h3>全部音效</h3>
        <div class="actions">
          <button id="openMixBtn" class="btn small-btn">音軌</button>
          <button id="shuffleBtn" class="btn small-btn">洗牌</button>
          <button id="resetOrderBtn" class="btn small-btn">預設順序</button>
        </div>
      </div>
      <p class="desc">提示：點音效即可播放；右鍵（或行動裝置長按）可分享/下載。</p>
      <div id="grid" class="grid"></div>
      <div id="empty" class="empty hidden">沒有符合搜尋的音效。</div>
    </div>
    <!-- 小遊戲分頁 -->
    <div id="page-game" class="hidden">
      <div id="concentration-game">
        <div class="cg-header">
          <div class="cg-stats">
            <span id="cg-timer">00:00</span>
            <span id="cg-accuracy">準確率：--%</span>
          </div>
          <div class="cg-controls">
            <button id="cg-restart" class="btn small-btn">重開一局</button>
          </div>
        </div>
        <div id="cg-board" class="cg-board"></div>
        <div id="cg-result" class="cg-result hidden"></div>
        <!-- 規則說明卡：與其他遊戲區塊同寬並置於下方 -->
        <div id="cg-rules" class="cg-rules" aria-labelledby="cg-rules-title">
          <h4 id="cg-rules-title">記憶小遊戲規則</h4>
          <ul>
            <li>第一次翻開的牌不對計分造成影響，屬於記憶提示。</li>
            <li>每翻開兩張卡，若為相同主播的相同音效即為配對，共有 8 對配對。</li>
            <li>（不會出現帶有「髒話」或「SUS」標籤的語音，但是會有尖叫，請小心耳膜。）</li>
          </ul>
        </div>
      </div>
      <style>
        .cg-board {
          display: grid;
          grid-template-columns: repeat(4, 70px);
          grid-template-rows: repeat(4, 70px);
          gap: 8px;
          justify-content: center;
          margin: 12px auto;
          /* 與 .cg-header 同寬且置中，呈現半透明玻璃托盤 */
          width: min(720px, 96%);
          padding: 12px;
          border-radius: 12px;
          background: var(--glass-bg);
          border: 1px solid var(--glass-border);
          backdrop-filter: saturate(1.8) blur(12px);
          -webkit-backdrop-filter: saturate(1.8) blur(12px);
          box-shadow: var(--shadow);
          justify-items: center;
        }

        .cg-card {
          width: 70px;
          height: 70px;
          background: #888;
          border-radius: 10px;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          position: relative;
          perspective: 600px;
          /* subtle click feedback */
          will-change: transform;
          transition: transform 140ms ease, box-shadow 140ms ease;
          user-select: none;
        }

        .cg-card.matched {
          opacity: 0.5;
          pointer-events: none;
        }

        .cg-card-inner {
          width: 100%;
          height: 100%;
          transition: transform 0.4s cubic-bezier(.4, 2, .6, 1);
          transform-style: preserve-3d;
          position: relative;
        }

        .cg-card.flipped .cg-card-inner {
          transform: rotateY(180deg);
        }

        .cg-card-front,
        .cg-card-back {
          position: absolute;
          width: 100%;
          height: 100%;
          backface-visibility: hidden;
          border-radius: 10px;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .cg-card-front {
          background: #888;
        }

        /* click feedback: a short pop + shadow while clicked */
        .cg-card:active,
        .cg-card.clicked {
          transform: scale(1.06);
          box-shadow: 0 10px 28px rgba(0, 0, 0, 0.28);
        }

        .cg-card-back {
          background: #fff;
          transform: rotateY(180deg);
          overflow: hidden;
        }

        .cg-card-back img {
          width: 80%;
          height: 80%;
          object-fit: contain;
          border-radius: 8px;
        }

        .cg-lock {
          position: absolute;
          right: 6px;
          top: 6px;
          background: rgba(0, 0, 0, 0.4);
          color: white;
          width: 20px;
          height: 20px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          font-weight: 700;
          font-size: 14px;
        }

        .cg-header {
          /* 玻璃托盤樣式：半透明、圓角、陰影，並固定於視窗頂端（在分頁內） */
          display: flex;
          gap: 6px;
          align-items: center;
          justify-content: space-between;
          margin: 4px auto;
          padding: 8px 12px;
          width: min(720px, 96%);
          border-radius: 12px;
          background: var(--glass-bg);
          border: 1px solid var(--glass-border);
          backdrop-filter: saturate(1.8) blur(12px);
          -webkit-backdrop-filter: saturate(1.8) blur(12px);
          box-shadow: var(--shadow);
          position: sticky;
          top: 12px;
          z-index: 60;
          /* allow wrap on very small screens */
          flex-wrap: wrap;
        }

        /* 左側數值群（計時器 + 準確率） */
        #cg-timer {
          font-size: 1.0rem;
          font-weight: 700;
          color: var(--fg);
          letter-spacing: 0.6px;
          min-width: 25px;
          text-align: left;
        }

        /* 當遊戲進行中（計時器運行）時顯示綠色 */
        #cg-timer.cg-running {
          color: #34d399;
        }

        #cg-accuracy {
          color: var(--muted);
          font-weight: 600;
          margin-left: 8px;
        }

        .cg-stats {
          display: flex;
          align-items: center;
          gap: 8px;
          flex: 1 1 auto;
          min-width: 0
        }

        .cg-controls {
          display: flex;
          align-items: center;
          gap: 8px;
          flex: 0 0 auto
        }

        /* 右側控制按鈕排列 */
        .cg-header button {
          margin-left: 8px;
          flex: 0 0 auto;
        }

        @media (max-width:420px) {
          .cg-header {
            gap: 8px;
            padding: 8px;
          }

          #cg-timer {
            font-size: 1rem;
          }

          .cg-board {
            grid-template-columns: repeat(4, 56px);
            grid-template-rows: repeat(4, 56px);
            gap: 4px;
            padding: 10px
          }

          .cg-card {
            width: 56px;
            height: 56px
          }
        }

        .cg-result {
          text-align: center;
          font-size: 1.05rem;
          margin-top: 18px;
          /* 使用與關於頁面相同的文字卡樣式 */
          background: var(--glass-bg);
          border: 1px solid var(--glass-border);
          backdrop-filter: saturate(1.8) blur(12px);
          -webkit-backdrop-filter: saturate(1.8) blur(12px);
          border-radius: 14px;
          padding: 14px 16px;
          box-shadow: var(--shadow);
          max-width: 480px;
          margin: 18px auto 0;
        }

        .cg-result h3 {
          margin: 0 0 6px;
          font-size: 1.15rem
        }

        .cg-result .stats {
          display: flex;
          gap: 12px;
          justify-content: center;
          flex-wrap: wrap;
          color: var(--muted);
          font-weight: 600
        }

        .cg-result .big-num {
          font-size: 1.25rem;
          font-weight: 700;
          color: var(--fg)
        }

        /* 規則說明卡：與 .cg-board / .cg-header 同寬且置中，外觀一致 */
        .cg-rules {
          width: min(720px, 96%);
          margin: 14px auto 28px;
          background: var(--glass-bg);
          border: 1px solid var(--glass-border);
          backdrop-filter: saturate(1.8) blur(12px);
          -webkit-backdrop-filter: saturate(1.8) blur(12px);
          border-radius: 12px;
          padding: 12px 16px;
          box-shadow: var(--shadow);
          color: var(--fg);
        }

        .cg-rules h4 {
          margin: 0 0 8px;
          font-size: 1.05rem
        }

        .cg-rules ul {
          margin: 0;
          padding-left: 18px;
          color: var(--muted)
        }
      </style>
    </div>

    <!-- 背景分頁 
    <div id="page-bg" class="bg-page hidden" aria-labelledby="tab-bg" role="region">
      <div class="bg-credit"><a href="https://x.com/jiauwu_0730" target="_blank" rel="noopener">背景插畫由 Jia 繪製</a></div>
    </div>
    -->

  <!-- 關於分頁 -->
  <div id="page-about" class="hidden">
      <div class="about-content">
        <p>本站由粉肝製作，並非由厭世醫師阿萬官方經營。音效內容皆是粉肝去脈絡式、斷章取義的剪輯，僅供娛樂。最後更新時間：2025/10/27。</p>

        <p>阿萬本家→ <a href="https://x.com/drlifesucks" target="_blank">厭世醫師阿萬X</a>、<a
            href="https://www.youtube.com/@Dr.lifesucks" target="_blank">厭世醫師阿萬Youtube</a> </p>
        <p><a href="https://discord.gg/e6ch4VbRB4" target="_blank">音效板問題回報與建議區</a></p>
        <img src="assets/art-by-sigh.png" alt=""
          style="margin: 0 auto; max-width:100%; max-height: 250px; display: block; object-fit: cover;" />
        <p style="text-align: right;">插畫：<a href="https://x.com/sigh121212" target="_blank">Minie(Sigh)</a></p>
        <h2>大德芳名錄</h2>
        <p>感謝53、Kie在DC弄了一堆音效，讓南想到可以做這個網站，並在提出這個想法的一開始就弄了一堆音效過來。還有同樣感謝在原型階段就幫忙收集音效的米糕跟薰薰草。
          <br />感謝Jia繪製超可愛的背景圖跟收集了很多音效。
          <br />
          <br />感謝粉肝們收集很多音效，豐富了這個網站（Word筆劃順）：
          <br />AmBinBong、CZ、HUI、Lococco de
          suzuran、Nokimi07、Sigh、TENN、Yichen沉沉、🌙🐰月桂葉香包♏🎵、布丁(25:00)、幸福柴柴、青末枝、凌伊LingYi（01）、夏白衫、澐▽米粉 肉干、貓貓雨。
          以及其他回報問題、提出建議的粉肝們，你們讓這個網站的功能更完善。
        </p>
      </div>
      <div class="bg-credit"><a href="https://x.com/jiauwu_0730" target="_blank" rel="noopener">背景插畫由 Jia 繪製</a></div>

    </div>

    <!-- 票選結果分頁 -->
    <div id="page-awards" class="hidden">
    
      <style>
        #page-awards .awards-grid {
          display: grid;
          gap: 4px;
          grid-template-columns: repeat(4, minmax(120px, 240px));
          align-items: center;
          justify-items: center;
          justify-content: center; /* center the grid tracks when total width is less than container */
        }
        @media (max-width: 700px) {
          #page-awards .awards-grid {
            grid-template-columns: repeat(2, minmax(120px, 240px));
            justify-content: center;
          }
        }
        #page-awards .awards-grid img { width: 100%; height: auto; display: block; max-width: 100%; object-fit: cover; }
        /* ensure sound card titles inside awards page keep left alignment (override parent text-align:center) */
        #page-awards .grid .title { text-align: left; }
      </style>
      <div style="max-width:1100px;margin:0 auto;padding:18px;">
        <h2 style="text-align:center">第一屆音效板爭霸戰</h2>
        <div style="text-align:center;margin:12px 0">
          <div class="awards-grid">
            <img src="assets/award1-1.jpg" alt="第一屆貓下去" />
            <img src="assets/award1-2.jpg" alt="第一屆Matsuko" />
            <img src="assets/award1-3.jpg" alt="第一屆豹子頭" />
            <img src="assets/award1-4.jpg" alt="第一屆瓦哈" />
          </div>
        <h3>獲獎區（前十名）</h3>
        <div id="awards-top10" class="grid"></div>
        <h3 style="margin-top:18px">入圍獎（後20名）</h3>
        <div id="awards-next20" class="grid"></div>
      </div>
    </div>
  </div>

    <!-- 設定 Modal（站內所有設定：音量 / 主題開關 等） -->
    <div id="settingsModal" class="mix-modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <div class="mix-modal">
        <h3 id="settingsTitle" style="margin-top: 0px;margin-bottom: 12px;">設定</h3>
        <div style="display:flex;flex-direction:column;gap:8px;">
          <button id="themeBtn" class="mix-btn" type="button">電燈開關</button>
          <label for="settingsVolume">播放音量： <span id="settingsVolumeValue">100%</span></label>
          <input id="settingsVolume" type="range" min="0" max="100" step="1" value="100" />
          <div style="display:flex;justify-content:flex-end;margin-top:6px;gap:8px;">
            <button id="settingsClose" class="mix-btn" type="button">關閉</button>
          </div>
        </div>
      </div>
    </div>

  <!-- 混音軌道面板 -->
  <div id="mixPanel" class="mix-panel hidden" aria-hidden="true" role="region" aria-label="混音軌道控制">
    <div class="mix-header">
      <div class="mix-bar-row">
        <div class="mix-bar">
          <span class="mix-muted">縮放</span>
          <input id="mixZoomRange" type="range" min="5" max="150" step="5" value="50" aria-label="混音軌道縮放" />
        </div>
        <div class="mix-bar">
          <span class="mix-muted">位置</span>
          <input id="mixScrollRange" type="range" min="0" max="100" step="1" value="0" aria-label="混音軌道檢視位置" />
        </div>
      </div>
      <div id="mixScrollHost" class="mix-scroll-host" aria-hidden="false">
        <div id="mixScrollContent" class="mix-scroll-content">
          <div id="mixTrackLanes" class="mix-track-lanes">
            <div class="mix-track" data-track="0" data-label="1"></div>
            <div class="mix-track" data-track="1" data-label="2"></div>
            <div class="mix-track" data-track="2" data-label="3"></div>
          </div>
          <div id="mixPlayhead" class="mix-playhead" style="left:0"></div>
        </div>
      </div>
    </div>
    <div class="mix-controls">
      <div class="mix-controls-left">
        <button id="mixClearBtn" class="mix-btn" type="button">清除</button>
      </div>
      <div class="mix-controls-center">
        <button id="mixUndoBtn" class="mix-btn" type="button" aria-label="上一步">↺</button>
        <button id="mixRedoBtn" class="mix-btn" type="button" aria-label="下一步">↻</button>
        <button id="mixToStartBtn" class="mix-btn" type="button" aria-label="移到開頭">⏮</button>
        <button id="mixPlayPauseBtn" class="mix-btn" type="button" aria-label="播放或暫停">▶</button>
        <button id="mixToEndBtn" class="mix-btn" type="button" aria-label="移到結尾">⏭</button>
      </div>
      <div class="mix-controls-right">
        <button id="mixCloseBtn" class="mix-btn" type="button">關閉</button>
      </div>
    </div>
  </div>

  <!-- 混音清除確認 -->
  <div id="mixConfirmModal" class="mix-modal-backdrop hidden" role="dialog" aria-modal="true"
    aria-labelledby="mixConfirmTitle">
    <div class="mix-modal">
      <h3 id="mixConfirmTitle">要清除所有音軌嗎？</h3>
      <div class="mix-modal-actions">
        <button id="mixConfirmCancel" class="mix-btn" type="button">取消</button>
        <button id="mixConfirmAccept" class="mix-btn" type="button">清除</button>
      </div>
    </div>
  </div>

  <!-- 播放彩蛋舞台 -->
  <div id="stage" class="stage" aria-hidden="true"></div>
  <!-- 右鍵/長按選單 -->
  <div id="menu" class="menu hidden" role="menu" aria-label="音效選單"></div>
  <!-- Toast提示 -->
  <div id="toast" class="toast hidden" role="status" aria-live="polite"></div>
  <!--
<script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.3/Sortable.min.js"></script>
-->
  <script src="scripts/Tone.js"></script>
  <script src="scripts/Sortable.min.js"></script>
  <script>
    (function () {
      /**
       * 檔案版本字串：每次部署變更此值，可確保抓取最新資料並強制 CDN/瀏覽器重新載入。
       */
      const VERSION = 'ver2025-10-27-1';

      /**
       * 為給定的 URL 附加版本字串 (?v=<VERSION>)。如果已有查詢參數則加 &。
       * @param {string} url
       * @returns {string}
       */
      function withV(url) {
        return url + (url.includes('?') ? '&' : '?') + 'v=' + encodeURIComponent(VERSION);
      }

      /** Fisher-Yates 洗牌演算法 **/
      function shuffleInPlace(arr, rng = Math.random) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      /** @typedef {{key:string, name:string, color:string, role:'streamer'|'category', avatar?:string}} Tag */
      /** @typedef {{file:string, title:string, tags:string[]}} SoundConf */
      /** @typedef {{id:string, src:string, title:string, tags:string[]}} Sound */

      // 元素引用。對 menu 與 toast 使用 getter 確保 DOM 已存在。
      const els = {
        q: document.getElementById('q'),
        activeChips: document.getElementById('activeChips'),
        grid: document.getElementById('grid'),
        favGrid: document.getElementById('favGrid'),
        empty: document.getElementById('empty'),
        favEmpty: document.getElementById('favEmpty'),
  settingsBtn: document.getElementById('settingsBtn'),
  themeBtn: document.getElementById('themeBtn'),
        stage: document.getElementById('stage'),
        clearBtn: document.getElementById('clearBtn'),
        get menu() { return document.getElementById('menu'); },
        get toast() { return document.getElementById('toast'); },
        mixPanel: document.getElementById('mixPanel'),
        mixScrollHost: document.getElementById('mixScrollHost'),
        mixScrollContent: document.getElementById('mixScrollContent'),
        mixTrackLanes: document.getElementById('mixTrackLanes'),
        mixPlayhead: document.getElementById('mixPlayhead'),
        mixScrollRange: document.getElementById('mixScrollRange'),
        mixZoomRange: document.getElementById('mixZoomRange'),
        mixClearBtn: document.getElementById('mixClearBtn'),
        mixUndoBtn: document.getElementById('mixUndoBtn'),
        mixRedoBtn: document.getElementById('mixRedoBtn'),
        mixToStartBtn: document.getElementById('mixToStartBtn'),
        mixPlayPauseBtn: document.getElementById('mixPlayPauseBtn'),
        mixToEndBtn: document.getElementById('mixToEndBtn'),
        mixCloseBtn: document.getElementById('mixCloseBtn'),
        mixConfirmModal: document.getElementById('mixConfirmModal'),
        mixConfirmCancel: document.getElementById('mixConfirmCancel'),
        mixConfirmAccept: document.getElementById('mixConfirmAccept'),
        openMixBtn: document.getElementById('openMixBtn'),
        // 分頁容器
        pageHome: document.getElementById('page-home'),
        pageGame: document.getElementById('page-game'),
    pageAbout: document.getElementById('page-about'),
  pageawards: document.getElementById('page-awards'),
  pageBg: document.getElementById('page-bg'),
    // settings modal elements (added)
    settingsModal: document.getElementById('settingsModal'),
    settingsClose: document.getElementById('settingsClose'),
    settingsVolume: document.getElementById('settingsVolume'),
    settingsVolumeValue: document.getElementById('settingsVolumeValue'),
        navToggle: document.getElementById('navToggle'),
        // 導覽標籤（動態抓取）
        get navTabs() { return document.querySelectorAll('.tab'); },
        // 標籤一覽容器
        tagList: document.getElementById('tagList'),
        // 收到的列表
        receivedSection: document.getElementById('receivedSection'),
        receivedGrid: document.getElementById('receivedGrid'),
        receivedHeader: document.getElementById('receivedHeader'),
  awardsTop10: document.getElementById('awards-top10'),
  awardsNext20: document.getElementById('awards-next20'),
        // 最愛排序/分享與洗牌按鈕
        sortFavBtn: document.getElementById('sortFavBtn'),
        doneSortBtn: document.getElementById('doneSortBtn'),
        shareFavBtn: document.getElementById('shareFavBtn'),
        shuffleBtn: document.getElementById('shuffleBtn'),
        resetOrderBtn: document.getElementById('resetOrderBtn')
      };

      // 全域狀態。
      const state = {
        tags: /** @type {Record<string, Tag>} */ ({}),
        tagList: /** @type {Tag[]} */ ([]),
        sounds: /** @type {Sound[]} */ ([]),
        favorites: JSON.parse(localStorage.getItem('favorites') || '[]'),
        favSet: new Set(),
        queryText: '',
        queryTags: new Set(),
        soundMap: new Map(),
        // 長按/右鍵開選單的計時器
        contextTimer: null,
        // 分頁狀態：home | game | about
        page: 'home',
        // 分享列表收到的 id 陣列
        receivedList: /** @type {string[]} */ ([]),
        // 已移除自動播放功能
        // Toast 計時器 id
        toastTimer: null,
        // 使用過的標籤列表
        usedTagList: /** @type {Tag[]} */ ([]),
        // 排序編輯模式
        isSorting: false,
        sortable: /** @type {any} */ (null),
        // 目前被高亮（持續外光暈）的音效卡片 id（若有）
        highlightedCardId: '',
        // 小遊戲（Concentration）是否正在進行中
        cgRunning: false,
        // 儲存一份載入時的預設音效順序（用於回復預設排序）
        defaultSoundsSnapshot: []
      };

      // 初始同步 favorites Set 供快速查詢
      state.favSet = new Set(state.favorites);

      // 全域音量（0.0 - 1.0），從 localStorage 載入，預設 1.0（100%）
      state.globalVolume = (function () {
        try {
          const v = localStorage.getItem('globalVolume');
          if (v !== null) {
            const n = Number(v);
            if (!isNaN(n) && n >= 0 && n <= 1) return n;
          }
        } catch (e) { }
        return 1.0;
      })();

      function applyVolumeToAudio(a) {
        try { if (a && typeof a.volume === 'number') a.volume = state.globalVolume; } catch (e) { }
      }

      /**
       * 建立一個 Audio 播放器並啟動播放。會自動套用全域音量並綁定常用 callback。
       * @param {string} src 音檔 URL
       * @param {{snd?:object, onPlay?:function, onEnded?:function, preload?:string, loop?:boolean}} opts
       * @returns {HTMLAudioElement}
       */
      function createPlayer(src, opts = {}) {
        try {
          const { snd = null, onPlay = null, onEnded = null, preload = 'auto', loop = false, autoplay = true } = opts;
          const audio = new Audio(src);
          if (preload) audio.preload = preload;
          audio.loop = !!loop;
          if (onPlay && typeof onPlay === 'function') audio.addEventListener('play', () => onPlay(snd, audio));
          if (onEnded && typeof onEnded === 'function') audio.addEventListener('ended', () => onEnded(snd, audio));
          applyVolumeToAudio(audio);
          if (autoplay) {
            try { audio.play().catch(() => { }); } catch (e) { }
          }
          return audio;
        } catch (e) { console.warn('[createPlayer] failed', e); return null; }
      }

      /**
       * 以 sound 物件（具有 id/src/title/tags）播放，並連結 onPlayStart/onPlayEnd 以保留舞台顯示行為。
       * @param {{id:string,src:string,title?:string,tags?:string[]}} snd
       * @returns {HTMLAudioElement|null}
       */
      function playSoundObject(snd) {
        if (!snd || !snd.src) return null;
        return createPlayer(snd.src, { snd, onPlay: onPlayStart, onEnded: onPlayEnd, preload: 'auto' });
      }

      // Concentration game cleanup hook (set when game initialized)
      let cgCleanup = null;


      // DOM 快速建造工具
      const dom = {
        el(tag, attrs = {}, children = []) {
          const e = document.createElement(tag);
          Object.entries(attrs).forEach(([k, v]) => {
            if (k === 'class') e.className = v;
            else if (k === 'style') Object.assign(e.style, v);
            else if (k.startsWith('on') && typeof v === 'function') e.addEventListener(k.substring(2), v);
            else if (v !== undefined && v !== null) e.setAttribute(k, v);
          });
          (Array.isArray(children) ? children : [children]).filter(Boolean).forEach(c => {
            if (typeof c === 'string') e.appendChild(document.createTextNode(c));
            else e.appendChild(c);
          });
          return e;
        },
        svgHeart() {
          const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.setAttribute('viewBox', '0 0 24 24');
          svg.innerHTML = '<path d="M12 21s-6.716-4.438-9.428-7.15C.59 11.868.59 8.608 2.57 6.627 4.55 4.647 7.81 4.647 9.79 6.627L12 8.838l2.21-2.21c1.98-1.98 5.24-1.98 7.22 0 1.98 1.98 1.98 5.24 0 7.223C18.716 16.562 12 21 12 21z" fill="none" stroke="currentColor" stroke-width="1.5"/>';
          return svg;
        }
      };

      // 工具函式
      const utils = {
        slug(s) { return s.normalize('NFKC').trim(); },
        byId(id) { return document.getElementById(id); },
        saveFav() { localStorage.setItem('favorites', JSON.stringify(state.favorites)); },
        inFav(id) { return state.favSet.has(id); },
        // 下載音檔
        download(url, filename) {
          const a = document.createElement('a');
          a.href = url;
          a.download = filename || '';
          document.body.appendChild(a);
          a.click();
          a.remove();
        },
        // 解析輸入框文字與目前已選標籤，回傳 {terms, tags}
        parseQuery() {
          const raw = state.queryText.trim();
          const parts = raw.length ? raw.split(/\s+/) : [];
          const tags = new Set([...state.queryTags]);
          const terms = [];
          for (const p of parts) {
            if (p.startsWith('#')) tags.add(utils.slug(p.slice(1)));
            else terms.push(utils.slug(p));
          }
          return { terms, tags };
        },
        // 判斷音效是否匹配搜尋條件
        match(sound, terms, tags) {
          for (const t of tags) {
            if (!sound.tags.some(s => utils.slug(s) === t)) return false;
          }
          for (const term of terms) {
            const inTitle = sound.title.toLowerCase().includes(term.toLowerCase());
            const inTags = sound.tags.some(t => t.toLowerCase().includes(term.toLowerCase()));
            if (!(inTitle || inTags)) return false;
          }
          return true;
        }
        ,
        // Debounce helper to limit how often a callback runs while an input is changing
        // usage: const debounced = utils.debounce(fn, 200);
        debounce(fn, wait = 200) {
          let t = null;
          return (...args) => {
            if (t) clearTimeout(t);
            t = setTimeout(() => { t = null; try { fn(...args); } catch (e) { console.error(e); } }, wait);
          };
        }
      };

      /** ===== 混音軌道狀態 ===== */
      const MIX_TRACK_COUNT = 3;
      const MIX_STORAGE_KEY = 'mix_tracks_v1';
      const MIX_HISTORY_LIMIT = 10;
      const MIX_MIN_SECONDS = 30;
      const MIX_PX_PER_SEC_DEFAULT = 30;
      const MIX_ZOOM_MIN = 20;
      const MIX_ZOOM_MAX = 120;

      /**
       * @typedef {{id:string,soundId:string,start:number,duration:number,track:number}} MixClip
       */

      const mixState = {
        tracks: Array.from({ length: MIX_TRACK_COUNT }, () => /** @type {MixClip[]} */([])),
        playhead: 0,
        pxPerSecond: MIX_PX_PER_SEC_DEFAULT,
        contentDuration: 0,
        timelineDuration: MIX_MIN_SECONDS,
        durationCache: new Map(),
        durationRequests: new Map(),
        history: [],
        future: [],
        isOpen: false,
        isPlaying: false,
        scrollRatio: 0,
        initialized: false
      };

      const mixAudio = {
        players: new Map(),
        loading: new Map(),
        rafId: 0,
        startTime: 0,
        startPlayhead: 0,
        scheduleIds: [],
        masterGain: null,
        toneStarted: false
      };

      let mixDrag = null;
      let mixPan = null;
      let mixPanSuppressClick = false;
      let mixZoomPersistTimer = null;

      function mixResetTracks() {
        return Array.from({ length: MIX_TRACK_COUNT }, () => /** @type {MixClip[]} */([]));
      }

      function mixNormalizeClip(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const soundId = typeof raw.soundId === 'string' ? raw.soundId : '';
        if (!soundId) return null;
        const start = Number(raw.start);
        const duration = Number(raw.duration);
        const track = Number(raw.track);
        if (!Number.isFinite(start) || start < 0) return null;
        if (!Number.isFinite(duration) || duration <= 0) return null;
        if (!Number.isInteger(track) || track < 0 || track >= MIX_TRACK_COUNT) return null;
        const id = typeof raw.id === 'string' && raw.id ? raw.id : mixGenerateClipId();
        return { id, soundId, start: mixRoundSeconds(start), duration: mixRoundSeconds(duration), track };
      }

      /**
       * 將 localStorage 中的片段資料（支援新版縮寫鍵與舊版完整鍵）轉換成標準 clip 物件。
       * 新版縮寫鍵對照：sid(soundId)、st(start)、du(duration)、tr(track)。
       */
      function mixNormalizeClipFromStorage(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const converted = {
          id: raw.id,
          soundId: raw.sid ?? raw.soundId,
          start: raw.st ?? raw.start,
          duration: raw.du ?? raw.duration,
          track: raw.tr ?? raw.track
        };
        return mixNormalizeClip(converted);
      }

      function mixRoundSeconds(value) {
        if (!Number.isFinite(value)) return 0;
        return Number(value.toFixed(3));
      }

      function mixGenerateClipId() {
        return 'cp-' + Math.random().toString(36).slice(3, 6) + Date.now().toString(36).slice(-2);
      }

      function mixRecalculateDuration() {
        let max = 0;
        mixState.tracks.forEach(track => track.forEach(clip => {
          const end = clip.start + clip.duration;
          if (end > max) max = end;
        }));
        mixState.contentDuration = max;
        mixState.timelineDuration = Math.max(MIX_MIN_SECONDS, Math.ceil(max));
        if (mixState.playhead > mixState.timelineDuration) mixState.playhead = mixState.timelineDuration;
        return mixState.timelineDuration;
      }

      function mixGetTimelineWidth() {
        return mixState.timelineDuration * mixState.pxPerSecond;
      }

      function mixResolveSoundColor(sound) {
        if (!sound || !Array.isArray(sound.tags)) return '#64748b';
        for (const tag of sound.tags) {
          const t = state.tags[utils.slug(tag)];
          if (t && t.color) return t.color;
        }
        return '#64748b';
      }

      function mixGetDurationForSound(sound) {
        if (!sound) return 2;
        const cached = mixState.durationCache.get(sound.id);
        if (typeof cached === 'number' && cached > 0) return cached;
        return 2;
      }

      function mixApplyDurationToClips(soundId, duration) {
        let updated = false;
        const rounded = mixRoundSeconds(duration);
        mixState.tracks.forEach(track => {
          track.forEach(clip => {
            if (clip.soundId === soundId) {
              if (Math.abs(clip.duration - rounded) > 0.0001) {
                clip.duration = rounded;
                updated = true;
              }
            }
          });
        });
        if (updated) {
          mixRecalculateDuration();
          mixRenderAll();
          mixSaveToStorage();
        }
      }

      function mixRequestDuration(sound, clip) {
        if (!sound) return;
        const cached = mixState.durationCache.get(sound.id);
        if (typeof cached === 'number' && cached > 0) return;
        if (mixState.durationRequests.has(sound.id)) return;
        const audio = new Audio();
        audio.preload = 'metadata';
        audio.src = sound.src;
  applyVolumeToAudio(audio);
        const promise = new Promise((resolve) => {
          const cleanup = () => {
            audio.removeEventListener('loadedmetadata', onLoaded);
            audio.removeEventListener('error', onError);
            audio.src = '';
          };
          const onLoaded = () => {
            const dur = Number(audio.duration);
            cleanup();
            if (isFinite(dur) && dur > 0) {
              const rounded = mixRoundSeconds(dur);
              mixState.durationCache.set(sound.id, rounded);
              mixApplyDurationToClips(sound.id, rounded);
              if (clip) { clip.duration = rounded; }
            }
            resolve();
          };
          const onError = () => {
            cleanup();
            resolve();
          };
          audio.addEventListener('loadedmetadata', onLoaded, { once: true });
          audio.addEventListener('error', onError, { once: true });
          try { audio.load(); } catch (e) { cleanup(); resolve(); }
        });
        mixState.durationRequests.set(sound.id, promise);
        promise.finally(() => mixState.durationRequests.delete(sound.id));
      }

      function mixHydrateClip(clip) {
        const snd = state.soundMap.get(clip.soundId);
        if (!snd) return;
        if (!mixState.durationCache.has(snd.id)) {
          mixRequestDuration(snd, clip);
        }
      }

      function mixCreateClipElement(clip) {
        const snd = state.soundMap.get(clip.soundId);
        const title = snd?.title || clip.soundId;
        const width = Math.max(clip.duration * mixState.pxPerSecond, 36);
        const left = clip.start * mixState.pxPerSecond;
        const color = mixResolveSoundColor(snd);
        const removeBtn = dom.el('button', { class: 'mix-clip-remove', type: 'button', 'data-clip-id': clip.id, 'aria-label': '移除音效' }, '×');
        removeBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          mixRemoveClipById(clip.id);
        });
        const titleEl = dom.el('span', { class: 'mix-clip-title' }, title);
        const clipEl = dom.el('div', {
          class: 'mix-clip',
          'data-clip-id': clip.id,
          style: { left: `${left}px`, width: `${width}px`, background: color },
          title
        }, [
          titleEl,
          removeBtn
        ]);
        clipEl.dataset.start = String(clip.start);
        clipEl.dataset.duration = String(clip.duration);
        clipEl.dataset.track = String(clip.track);
        return clipEl;
      }

      function mixRenderTracks() {
        const lanes = els.mixTrackLanes;
        if (!lanes) return;
        const width = mixGetTimelineWidth();
        const trackEls = lanes.querySelectorAll('.mix-track');
        trackEls.forEach(trackEl => {
          trackEl.style.width = width + 'px';
          trackEl.innerHTML = '';
        });
        mixState.tracks.forEach((track, idx) => {
          const trackEl = lanes.querySelector(`.mix-track[data-track="${idx}"]`);
          if (!trackEl) return;
          track.sort((a, b) => a.start - b.start || a.id.localeCompare(b.id));
          track.forEach(clip => {
            mixHydrateClip(clip);
            const el = mixCreateClipElement(clip);
            trackEl.appendChild(el);
          });
        });
      }

      function mixRenderPlayhead() {
        const ph = els.mixPlayhead;
        if (!ph) return;
        const x = mixState.playhead * mixState.pxPerSecond;
        ph.style.left = `${x}px`;
      }

      function mixUpdateScrollState() {
        const host = els.mixScrollHost;
        const range = els.mixScrollRange;
        if (!host || !range) return;
        const maxScroll = Math.max(0, host.scrollWidth - host.clientWidth);
        if (maxScroll <= 1) {
          range.value = '0';
          range.disabled = true;
          mixState.scrollRatio = 0;
          return;
        }
        range.disabled = false;
        const ratio = host.scrollLeft / maxScroll;
        mixState.scrollRatio = isFinite(ratio) ? ratio : 0;
        range.value = String(Math.round(mixState.scrollRatio * 100));
      }

      function mixOnWheelZoom(event) {
        const host = els.mixScrollHost;
        if (!host) return;
        if (mixState.timelineDuration <= 0) return;
        const deltaY = event.deltaY || 0;
        const deltaX = event.deltaX || 0;
        const primaryDelta = Math.abs(deltaY) >= Math.abs(deltaX) ? deltaY : deltaX;
        if (primaryDelta === 0) return;
        event.preventDefault();
        const step = primaryDelta > 0 ? -5 : 5;
        if (step === 0) return;
        const rect = host.getBoundingClientRect();
        const anchor = event.clientX - rect.left;
        const before = mixState.pxPerSecond;
        mixApplyZoom(mixState.pxPerSecond + step, { persist: false, anchorPixel: anchor });
        if (before !== mixState.pxPerSecond) {
          if (mixZoomPersistTimer) clearTimeout(mixZoomPersistTimer);
          mixZoomPersistTimer = setTimeout(() => {
            mixSaveToStorage();
            mixZoomPersistTimer = null;
          }, 240);
        }
      }

      function mixOnScrollRangeInput() {
        const host = els.mixScrollHost;
        const range = els.mixScrollRange;
        if (!host || !range) return;
        const maxScroll = Math.max(0, host.scrollWidth - host.clientWidth);
        const ratio = Number(range.value) / 100;
        host.scrollLeft = maxScroll * ratio;
        mixState.scrollRatio = isFinite(ratio) ? ratio : 0;
        mixUpdateScrollState();
      }

      function mixRenderAll() {
        if (!els.mixPanel) return;
        mixRecalculateDuration();
        const contentWidth = mixGetTimelineWidth();
        if (els.mixScrollContent) els.mixScrollContent.style.width = `${contentWidth}px`;
        if (els.mixZoomRange) {
          const rounded = String(Math.round(mixState.pxPerSecond));
          if (els.mixZoomRange.value !== rounded) els.mixZoomRange.value = rounded;
        }
        mixRenderTracks();
        const host = els.mixScrollHost;
        if (host) {
          const maxScroll = Math.max(0, host.scrollWidth - host.clientWidth);
          host.scrollLeft = maxScroll * mixState.scrollRatio;
        }
        mixRenderPlayhead();
        mixUpdateScrollState();
        mixUpdateControlStates();
      }

      function mixScrollPlayheadIntoView() {
        const host = els.mixScrollHost;
        if (!host) return;
        const x = mixState.playhead * mixState.pxPerSecond;
        const padding = 40;
        if (x < host.scrollLeft + padding) {
          host.scrollLeft = Math.max(0, x - padding);
        } else if (x > host.scrollLeft + host.clientWidth - padding) {
          host.scrollLeft = Math.max(0, x - host.clientWidth + padding);
        }
        mixUpdateScrollState();
      }

      function mixScrollClipIntoView(clip) {
        const host = els.mixScrollHost;
        if (!host) return;
        const startX = clip.start * mixState.pxPerSecond;
        const endX = (clip.start + clip.duration) * mixState.pxPerSecond;
        const padding = 40;
        if (startX < host.scrollLeft + padding) {
          host.scrollLeft = Math.max(0, startX - padding);
        } else if (endX > host.scrollLeft + host.clientWidth - padding) {
          host.scrollLeft = Math.max(0, endX - host.clientWidth + padding);
        }
        mixUpdateScrollState();
      }

      function mixApplyZoom(pxPerSecond, { persist = true, maintainCenter = false, anchorPixel = null } = {}) {
        const host = els.mixScrollHost;
        const previousPx = mixState.pxPerSecond;
        const clamped = Math.min(MIX_ZOOM_MAX, Math.max(MIX_ZOOM_MIN, Number(pxPerSecond) || MIX_PX_PER_SEC_DEFAULT));
        let targetScrollRatio = mixState.scrollRatio;
        if (anchorPixel != null && host) {
          const anchorLocal = Math.max(0, Math.min(anchorPixel, host.clientWidth));
          const currentWidth = mixState.timelineDuration * previousPx;
          const anchorAbsolute = host.scrollLeft + anchorLocal;
          const anchorRatio = currentWidth > 0 ? anchorAbsolute / currentWidth : 0;
          const newWidth = mixState.timelineDuration * clamped;
          const targetAnchor = newWidth * anchorRatio;
          const targetScrollLeft = Math.max(0, targetAnchor - anchorLocal);
          const maxScroll = Math.max(0, newWidth - host.clientWidth);
          targetScrollRatio = maxScroll > 0 ? targetScrollLeft / maxScroll : 0;
        } else if (maintainCenter && host) {
          const currentWidth = mixState.timelineDuration * previousPx;
          const center = host.scrollLeft + host.clientWidth / 2;
          const centerRatio = currentWidth > 0 ? center / currentWidth : 0;
          const newWidth = mixState.timelineDuration * clamped;
          const targetCenter = newWidth * centerRatio;
          const targetScrollLeft = Math.max(0, targetCenter - host.clientWidth / 2);
          const maxScroll = Math.max(0, newWidth - host.clientWidth);
          targetScrollRatio = maxScroll > 0 ? targetScrollLeft / maxScroll : 0;
        }
        if (Math.abs(clamped - mixState.pxPerSecond) < 0.0001) {
          if (persist) mixSaveToStorage();
          return;
        }
        mixState.pxPerSecond = clamped;
        mixState.scrollRatio = Math.min(1, Math.max(0, targetScrollRatio));
        mixRenderAll();
        if (host && (maintainCenter || anchorPixel != null)) {
          const maxScroll = Math.max(0, host.scrollWidth - host.clientWidth);
          host.scrollLeft = maxScroll * mixState.scrollRatio;
          mixUpdateScrollState();
        }
        if (els.mixZoomRange) {
          const rounded = String(Math.round(mixState.pxPerSecond));
          if (els.mixZoomRange.value !== rounded) els.mixZoomRange.value = rounded;
        }
        if (persist) mixSaveToStorage();
      }

      function mixSaveToStorage() {
        try {
          // 儲存時採用縮寫鍵以減少 metadata 體積：plh(playhead)、pps(pxPerSecond)、trs(tracks array)。
          const payload = {
            plh: mixRoundSeconds(mixState.playhead),
            pps: mixState.pxPerSecond,
            trs: mixState.tracks.map(track => track.map(clip => ({
              id: clip.id,
              sid: clip.soundId,       // sound id
              st: mixRoundSeconds(clip.start),
              du: mixRoundSeconds(clip.duration),
              tr: clip.track
            })))
          };
          localStorage.setItem(MIX_STORAGE_KEY, JSON.stringify(payload));
        } catch (err) {
          console.warn('[mix] save failed', err);
        }
      }

      function mixLoadFromStorage() {
        try {
          const raw = localStorage.getItem(MIX_STORAGE_KEY);
          if (!raw) { mixState.tracks = mixResetTracks(); mixState.playhead = 0; mixState.pxPerSecond = MIX_PX_PER_SEC_DEFAULT; mixRecalculateDuration(); return; }
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== 'object') throw new Error('invalid mix payload');
          const tracks = mixResetTracks();
          const rawTracks = Array.isArray(parsed.trs) ? parsed.trs : parsed.tracks;
          for (let i = 0; i < MIX_TRACK_COUNT; i++) {
            const arr = Array.isArray(rawTracks?.[i]) ? rawTracks[i] : [];
            tracks[i] = arr.map(mixNormalizeClipFromStorage).filter(Boolean).sort((a, b) => a.start - b.start || a.id.localeCompare(b.id));
          }
          mixState.tracks = tracks;
          const rawPlayhead = parsed.plh ?? parsed.playhead;
          mixState.playhead = mixRoundSeconds(Math.max(0, Number(rawPlayhead) || 0));
          const storedPx = Number(parsed.pps ?? parsed.pxPerSecond);
          if (Number.isFinite(storedPx) && storedPx >= MIX_ZOOM_MIN && storedPx <= MIX_ZOOM_MAX) {
            mixState.pxPerSecond = storedPx;
          } else {
            mixState.pxPerSecond = MIX_PX_PER_SEC_DEFAULT;
          }
          mixRecalculateDuration();
        } catch (err) {
          console.warn('[mix] load failed，已還原為預設值。', err);
          localStorage.removeItem(MIX_STORAGE_KEY);
          mixState.tracks = mixResetTracks();
          mixState.playhead = 0;
          mixState.pxPerSecond = MIX_PX_PER_SEC_DEFAULT;
          mixRecalculateDuration();
        }
        mixState.history = [];
        mixState.future = [];
        mixState.scrollRatio = 0;
      }

      function mixHasClips() {
        return mixState.tracks.some(track => track.length > 0);
      }

      function mixCloneState() {
        return {
          playhead: mixState.playhead,
          tracks: mixState.tracks.map(track => track.map(clip => ({
            ...clip,
            start: mixRoundSeconds(clip.start),
            duration: mixRoundSeconds(clip.duration)
          })))
        };
      }

      function mixStageHistory() {
        mixState.history.push(mixCloneState());
        if (mixState.history.length > MIX_HISTORY_LIMIT) {
          mixState.history.shift();
        }
        mixState.future = [];
      }

      function mixRestoreFromSnapshot(snapshot) {
        mixState.tracks = snapshot.tracks.map(track => track.map(clip => ({ ...clip })));
        mixState.playhead = snapshot.playhead;
        mixRecalculateDuration();
        mixRenderAll();
        mixSaveToStorage();
      }

      function mixUndo() {
        if (mixState.isPlaying || mixState.history.length === 0) return;
        const snapshot = mixState.history.pop();
        if (!snapshot) return;
        mixState.future.push(mixCloneState());
        if (mixState.future.length > MIX_HISTORY_LIMIT) mixState.future.shift();
        mixRestoreFromSnapshot(snapshot);
      }

      function mixRedo() {
        if (mixState.isPlaying || mixState.future.length === 0) return;
        const snapshot = mixState.future.pop();
        if (!snapshot) return;
        mixState.history.push(mixCloneState());
        if (mixState.history.length > MIX_HISTORY_LIMIT) mixState.history.shift();
        mixRestoreFromSnapshot(snapshot);
      }

      function mixUpdatePlayButton() {
        if (!els.mixPlayPauseBtn) return;
        els.mixPlayPauseBtn.textContent = mixState.isPlaying ? '⏸' : '▶';
        els.mixPlayPauseBtn.setAttribute('aria-label', mixState.isPlaying ? '暫停混音' : '播放混音');
      }

      function mixUpdateControlStates() {
        const playing = mixState.isPlaying;
        const hasClips = mixHasClips();
        if (els.mixUndoBtn) els.mixUndoBtn.disabled = playing || mixState.history.length === 0;
        if (els.mixRedoBtn) els.mixRedoBtn.disabled = playing || mixState.future.length === 0;
        if (els.mixPlayPauseBtn) {
          els.mixPlayPauseBtn.disabled = !hasClips;
          mixUpdatePlayButton();
        }
        if (els.mixClearBtn) els.mixClearBtn.disabled = playing || !hasClips;
        if (els.mixToStartBtn) els.mixToStartBtn.disabled = !hasClips;
        if (els.mixToEndBtn) els.mixToEndBtn.disabled = !hasClips;
      }

      function mixFindClipById(id) {
        for (let trackIndex = 0; trackIndex < MIX_TRACK_COUNT; trackIndex++) {
          const track = mixState.tracks[trackIndex];
          const index = track.findIndex(c => c.id === id);
          if (index !== -1) {
            return { clip: track[index], trackIndex, index };
          }
        }
        return null;
      }

      function mixRemoveClipById(clipId, { silent = false, recordHistory = true } = {}) {
        if (!clipId) return null;
        if (mixState.isPlaying) return null;
        const loc = mixFindClipById(clipId);
        if (!loc) return null;
        if (recordHistory) mixStageHistory();
        const track = mixState.tracks[loc.trackIndex];
        const [removed] = track.splice(loc.index, 1);
        mixRecalculateDuration();
        mixSaveToStorage();
        mixRenderAll();
        if (!silent) toast('已移除音效');
        return removed;
      }

      function mixClearAllTracks({ silent = false } = {}) {
        if (mixState.isPlaying || !mixHasClips()) return;
        mixStageHistory();
        mixState.tracks = mixResetTracks();
        mixState.playhead = 0;
        mixRecalculateDuration();
        mixSaveToStorage();
        mixRenderAll();
        if (!silent) toast('已清除所有音效');
      }

      function mixSetPlayhead(seconds, { scroll = true, persist = true } = {}) {
        const clamped = mixRoundSeconds(Math.max(0, Math.min(seconds, mixState.timelineDuration)));
        mixState.playhead = clamped;
        mixRenderPlayhead();
        if (scroll) mixScrollPlayheadIntoView();
        if (persist && !mixState.isPlaying) mixSaveToStorage();
      }

      function mixJumpToStart() {
        let earliest = Infinity;
        mixState.tracks.forEach(track => track.forEach(clip => {
          if (clip.start < earliest) earliest = clip.start;
        }));
        if (!isFinite(earliest)) earliest = 0;
        const wasPlaying = mixState.isPlaying;
        if (wasPlaying) mixStopPlayback(false);
        mixSetPlayhead(earliest, { scroll: true, persist: !wasPlaying });
        if (wasPlaying) {
          const upcoming = mixCollectPlayableClips();
          if (upcoming.length) mixStartPlayback();
          else mixUpdateControlStates();
        }
      }

      function mixJumpToEnd() {
        const end = Math.max(mixState.contentDuration, 0);
        const wasPlaying = mixState.isPlaying;
        if (wasPlaying) mixStopPlayback(false);
        mixSetPlayhead(end, { scroll: true, persist: !wasPlaying });
        if (wasPlaying) {
          const upcoming = mixCollectPlayableClips();
          if (upcoming.length) mixStartPlayback();
          else mixUpdateControlStates();
        }
      }

      function mixFindAvailableTrack(start, duration) {
        for (let i = 0; i < MIX_TRACK_COUNT; i++) {
          const track = mixState.tracks[i];
          const conflict = track.some(clip => !(start + duration <= clip.start || start >= clip.start + clip.duration));
          if (!conflict) return i;
        }
        return 0;
      }

      function mixOnLanesClick(event) {
        if (mixPanSuppressClick) {
          mixPanSuppressClick = false;
          return;
        }
        if (event.target.closest('.mix-clip')) return;
        const host = els.mixScrollHost;
        if (!host) return;
        const rect = host.getBoundingClientRect();
        const x = event.clientX - rect.left + host.scrollLeft;
        const seconds = x / mixState.pxPerSecond;
        const wasPlaying = mixState.isPlaying;
        if (wasPlaying) mixStopPlayback(false);
        mixSetPlayhead(seconds, { scroll: true, persist: !wasPlaying });
        if (wasPlaying) {
          const upcoming = mixCollectPlayableClips();
          if (upcoming.length) mixStartPlayback();
          else mixUpdateControlStates();
        }
      }

      function mixOpenConfirmModal() {
        if (!els.mixConfirmModal) return;
        els.mixConfirmModal.classList.remove('hidden');
        els.mixConfirmModal.setAttribute('aria-hidden', 'false');
        if (els.mixConfirmAccept) try { els.mixConfirmAccept.focus(); } catch (e) { }
      }

      function mixCloseConfirmModal() {
        if (!els.mixConfirmModal) return;
        els.mixConfirmModal.classList.add('hidden');
        els.mixConfirmModal.setAttribute('aria-hidden', 'true');
        if (els.mixClearBtn) try { els.mixClearBtn.focus(); } catch (e) { }
      }

      function mixHandleGlobalKeydown(event) {
        if (event.key === 'Escape') {
          if (els.mixConfirmModal && !els.mixConfirmModal.classList.contains('hidden')) {
            mixCloseConfirmModal();
          }
        }
      }

      // === Clip drag-and-drop ===
      function mixOnClipPointerDown(event) {
        const clipEl = event.target.closest('.mix-clip');
        if (!clipEl) {
          mixBeginPan(event);
          return;
        }
        if (event.button !== undefined && event.button !== 0) return;
        if (event.target.closest('.mix-clip-remove')) return;
        if (mixState.isPlaying) return;
        const clipId = clipEl.dataset.clipId || '';
        const loc = mixFindClipById(clipId);
        if (!loc) return;
        const host = els.mixScrollHost;
        const lanes = els.mixTrackLanes;
        if (!host || !lanes) return;
        const clipRect = clipEl.getBoundingClientRect();
        const hostRect = host.getBoundingClientRect();
        const lanesRect = lanes.getBoundingClientRect();
        const pointerOffsetX = event.clientX - clipRect.left;
        const pointerOffsetY = event.clientY - clipRect.top;
        const placeholder = document.createElement('div');
        placeholder.className = 'mix-clip-placeholder';
        placeholder.style.width = clipRect.width + 'px';
        placeholder.style.height = clipRect.height + 'px';
        const originContainer = clipEl.parentElement;
        if (originContainer) {
          const existingLeft = parseFloat(clipEl.style.left || '0');
          const fallbackLeft = loc.clip.start * mixState.pxPerSecond;
          const placeholderLeft = Number.isFinite(existingLeft) ? existingLeft : fallbackLeft;
          placeholder.style.left = placeholderLeft + 'px';
          originContainer.insertBefore(placeholder, clipEl);
        }
        lanes.appendChild(clipEl);
        const clipWidth = clipRect.width;
        const clipHeight = clipRect.height;
        clipEl.classList.add('dragging');
        clipEl.style.position = 'absolute';
        clipEl.style.zIndex = '10';
        clipEl.style.width = clipWidth + 'px';
        clipEl.style.left = `${event.clientX - lanesRect.left - pointerOffsetX + host.scrollLeft}px`;
        clipEl.style.top = `${clipRect.top - lanesRect.top}px`;

        mixDrag = {
          clip: loc.clip,
          clipEl,
          placeholder,
          pointerId: event.pointerId,
          pointerOffsetX,
          pointerOffsetY,
          clipWidth,
          clipHeight,
          hostRect,
          lanesRect,
          originTrack: loc.trackIndex,
          originStart: loc.clip.start,
          trackHeight: lanes.querySelector('.mix-track')?.offsetHeight || 36,
          historyCaptured: false,
          currentTrack: loc.trackIndex,
          currentStart: loc.clip.start
        };
        try { clipEl.setPointerCapture(event.pointerId); } catch (e) { }
        clipEl.addEventListener('pointermove', mixOnClipPointerMove);
        clipEl.addEventListener('pointerup', mixOnClipPointerUp);
        clipEl.addEventListener('pointercancel', mixOnClipPointerCancel);
        event.preventDefault();
      }

      function mixOnClipPointerMove(event) {
        if (!mixDrag || event.pointerId !== mixDrag.pointerId) return;
        const host = els.mixScrollHost;
        if (!host) return;
        const lanes = els.mixTrackLanes;
        if (!lanes) return;
        const rawLeft = event.clientX - mixDrag.hostRect.left + host.scrollLeft - mixDrag.pointerOffsetX;
        const maxLeft = Math.max(0, mixGetTimelineWidth() - mixDrag.clipWidth);
        const newLeft = Math.min(Math.max(0, rawLeft), maxLeft);
        mixDrag.clipEl.style.left = `${newLeft}px`;
        const newStart = newLeft / mixState.pxPerSecond;
        const pointerCenterY = event.clientY - mixDrag.lanesRect.top - mixDrag.pointerOffsetY + mixDrag.clipHeight / 2;
        const trackHeight = mixDrag.trackHeight;
        const newTrack = Math.min(MIX_TRACK_COUNT - 1, Math.max(0, Math.floor(pointerCenterY / trackHeight)));
        const targetTop = newTrack * trackHeight + Math.max(0, (trackHeight - mixDrag.clipHeight) / 2);
        mixDrag.clipEl.style.top = `${targetTop}px`;
        mixDrag.currentTrack = newTrack;
        mixDrag.currentStart = mixRoundSeconds(Math.max(0, newStart));
        if (!mixDrag.historyCaptured) {
          if (Math.abs(newStart - mixDrag.originStart) > 0.0005 || newTrack !== mixDrag.originTrack) {
            mixStageHistory();
            mixDrag.historyCaptured = true;
          }
        }
        const threshold = 40;
        const maxScroll = Math.max(0, host.scrollWidth - host.clientWidth);
        if (event.clientX > mixDrag.hostRect.right - threshold) {
          host.scrollLeft = Math.min(host.scrollLeft + 14, maxScroll);
        } else if (event.clientX < mixDrag.hostRect.left + threshold) {
          host.scrollLeft = Math.max(host.scrollLeft - 14, 0);
        }
        mixUpdateScrollState();
      }

      function mixCleanupDragElements() {
        if (!mixDrag) return;
        const { clipEl, placeholder } = mixDrag;
        if (placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
        if (clipEl) {
          clipEl.classList.remove('dragging');
          clipEl.style.position = '';
          clipEl.style.zIndex = '';
          clipEl.style.width = '';
          clipEl.style.left = '';
          clipEl.style.top = '';
        }
      }

      /**
       * 在空白軌道上拖曳以平移視窗（等同調整位置滑桿）。
       */
      function mixBeginPan(event) {
        const host = els.mixScrollHost;
        const lanes = els.mixTrackLanes;
        if (!host || !lanes) return;
        if (event.button !== undefined && event.button !== 0) return;
        mixPanSuppressClick = false;
        mixPan = {
          pointerId: event.pointerId,
          startX: event.clientX,
          startScroll: host.scrollLeft,
          lanes
        };
        try { lanes.setPointerCapture(event.pointerId); } catch (e) { }
        lanes.addEventListener('pointermove', mixOnPanPointerMove);
        lanes.addEventListener('pointerup', mixEndPan);
        lanes.addEventListener('pointercancel', mixCancelPan);
      }

      function mixOnPanPointerMove(event) {
        if (!mixPan || event.pointerId !== mixPan.pointerId) return;
        const host = els.mixScrollHost;
        if (!host) return;
        const delta = event.clientX - mixPan.startX;
        if (Math.abs(delta) > 2) mixPanSuppressClick = true;
        const maxScroll = Math.max(0, host.scrollWidth - host.clientWidth);
        const nextScroll = Math.min(Math.max(mixPan.startScroll - delta, 0), maxScroll);
        host.scrollLeft = nextScroll;
        mixUpdateScrollState();
        event.preventDefault();
      }

      function mixEndPan(event) {
        mixFinalizePan(event, false);
      }

      function mixCancelPan(event) {
        mixFinalizePan(event, true);
      }

      function mixFinalizePan(event, canceled) {
        if (!mixPan || event.pointerId !== mixPan.pointerId) return;
        const { lanes } = mixPan;
        try { lanes.releasePointerCapture(event.pointerId); } catch (e) { }
        lanes.removeEventListener('pointermove', mixOnPanPointerMove);
        lanes.removeEventListener('pointerup', mixEndPan);
        lanes.removeEventListener('pointercancel', mixCancelPan);
        mixPan = null;
        if (canceled) mixPanSuppressClick = false;
      }

      function mixFinalizeDrag(event, canceled) {
        if (!mixDrag || event.pointerId !== mixDrag.pointerId) return;
        const { clip, clipEl, placeholder, originTrack, originStart, currentTrack, currentStart, historyCaptured } = mixDrag;
        try { clipEl.releasePointerCapture(event.pointerId); } catch (e) { }
        clipEl.removeEventListener('pointermove', mixOnClipPointerMove);
        clipEl.removeEventListener('pointerup', mixOnClipPointerUp);
        clipEl.removeEventListener('pointercancel', mixOnClipPointerCancel);
        const movedMeaningful = Math.abs(currentStart - originStart) > 0.0005 || currentTrack !== originTrack;
        if (!historyCaptured || !movedMeaningful || canceled) {
          if (historyCaptured && mixState.history.length > 0) mixState.history.pop();
          mixCleanupDragElements();
          if (clipEl && clipEl.parentNode) clipEl.parentNode.removeChild(clipEl);
          mixRenderAll();
          mixDrag = null;
          return;
        }
        const originArr = mixState.tracks[originTrack];
        if (currentTrack !== originTrack) {
          const idx = originArr.indexOf(clip);
          if (idx !== -1) originArr.splice(idx, 1);
          mixState.tracks[currentTrack].push(clip);
          clip.track = currentTrack;
        }
        clip.start = mixRoundSeconds(Math.max(0, currentStart));
        mixState.tracks[currentTrack].sort((a, b) => a.start - b.start || a.id.localeCompare(b.id));
        if (currentTrack !== originTrack) {
          originArr.sort((a, b) => a.start - b.start || a.id.localeCompare(b.id));
        }
        mixCleanupDragElements();
        if (clipEl && clipEl.parentNode) clipEl.parentNode.removeChild(clipEl);
        mixRecalculateDuration();
        mixSaveToStorage();
        mixRenderAll();
        mixScrollClipIntoView(clip);
        mixDrag = null;
      }

      function mixOnClipPointerUp(event) {
        mixFinalizeDrag(event, false);
      }

      function mixOnClipPointerCancel(event) {
        mixFinalizeDrag(event, true);
      }

      // === Tone.js playback helpers ===
      function mixCollectPlayableClips() {
        const start = mixState.playhead;
        const clips = [];
        mixState.tracks.forEach(track => {
          track.forEach(clip => {
            if (clip.start + clip.duration > start) {
              clips.push(clip);
            }
          });
        });
        clips.sort((a, b) => a.start - b.start || a.id.localeCompare(b.id));
        return clips;
      }

      function isToneAvailable() {
        return typeof window !== 'undefined' && typeof Tone !== 'undefined' && Tone && typeof Tone.Transport !== 'undefined';
      }

      async function mixEnsureToneStarted() {
        if (!isToneAvailable()) throw new Error('Tone.js unavailable');
        if (!mixAudio.toneStarted) {
          await Tone.start();
          // create a master gain node so we can control mix volume from settings
          try {
            mixAudio.masterGain = new Tone.Gain(state.globalVolume || 1).toDestination();
          } catch (e) {
            mixAudio.masterGain = null;
          }
          mixAudio.toneStarted = true;
        }
      }

      function mixPlayerKey(soundId, track) {
        return `${soundId}::${track}`;
      }

      async function mixGetPlayer(sound, track) {
        const key = mixPlayerKey(sound.id, track);
        if (mixAudio.players.has(key)) return mixAudio.players.get(key);
        if (mixAudio.loading.has(key)) return mixAudio.loading.get(key);
        if (!isToneAvailable()) throw new Error('Tone.js unavailable');
        const promise = new Promise((resolve, reject) => {
          let player;
          try {
            player = new Tone.Player({
              url: sound.src,
              autostart: false,
              onload: () => {
                mixAudio.players.set(key, player);
                const dur = player.buffer?.duration;
                if (isFinite(dur) && dur > 0) {
                  const rounded = mixRoundSeconds(dur);
                  mixState.durationCache.set(sound.id, rounded);
                  mixApplyDurationToClips(sound.id, rounded);
                }
                resolve(player);
              },
              onerror: (err) => {
                try { player.dispose(); } catch (e) { }
                reject(err || new Error('load failed'));
              }
            });
            // route player output to masterGain when available so global volume can control mix playback
            try {
              if (mixAudio.masterGain && typeof mixAudio.masterGain.connect === 'function') {
                player.connect(mixAudio.masterGain);
              } else {
                player.toDestination();
              }
            } catch (e) {
              try { player.toDestination(); } catch (ee) { }
            }
          } catch (err) {
            if (player) try { player.dispose(); } catch (e) { }
            reject(err);
          }
        });
        mixAudio.loading.set(key, promise);
        return promise.finally(() => mixAudio.loading.delete(key));
      }

      async function mixEnsurePlayers(clips) {
        const tasks = clips.map(clip => {
          const sound = state.soundMap.get(clip.soundId);
          if (!sound) return Promise.resolve();
          return mixGetPlayer(sound, clip.track);
        });
        await Promise.all(tasks);
      }

      function mixStartTransportMonitor() {
        mixStopTransportMonitor();
        const tick = () => {
          if (!mixState.isPlaying || !isToneAvailable()) return;
          const elapsed = Tone.now() - mixAudio.startTime;
          const newPos = mixAudio.startPlayhead + elapsed;
          mixState.playhead = Math.min(newPos, mixState.timelineDuration);
          mixRenderPlayhead();
          mixScrollPlayheadIntoView();
          mixAudio.rafId = requestAnimationFrame(tick);
        };
        mixAudio.rafId = requestAnimationFrame(tick);
      }

      function mixStopTransportMonitor() {
        if (mixAudio.rafId) {
          cancelAnimationFrame(mixAudio.rafId);
          mixAudio.rafId = 0;
        }
      }

      async function mixStartPlayback() {
        if (mixState.isPlaying) return;
        if (!mixHasClips()) { toast('沒有可播放的片段'); return; }
        if (!isToneAvailable()) { toast('Tone.js 載入失敗，無法播放'); return; }
        const clips = mixCollectPlayableClips();
        if (!clips.length) { toast('播放位置之後沒有音效'); return; }
        try {
          await mixEnsureToneStarted();
          await mixEnsurePlayers(clips);
        } catch (err) {
          console.error('[mix] player load error', err);
          toast('音訊載入失敗');
          return;
        }
        try {
          Tone.Transport.stop();
          Tone.Transport.cancel();
          mixAudio.scheduleIds.forEach(id => Tone.Transport.clear(id));
          mixAudio.scheduleIds = [];
        } catch (err) { console.warn('[mix] transport reset failed', err); }
        clips.forEach(clip => {
          const key = mixPlayerKey(clip.soundId, clip.track);
          const player = mixAudio.players.get(key);
          if (!player) return;
          const startTime = Math.max(0, clip.start - mixState.playhead);
          const offset = Math.max(0, mixState.playhead - clip.start);
          const remaining = clip.duration - offset;
          if (remaining <= 0) return;
          const id = Tone.Transport.schedule(time => {
            try { player.start(time, offset, remaining); } catch (e) { console.warn('[mix] player start failed', e); }
          }, startTime);
          mixAudio.scheduleIds.push(id);
        });
        const totalRemaining = Math.max(0, mixState.contentDuration - mixState.playhead);
        if (totalRemaining > 0) {
          const stopId = Tone.Transport.schedule(() => mixStopPlayback(true), totalRemaining + 0.05);
          mixAudio.scheduleIds.push(stopId);
        }
        mixAudio.startPlayhead = mixState.playhead;
        mixAudio.startTime = Tone.now();
        mixState.isPlaying = true;
        mixUpdateControlStates();
        try {
          Tone.Transport.start('+0.02');
        } catch (err) {
          console.error('[mix] transport start error', err);
          mixState.isPlaying = false;
          mixUpdateControlStates();
          toast('播放啟動失敗');
          return;
        }
        mixStartTransportMonitor();
      }

      function mixStopPlayback(auto = false) {
        if (!isToneAvailable()) {
          mixState.isPlaying = false;
          mixUpdateControlStates();
          return;
        }
        try {
          Tone.Transport.stop();
          Tone.Transport.cancel();
          mixAudio.scheduleIds.forEach(id => Tone.Transport.clear(id));
          mixAudio.scheduleIds = [];
        } catch (err) { console.warn('[mix] transport stop error', err); }
        mixAudio.players.forEach(player => { try { player.stop(); } catch (e) { } });
        mixStopTransportMonitor();
        if (!mixState.isPlaying) return;
        const elapsed = Tone.now() - mixAudio.startTime;
        const newPos = mixAudio.startPlayhead + Math.max(0, elapsed);
        mixState.isPlaying = false;
        mixSetPlayhead(Math.min(newPos, mixState.contentDuration), { scroll: true, persist: true });
        if (auto) toast('播放結束');
        mixUpdateControlStates();
      }

      function mixTogglePlayback() {
        if (mixState.isPlaying) mixStopPlayback(false);
        else mixStartPlayback();
      }

      function mixShowPanel(scrollToPlayhead = true) {
        if (!els.mixPanel) return;
        els.mixPanel.classList.remove('hidden');
        els.mixPanel.setAttribute('aria-hidden', 'false');
        mixState.isOpen = true;
        mixRenderAll();
        if (scrollToPlayhead) mixScrollPlayheadIntoView();
      }

      function mixHidePanel() {
        if (!els.mixPanel) return;
        els.mixPanel.classList.add('hidden');
        els.mixPanel.setAttribute('aria-hidden', 'true');
        mixState.isOpen = false;
      }

      function mixAddClipForSound(sound, opts = {}) {
        if (!sound) return null;
        if (!mixState.initialized) ensureMixPanelReady();
        mixStageHistory();
        const duration = mixRoundSeconds(Math.max(0.5, Number(opts.duration) || mixGetDurationForSound(sound)));
        const start = mixRoundSeconds(Math.max(0, Number.isFinite(opts.start) ? Number(opts.start) : mixState.playhead));
        let track = Number.isInteger(opts.track) ? Number(opts.track) : mixFindAvailableTrack(start, duration);
        if (track < 0 || track >= MIX_TRACK_COUNT) track = mixFindAvailableTrack(start, duration);
        const clip = { id: mixGenerateClipId(), soundId: sound.id, start, duration, track };
        mixState.tracks[track].push(clip);
        mixState.tracks[track].sort((a, b) => a.start - b.start);
        mixRecalculateDuration();
        mixSaveToStorage();
        mixRenderAll();
        mixShowPanel(false);
        mixScrollClipIntoView(clip);
        mixRequestDuration(sound, clip);
        return clip;
      }

      function handleAddSoundToMix(soundId) {
        const sound = state.soundMap.get(soundId) || state.sounds.find(s => s.id === soundId);
        if (!sound) {
          toast('找不到音效');
          return;
        }
        ensureMixPanelReady();
        const clip = mixAddClipForSound(sound);
        if (clip) toast('已加入混音軌道');
      }

      function ensureMixPanelReady() {
        if (mixState.initialized) return;
        mixState.initialized = true;
        mixLoadFromStorage();
        mixRenderAll();
        if (els.mixScrollHost) {
          els.mixScrollHost.addEventListener('scroll', mixUpdateScrollState, { passive: true });
          els.mixScrollHost.addEventListener('wheel', mixOnWheelZoom, { passive: false });
        }
        if (els.mixScrollRange) {
          els.mixScrollRange.addEventListener('input', mixOnScrollRangeInput);
        }
        if (els.mixZoomRange && !els.mixZoomRange.dataset.mixBound) {
          els.mixZoomRange.dataset.mixBound = '1';
          els.mixZoomRange.setAttribute('min', String(MIX_ZOOM_MIN));
          els.mixZoomRange.setAttribute('max', String(MIX_ZOOM_MAX));
          els.mixZoomRange.setAttribute('step', '5');
          els.mixZoomRange.value = String(Math.round(mixState.pxPerSecond));
          els.mixZoomRange.addEventListener('input', (ev) => {
            mixApplyZoom(Number(ev.target.value), { persist: false, maintainCenter: true });
          });
          els.mixZoomRange.addEventListener('change', (ev) => {
            mixApplyZoom(Number(ev.target.value), { persist: true, maintainCenter: true });
          });
        } else if (els.mixZoomRange) {
          els.mixZoomRange.value = String(Math.round(mixState.pxPerSecond));
        }
        if (els.mixTrackLanes) {
          els.mixTrackLanes.addEventListener('click', mixOnLanesClick);
          els.mixTrackLanes.addEventListener('pointerdown', mixOnClipPointerDown);
          // Prevent native context menu and text selection on mobile long-press so pointer drag works
          try {
            els.mixTrackLanes.addEventListener('contextmenu', (e) => { e.preventDefault(); });
            els.mixTrackLanes.addEventListener('selectstart', (e) => { e.preventDefault(); });
          } catch (e) { /* ignore */ }
        }
        if (els.mixPlayPauseBtn) els.mixPlayPauseBtn.addEventListener('click', mixTogglePlayback);
        if (els.mixToStartBtn) els.mixToStartBtn.addEventListener('click', mixJumpToStart);
        if (els.mixToEndBtn) els.mixToEndBtn.addEventListener('click', mixJumpToEnd);
        if (els.mixUndoBtn) els.mixUndoBtn.addEventListener('click', mixUndo);
        if (els.mixRedoBtn) els.mixRedoBtn.addEventListener('click', mixRedo);
        if (els.mixClearBtn) els.mixClearBtn.addEventListener('click', mixOpenConfirmModal);
        if (els.mixCloseBtn) els.mixCloseBtn.addEventListener('click', () => { mixStopPlayback(false); mixHidePanel(); });
        if (els.mixConfirmCancel) els.mixConfirmCancel.addEventListener('click', mixCloseConfirmModal);
        if (els.mixConfirmAccept) els.mixConfirmAccept.addEventListener('click', () => { mixClearAllTracks({ silent: false }); mixCloseConfirmModal(); });
        if (els.mixConfirmModal) {
          els.mixConfirmModal.addEventListener('click', (ev) => {
            if (ev.target === els.mixConfirmModal) mixCloseConfirmModal();
          });
        }
        document.addEventListener('keydown', mixHandleGlobalKeydown);
        if (els.openMixBtn && !els.openMixBtn.dataset.mixBound) {
          els.openMixBtn.dataset.mixBound = '1';
          els.openMixBtn.addEventListener('click', () => {
            ensureMixPanelReady();
            mixShowPanel(true);
          });
        }
        mixUpdateControlStates();
      }

      /**
       * URL 同步工具：將當前搜尋條件封裝為 URLSearchParams
       */
      function buildSearchParams() {
        const { terms, tags } = utils.parseQuery();
        const params = new URLSearchParams(window.location.search);
        if (terms.length) params.set('q', terms.join(' ')); else params.delete('q');
        if (tags.size) params.set('tags', [...tags].join(',')); else params.delete('tags');
        params.delete('sound'); // 修改搜尋時清除音效深連結
        return params;
      }

      /**
       * 將狀態寫回 URL。
       * @param {boolean} push 若為 true 則使用 history.pushState，否則使用 replaceState
       */
      function updateURLFromState(push = false) {
        const params = buildSearchParams();
        // 保留 list 參數（分享收到的列表）若存在
        const current = new URLSearchParams(location.search);
        if (current.has('list')) params.set('list', current.get('list'));
        // 這行是正確的，是為了保證分享網址的邏輯能夠正確運作
        if (current.has('sound')) params.set('sound', current.get('sound'));
        // 加上 page 參數（非首頁才寫入）
        if (state.page && state.page !== 'home') params.set('page', state.page); else params.delete('page');
        const qs = params.toString();
        const url = `${location.pathname}${qs ? '?' + qs : ''}`;
        (push ? history.pushState : history.replaceState).call(history, null, '', url);
      }

      /**
       * 從現有 URL 讀取搜尋條件並套用到狀態與輸入框
       */
      function applyURLToState() {
        const params = new URLSearchParams(location.search);
        const q = params.get('q') || '';
        const tagsParam = params.get('tags') || '';
        state.queryTags.clear();
        const keys = tagsParam ? tagsParam.split(',').map(k => utils.slug(k)).filter(Boolean) : [];
        for (const k of keys) { state.queryTags.add(k); }
        state.queryText = q;
        // 同步輸入框文字：將 q 與 #tagTokens 組合顯示
        const tagTokens = keys.map(k => '#' + (state.tags[k]?.name || k));
        els.q.value = [q, ...tagTokens].filter(Boolean).join(' ');

        // 分頁：讀取 page 參數
        const pageParam = params.get('page');
  if (pageParam === 'game' || pageParam === 'about' || pageParam === 'bg' || pageParam === 'awards') state.page = pageParam;
        else state.page = 'home';
        // 分享列表：讀取 list 參數，逗號分隔
        const listParam = params.get('list');
        if (listParam) {
          state.receivedList = listParam.split(',').filter(Boolean);
        } else {
          state.receivedList = [];
        }
      }

      /**
       * 若 URL 有 ?sound=<id>，則聚焦並閃爍該卡片
       */
      function focusSoundFromURL() {
        const id = new URLSearchParams(location.search).get('sound');
        if (!id) return;
        const card = utils.byId('snd-' + id);
        if (card) {
          card.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // 移除舊的高亮
          if (state.highlightedCardId) {
            const prev = utils.byId('snd-' + state.highlightedCardId);
            if (prev) { prev.classList.remove('glow-persistent'); }
          }
          // 設定新的高亮 id
          state.highlightedCardId = id;
          // 加入持續外光暈
          card.classList.add('glow-persistent');
        }
      }

      // popstate 事件：返回/前進時載入 URL 條件
      window.addEventListener('popstate', () => {
        applyURLToState();
        render();
        focusSoundFromURL();
      });

      /**
       * 建立分享音效跟搜尋條件的 URL：包含當前搜尋條件與鎖定的 sound id。
       * @param {string} id 音檔檔名
       */
      function buildTotalSoundURL(id) {
        const params = buildSearchParams();
        params.set('sound', id);
        const qs = params.toString();
        return `${location.origin}${location.pathname}${qs ? '?' + qs : ''}`;
      }
      /**
       * 建立僅包含 sound id 的分享連結（不攜帶搜尋文字或標籤）。
       * 會使用目前文件的 base URL（移除 query/hash）再加上 ?sound=<id>
       * @param {string} id 音效 id
       */
      function buildSoundURL(id) {
        const href = String(location.href || '');
        // 移除 query 與 hash
        const base = href.replace(/[?#].*$/, '');
        return `${base}${base.includes('?') ? '&' : '?'}sound=${encodeURIComponent(id)}`;
      }

      /**
       * 建立分享列表的 URL：加入 list 參數，使用逗號分隔的 id 列表。
       * @param {string[]} ids
       */
      function buildListURL(ids) {
        const params = buildSearchParams();
        if (ids && ids.length) {
          params.set('list', ids.join(','));
        } else {
          params.delete('list');
        }
        // 刪除單獨音效參數
        params.delete('sound');
        const qs = params.toString();
        return `${location.origin}${location.pathname}${qs ? '?' + qs : ''}`;
      }

      /**
       * 根據 id 自動播放音效（若存在）。會使用 renderSoundCard 中的邏輯建立 Audio。
       * @param {string} id
       */
      function playSoundById(id) {
        const snd = state.sounds.find(s => s.id === id);
        if (!snd) return;
        playSoundObject(snd);
      }


      /**
       * 切換頁面：根據 page 名稱顯示不同內容，並更新網址參數與導覽樣式
       * @param {'home'|'game'|'about'} pg
       */
      function showPage(pg) {
        const prevPage = state.page;
        // 廣播「切換前」事件，讓需要在頁面被隱藏前做清理的模組先行處理。
        try {
          document.dispatchEvent(
            new CustomEvent(
              'pageChange',
              { detail: { page: pg, prevPage, phase: 'before' } })
          );
        } catch (e) { }
        state.page = pg;
  els.pageHome.classList.add('hidden');
  els.pageGame.classList.add('hidden');
  els.pageAbout.classList.add('hidden');
  if (els.pageawards) els.pageawards.classList.add('hidden');
        if (els.pageBg) els.pageBg.classList.add('hidden');
        if (pg === 'home') els.pageHome.classList.remove('hidden');
        else if (pg === 'game') els.pageGame.classList.remove('hidden');
  else if (pg === 'about') els.pageAbout.classList.remove('hidden');
  else if (pg === 'awards' && els.pageawards) els.pageawards.classList.remove('hidden');
  else if (pg === 'bg' && els.pageBg) els.pageBg.classList.remove('hidden');
        // 更新導覽標籤 active 樣式
        els.navTabs.forEach(tab => {
          if (tab.getAttribute('data-page') === pg) tab.classList.add('active');
          else tab.classList.remove('active');
        });
        // 切換背景滿版模式與收起手機選單
        document.body.classList.toggle('bg-full', (pg === 'bg' || pg === 'about'));
        document.body.classList.remove('nav-open');
        if (els.navToggle) els.navToggle.setAttribute('aria-expanded', 'false');
        // 更新 URL：保留搜尋與其他參數
        updateURLFromState(true);
        // 廣播「切換後」事件，讓需要在頁面顯示後做初始化的模組回應。
        try {
          document.dispatchEvent(
            new CustomEvent(
              'pageChange',
              { detail: { page: pg, prevPage, phase: 'after' } }));
        } catch (e) { }
      }

      /**
       * 渲染標籤一覽：列出所有使用到的標籤
       */
      function renderTagList() {
        const container = els.tagList;
        if (!container) return;
        container.innerHTML = '';
        state.usedTagList.forEach(t => {
          const el = dom.el('span', { class: 'tag', style: { background: t.color || '#94a3b8' } }, t.name);
          el.addEventListener('click', () => {
            addTagToQuery(t.key);
          });
          container.appendChild(el);
        });
      }

      /**
       * 嘗試使用剪貼簿 API，若不支援則降階到舊方式。
       * @param {string} text
       */
      function copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          return navigator.clipboard.writeText(text).catch(() => legacyCopy(text));
        }
        return legacyCopy(text);
      }
      function legacyCopy(text) {
        const ta = dom.el('textarea', { style: { position: 'fixed', left: '-9999px', top: '0' } }, text);
        document.body.appendChild(ta);
        ta.select();
        try { document.execCommand('copy'); } catch (e) { }
        ta.remove();
        return Promise.resolve();
      }

      /** Toast 提示顯示小資訊
       * 可傳入顯示時間（毫秒）；若為 0 則不會自動隱藏
       * @param {string} msg
       * @param {number} [duration=2200]
       */
      function toast(msg, duration = 2200) {
        const t = els.toast;
        if (!t) return;
        // 清除舊的計時器
        if (state.toastTimer) { clearTimeout(state.toastTimer); state.toastTimer = null; }
        t.textContent = msg;
        t.classList.remove('hidden');
        if (duration > 0) {
          state.toastTimer = setTimeout(() => {
            t.classList.add('hidden');
            state.toastTimer = null;
          }, duration);
        }
      }

      /** 打開音效的右鍵/長按選單 */
      function openMenuForSound(snd, x, y) {
        const m = els.menu;
        if (!m) return;
        m.innerHTML = '';
        // 分享網址項目
        const share = dom.el('div', { class: 'menu-item', role: 'menuitem', tabindex: '0' }, '分享網址');
        share.addEventListener('click', async () => {
          const url = buildSoundURL(snd.id);
          await copyToClipboard(url);
          closeMenu();
          toast('已複製分享連結');
          const card = utils.byId('snd-' + snd.id);
        });
        const addToMix = dom.el('div', { class: 'menu-item', role: 'menuitem', tabindex: '0' }, '加入軌道');
        addToMix.addEventListener('click', () => {
          closeMenu();
          handleAddSoundToMix(snd.id);
        });
        // 下載音檔項目
        const dl = dom.el('div', { class: 'menu-item', role: 'menuitem', tabindex: '0' }, '下載音檔');
        dl.addEventListener('click', () => {
          closeMenu();
          utils.download(snd.src, snd.file);
        });
        m.append(share, addToMix, dl);
        m.classList.remove('hidden');
        // 定位選單：確保元素有尺寸後再計算
        requestAnimationFrame(() => positionMenu(x, y));
      }

      /** 定位選單在視窗內 */
      function positionMenu(x, y) {
        const m = els.menu;
        if (!m) return;
        const pad = 6;
        const w = m.offsetWidth || 180;
        const h = m.offsetHeight || 100;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const left = Math.min(Math.max(0, x), vw - w - pad);
        const top = Math.min(Math.max(0, y), vh - h - pad);
        m.style.left = left + 'px';
        m.style.top = top + 'px';
      }

      /** 關閉選單 */
      function closeMenu() {
        const m = els.menu;
        if (!m) return;
        m.classList.add('hidden');
        m.innerHTML = '';
      }
      // 點擊外部或按 ESC 關閉選單
      document.addEventListener('click', (e) => {
        const m = els.menu;
        if (m && !m.classList.contains('hidden') && !m.contains(e.target)) closeMenu();
      });
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeMenu();
      });
      window.addEventListener('resize', closeMenu);

      /** 切換主題 */
      function applyTheme(theme) {
        document.documentElement.classList.toggle('light', theme === 'light');
      }
      const savedTheme = localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme:light)').matches ? 'light' : 'dark');
      applyTheme(savedTheme);
      els.themeBtn.addEventListener('click', () => {
        const next = document.documentElement.classList.contains('light') ? 'dark' : 'light';
        if (next == "dark") {
          playSoundById("oNTWqg"); //瓦哈音效 開燈啊
        }
        localStorage.setItem('theme', next);
        applyTheme(next);
      });

      // 設定 Modal 行為（開啟 / 關閉 / 音量綁定）
      try {
        if (els.settingsBtn) {
          els.settingsBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (!els.settingsModal) return;
            els.settingsModal.classList.remove('hidden');
            els.settingsModal.setAttribute('aria-hidden', 'false');
            // initialize slider
            if (els.settingsVolume) {
              els.settingsVolume.value = String(Math.round((state.globalVolume || 1) * 100));
            }
            if (els.settingsVolumeValue) {
              els.settingsVolumeValue.textContent = `${Math.round((state.globalVolume || 1) * 100)}%`;
            }
          });
        }
        if (els.settingsClose) {
          els.settingsClose.addEventListener('click', () => {
            if (!els.settingsModal) return;
            els.settingsModal.classList.add('hidden');
            els.settingsModal.setAttribute('aria-hidden', 'true');
          });
        }
        // backdrop click closes
        document.addEventListener('click', (ev) => {
          if (!els.settingsModal) return;
          if (els.settingsModal.classList.contains('hidden')) return;
          if (ev.target === els.settingsModal) {
            els.settingsModal.classList.add('hidden');
            els.settingsModal.setAttribute('aria-hidden', 'true');
          }
        });
        // Escape closes
        document.addEventListener('keydown', (ev) => {
          if (ev.key === 'Escape' && els.settingsModal && !els.settingsModal.classList.contains('hidden')) {
            els.settingsModal.classList.add('hidden');
            els.settingsModal.setAttribute('aria-hidden', 'true');
          }
        });
        // volume slider binding
        if (els.settingsVolume) {
          els.settingsVolume.addEventListener('input', (ev) => {
            const v = Number(els.settingsVolume.value) || 0;
            const norm = Math.max(0, Math.min(100, v)) / 100;
            state.globalVolume = norm;
            try { localStorage.setItem('globalVolume', String(norm)); } catch (e) { }
            if (els.settingsVolumeValue) els.settingsVolumeValue.textContent = `${Math.round(norm * 100)}%`;
            // apply to mix master gain if Tone is started
            try {
              if (mixAudio && mixAudio.masterGain && mixAudio.masterGain.gain) {
                // Tone.Gain.gain is a Signal; set value safely
                try { mixAudio.masterGain.gain.value = norm; } catch (e) {
                  try { mixAudio.masterGain.gain.rampTo(norm, 0.02); } catch (ee) { }
                }
              }
            } catch (e) { }
          });
        }
      } catch (e) { console.warn('[settings] init failed', e); }

      /** 播放彩蛋：當音效播放時顯示頭像，播放結束後彈跳離場 */
      const activeGroups = new Set();
      function onPlayStart(snd, audio) {
        const streamerTags = snd.tags
          .map(k => state.tags[utils.slug(k)])
          .filter(t => t && t.role === 'streamer' && t.avatar);
        if (streamerTags.length === 0) return;
        const group = dom.el('div', { class: 'group' });
        activeGroups.add(group);
        streamerTags.forEach((t, i) => {
          const avatar = dom.el('div', {
            class: 'avatar pop-in jit',
            style: { animationDelay: `${i * 60}ms` }
          }, [
            dom.el('img', { src: withV(t.avatar), alt: t.name })
          ]);
          group.appendChild(avatar);
        });
        els.stage.appendChild(group);
        audio.__group = group;
      }
      function onPlayEnd(_snd, audio) {
        const group = audio.__group;
        if (!group) return;
        const children = Array.from(group.children);
        children.forEach((av, i) => {
          av.classList.remove('jit');
          setTimeout(() => {
            av.classList.add('hop-out');
            av.addEventListener('animationend', () => {
              av.remove();
              if (group.childElementCount === 0) { group.remove(); activeGroups.delete(group); }
            }, { once: true });
          }, i * 90);
        });
      }

      /** ===== Favorites schema migration: file -> id (v1 -> v2) ===== */
      const LS_FAVORITES = 'favorites';
      const LS_FAVORITES_VERSION = 'favorites_version';        // '2' 表新版（id）
      const LS_FAVORITES_BACKUP = 'favorites_legacy_backup';  // 備份舊資料（除錯用）
      const ID_REGEX = /^[A-Za-z0-9_-]{6}$/;

      /** 將可能的舊資料各種型態，穩健轉成字串陣列 */
      function parseLegacyFavorites(raw) {
        if (!raw) return [];
        try {
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) return parsed.map(String);
          if (parsed && typeof parsed === 'object') {
            // 舊版若是 map 形式：{ "meme/awooga.mp3": true, "x.ogg": false, ... }
            return Object.keys(parsed).filter(k => !!parsed[k]).map(String);
          }
        } catch (e) {
          // 非 JSON：支援用逗號/空白分隔的舊格式
          if (typeof raw === 'string') {
            return raw.split(/[,\s]+/).map(s => s.trim()).filter(Boolean);
          }
        }
        return [];
      }

      /** 規一化 file key：去掉查詢字串、去頭尾斜線、保留原大小寫（另有小寫對照表） */
      function canonFileKey(s) {
        if (!s) return '';
        let k = String(s);
        k = k.split('?')[0];           // 去除 ?v=xxx
        k = k.replace(/^\.?\//, '');    // 去掉 ./ 或 /
        try { k = decodeURIComponent(k); } catch { }
        return k;
      }

      /** 由 sounds.json 建立對照表：file/basename/大小寫鬆弛 -> id */
      function buildFileMapsFromConfig(soundsJson) {
        const exact = new Map();
        const lower = new Map();
        soundsJson.forEach(s => {
          const file = canonFileKey(s.file);             // 例如: "animals/cat.mp3"
          const base = file.split('/').pop();            // 例如: "cat.mp3"
          const id = s.id || base;                     // 若缺 id，退回檔名（極少數情況）
          [
            file,
            base,
            'sounds/' + file,         // 某些舊資料可能帶或不帶 sounds/
            'sounds/' + base
          ].forEach(k => { exact.set(k, id); lower.set(k.toLowerCase(), id); });
        });
        return { exact, lower };
      }

      /** 需要遷移嗎？（favorites 不是純 6 碼 id 清單，就視為需要） */
      function favoritesNeedMigration(raw) {
        const list = parseLegacyFavorites(raw);
        if (list.length === 0) return false;
        return !list.every(x => ID_REGEX.test(x));
      }

      /** 主程序：在拿到 soundsJson（含 file 與 id）後呼叫 */
      function migrateFavoritesFromFilesToIds(soundsJson) {
        try {
          const raw = localStorage.getItem(LS_FAVORITES);
          if (!favoritesNeedMigration(raw)) {
            localStorage.setItem(LS_FAVORITES_VERSION, '2');
            return;
          }
          const legacy = parseLegacyFavorites(raw);
          const { exact, lower } = buildFileMapsFromConfig(soundsJson);

          const out = [];
          const seen = new Set();
          const missing = [];

          legacy.forEach(k => {
            const c = canonFileKey(k);
            const base = c.split('/').pop();
            const candidates = [c, c.replace(/^sounds\//, ''), base, 'sounds/' + c, 'sounds/' + base];
            let id = null;
            for (const cand of candidates) {
              id = exact.get(cand) || lower.get(cand.toLowerCase());
              if (id) break;
            }
            if (!id) { missing.push(k); return; }
            if (!seen.has(id)) { seen.add(id); out.push(id); }
          });

          // 寫入新版 + 備份舊版
          localStorage.setItem(LS_FAVORITES_BACKUP, raw);
          localStorage.setItem(LS_FAVORITES, JSON.stringify(out));
          localStorage.setItem(LS_FAVORITES_VERSION, '2');

          // 同步到 runtime（本次載入立即生效）
          state.favorites = out;
          state.favSet = new Set(out);
          // 使用你的 toast
          if (typeof toast === 'function') {
            toast(`已升級最愛格式，共 ${out.length} 筆${missing.length ? `；未匹配 ${missing.length} 筆` : ''}。`);
          }
          console.info('[favorites migration] done:', { converted: out.length, missing });
        } catch (err) {
          console.warn('[favorites migration] error:', err);
        }
      }

      /** 載入設定檔：使用版本字串與 no-store 以防快取；並洗牌音效 */
      async function loadConfig() {
        const [tagsJson, soundsJson] = await Promise.all([
          fetch(withV('config/tags.json'), { cache: 'no-store' }).then(r => r.json()),
          fetch(withV('config/sounds.json'), { cache: 'no-store' }).then(r => r.json())
        ]);
        // 讀取標籤
        migrateFavoritesFromFilesToIds(soundsJson);
        state.tags = {};
        state.tagList = tagsJson.map(t => ({ key: utils.slug(t.key), name: t.name, color: t.color, role: t.role, avatar: t.avatar }));
        for (const t of state.tagList) { state.tags[utils.slug(t.key)] = t; }
        // 讀取音效。若配置檔中包含 id，則使用該 id；否則 fallback 到檔名。加上版本字串。
        state.sounds = soundsJson.map(s => {
          const id = s.id || s.file.replace(/^.*[\\\/]/, '');
          return { id, src: withV(`sounds/${s.file}`), file: s.file, title: s.title, tags: s.tags.slice() };
        });
        state.soundMap = new Map(state.sounds.map(s => [s.id, s]));
        // 保存一份原始載入順序的淺拷貝，供「預設順序」還原使用
        state.defaultSoundsSnapshot = state.sounds.map(s => ({ ...s }));
        // 嘗試載入票選 CSV，將前 N 名依 CSV 排序移到最前面（若 CSV 可存取且含 id 欄）
        try {
          const top_rank_select = 30;
          const csvUrl = withV('misc/第一屆音效板票選結果.csv');
          let csvText = '';
          try {
            const resp = await fetch(csvUrl, { cache: 'no-store' });
            if (resp.ok) csvText = await resp.text();
            else console.warn('[csv load] resp not ok', resp.status, csvUrl);
          } catch (e) {
            console.warn('[csv load] failed to fetch', csvUrl, e);
          }
          if (csvText) {
            // 基本 CSV 解析：支援逗號分隔，並嘗試找出 id 欄位（大小寫不敏感）。若找不到則使用第一欄。
            const lines = csvText.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
            if (lines.length > 0) {
              const headerParts = lines[0].split(',').map(h => h.replace(/^\s+|\s+$/g, ''));
              // 優先依 header 關鍵字尋找 id 欄位（包含中文 '網址'）
              const idHeaderRegex = /(id|url|link|網址|code)/i;
              let idIndex = headerParts.findIndex(h => idHeaderRegex.test(h));
              // 若 header 中找不到，嘗試以內容採樣來找出最可能的 id 欄（短的英數字串）
              if (idIndex === -1) {
                const colCounts = new Map();
                const idLike = /^[A-Za-z0-9_-]{4,20}$/; // 假設 vote id 類似短碼
                for (let i = 1; i < Math.min(lines.length, 30); i++) {
                  const parts = lines[i].split(',');
                  for (let c = 0; c < parts.length; c++) {
                    const val = parts[c] ? parts[c].trim().replace(/^"|"$/g, '') : '';
                    if (idLike.test(val)) colCounts.set(c, (colCounts.get(c) || 0) + 1);
                  }
                }
                // 選取出現次數最多且至少一次的欄位
                let best = -1, bestCount = 0;
                for (const [c, cnt] of colCounts.entries()) {
                  if (cnt > bestCount) { best = c; bestCount = cnt; }
                }
                if (best !== -1) idIndex = best;
              }
              if (idIndex === -1) idIndex = 0;
              const topIds = [];
              for (let i = 1; i < lines.length && topIds.length < top_rank_select; i++) {
                const row = lines[i];
                // 分割時簡單處理可能的引號；這裡不做完整 CSV 規格解析以維持輕量
                const parts = row.split(',');
                let v = parts[idIndex] ? parts[idIndex].trim() : '';
                if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1, -1);
                v = v.trim();
                if (v) topIds.push(v);
              }
              if (topIds.length > 0) {
                // 建立一個更寬鬆的匹配：normalize id（去空白、小寫、去副檔名）以提高命中率
                const normalize = s => String(s || '').trim().toLowerCase().replace(/\.(mp3|wav|ogg|m4a)$/i, '');
                const normMap = new Map();
                for (const s of state.sounds) {
                  normMap.set(normalize(s.id), s);
                  if (s.file) normMap.set(normalize(s.file), s);
                }
                // 依照 CSV 的順序把存在的音效移到前面
                const seen = new Set();
                const ordered = [];
                const matchedList = [];
                for (const rawId of topIds) {
                  // 先嘗試直接 match id，否則用 normalize map
                  let s = state.soundMap.get(rawId);
                  if (!s) s = normMap.get(normalize(rawId));
                  if (s && !seen.has(s.id)) { ordered.push(s); seen.add(s.id); matchedList.push(s); }
                }
                for (const s of state.sounds) {
                  if (!seen.has(s.id)) ordered.push(s);
                }
                // 更新順序與索引；輸出 debug 日誌便於確認匹配情形
                const matchedCount = matchedList.length;
                state.sounds = ordered;
                state.soundMap = new Map(state.sounds.map(s => [s.id, s]));
                state.defaultSoundsSnapshot = state.sounds.map(s => ({ ...s }));
                console.info('[csv reorder] applied ordering from', csvUrl, 'csvIds=', topIds.length, 'matched=', matchedCount);
                console.debug('[csv reorder] csv topIds sample:', topIds.slice(0, top_rank_select));
                if (matchedCount === 0) console.warn('[csv reorder] no ids matched; check csv id column vs sounds.json ids');
                // 保存票選結果供頁面使用
                state.voteResults = {
                  topIds,
                  matchedList,
                  top10: matchedList.slice(0, 10),
                  next20: matchedList.slice(10, 30)
                };
                try { if (els.awardsBanner) els.awardsBanner.src = withV('misc/第一屆貓下去.png'); } catch (e) {}
              }
            }
          }
        } catch (e) {
          console.warn('[csv reorder] unexpected error', e);
        }
        // 計算哪些標籤被使用到，以供標籤一覽
        const usedKeys = new Set();
        state.sounds.forEach(snd => snd.tags.forEach(t => usedKeys.add(utils.slug(t))));
        state.usedTagList = state.tagList.filter(t => usedKeys.has(t.key));
      }

      /** 渲染介面：依據搜尋條件篩選音效，區分最愛與其他 */
      function render() {
        const { terms, tags } = utils.parseQuery();
        // 依搜尋條件過濾所有音效
        const filtered = state.sounds.filter(s => utils.match(s, terms, tags));
        // 收到的列表：轉成音效物件並過濾不存在者
        const received = state.receivedList.map(id => state.sounds.find(s => s.id === id)).filter(Boolean);
        // 最愛與收到的列表應用搜尋條件
        const idToSound = new Map(state.sounds.map(s => [s.id, s]));
        const allowed = new Set(filtered.map(s => s.id));
        const fav = state.favorites.map(id => idToSound.get(id)).filter(s => s && allowed.has(s.id));
        const rec = received.filter(s => filtered.includes(s) && !state.favSet.has(s.id));
        // 其餘音效：不在最愛也不在收到的列表
        const rest = filtered.filter(s => !state.favSet.has(s.id) && !rec.includes(s));
        if (!state.isSorting) { renderGrid(els.favGrid, fav, { inFav: true }); }
        renderGrid(els.receivedGrid, rec);
        renderGrid(els.grid, rest);
        els.favEmpty.classList.toggle('hidden', fav.length > 0);
        els.empty.classList.toggle('hidden', filtered.length > 0);
        // 顯示或隱藏收到的列表區塊
        if (rec.length > 0) {
          if (els.receivedSection) { els.receivedSection.classList.remove('hidden'); }
        } else {
          if (els.receivedSection) { els.receivedSection.classList.add('hidden'); }
        }
        renderActiveChips();
      }

      // 渲染票選頁面（重複使用 renderGrid / renderSoundCard）
      function renderawardsPage() {
        try {
          if (!state.voteResults) {
            if (els.awardsTop10) els.awardsTop10.innerHTML = '';
            if (els.awardsNext20) els.awardsNext20.innerHTML = '';
            return;
          }
          if (els.awardsTop10) renderGrid(els.awardsTop10, state.voteResults.top10 || []);
          if (els.awardsNext20) renderGrid(els.awardsNext20, state.voteResults.next20 || []);
        } catch (e) { console.warn('[renderawardsPage] error', e); }
      }
      /** 渲染單一區塊的音效列表 */
      function renderGrid(container, list, opts = { inFav: false }) {
        container.innerHTML = '';
        for (const s of list) { container.appendChild(renderSoundCard(s, opts)); }
      }
      /** 建立音效卡片元素 */
      function renderSoundCard(snd, opts = { inFav: false }) {
        const heartDisabled = !!(state.isSorting && opts.inFav);
        const heartAttrs = {
          class: 'heart',
          'aria-pressed': String(utils.inFav(snd.id)),
          'aria-label': '加入/移除最愛'
        };
        if (heartDisabled) {
          heartAttrs['disabled'] = 'true';
          heartAttrs['aria-disabled'] = 'true';
          heartAttrs['title'] = '正在編輯最愛排序，無法變更最愛';
        } else {
          heartAttrs['onclick'] = (e) => { e.stopPropagation(); toggleFavorite(snd.id, heartBtn); };
        }
        const heartBtn = dom.el('button', heartAttrs, dom.svgHeart());
        const tagWrap = dom.el('div', { class: 'tags' });
        for (const t of snd.tags) {
          const tagKey = utils.slug(t);
          const tagDef = state.tags[tagKey];
          const color = tagDef?.color || '#94a3b8';
          const el = dom.el('span', { class: 'tag', style: { background: color } }, t);
          el.addEventListener('click', (e) => {
            e.stopPropagation();
            addTagToQuery(tagKey);
          });
          tagWrap.appendChild(el);
        }
        const card = dom.el('div', { id: 'snd-' + snd.id, 'data-id': snd.id, class: 'sound', role: 'button', tabindex: '0', 'aria-label': `播放音效：${snd.title}` }, [
          dom.el('div', { class: 'sound-top' }, [
            dom.el('div', { class: 'title', title: snd.title }, snd.title),
            heartBtn
          ]),
          tagWrap
        ]);
        // 播放功能
        const play = async () => {
          try { playSoundObject(snd); } catch (e) { console.error(e); }
        };
        if (!(state.isSorting && opts.inFav)) {
          card.addEventListener('click', play);
        }
        if (!(state.isSorting && opts.inFav)) {
          card.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); play(); } });
        }
        // 右鍵開選單
        if (!(state.isSorting && opts.inFav)) card.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          closeMenu();
          openMenuForSound(snd, e.clientX, e.clientY);
        });
        // 行動長按開選單
        const startHold = (e) => {
          clearTimeout(state.contextTimer);
          const { clientX, clientY } = e;
          state.contextTimer = setTimeout(() => {
            closeMenu();
            openMenuForSound(snd, clientX || window.innerWidth / 2, clientY || window.innerHeight / 2);
          }, 650);
        };
        const endHold = () => { clearTimeout(state.contextTimer); };
        if (!(state.isSorting && opts.inFav)) card.addEventListener('pointerdown', startHold);
        if (!(state.isSorting && opts.inFav)) card.addEventListener('pointerup', endHold);
        if (!(state.isSorting && opts.inFav)) card.addEventListener('pointerleave', endHold);
        card.addEventListener('pointercancel', endHold);
        return card;
      }

      /** 切換最愛並重新渲染 */
      function toggleFavorite(id, btn) {
        // 在最愛排序（編輯）模式中禁止新增或移除最愛，增加robust性
        if (state.isSorting) {
          if (typeof toast === 'function') toast('正在編輯最愛排序，無法變更最愛');
          return;
        }
        if (state.favSet.has(id)) {
          state.favorites = state.favorites.filter(x => x !== id);
        } else {
          state.favorites.push(id);
        }
        state.favSet = new Set(state.favorites);
        utils.saveFav();
        if (btn) btn.setAttribute('aria-pressed', String(state.favSet.has(id)));
        render();
      }

      /** 渲染搜尋列上的已選標籤 chips */
      function renderActiveChips() {
        els.activeChips.innerHTML = '';
        for (const key of state.queryTags) {
          const tag = state.tags[key];
          const color = tag?.color || '#94a3b8';
          const chip = dom.el('span', { class: 'chip', style: { background: color }, onclick: () => { state.queryTags.delete(key); render(); updateURLFromState(true); } }, [
            `#${tag?.name || key}`,
            dom.el('button', { title: '移除', onclick: () => { state.queryTags.delete(key); render(); updateURLFromState(true); } }, '×')
          ],
          );
          els.activeChips.appendChild(chip);
        }
      }

      /** 點標籤加入搜尋：pushState，並清除建議 */
      function addTagToQuery(tagKey) {
        state.queryTags.add(tagKey);
        render();
        updateURLFromState(true);
      }

      /** 初始化事件綁定 */
      function initEvents() {
        // 搜尋框輸入（使用 debounce 降低 render 頻率）
        const handleSearchInput = () => {
          state.queryText = els.q.value;
          const val = els.q.value;
          const last = val.split(/\s+/).pop() || '';
          const needle = last.startsWith('#') ? last.slice(1).toLowerCase() : val.trim().toLowerCase();
          const list = needle
            ? state.tagList.filter(t => t.name.toLowerCase().includes(needle) || t.key.toLowerCase().includes(needle))
            : state.tagList.slice(0, 8);
          render();
          updateURLFromState(false);
        };
        els.q.addEventListener('input', utils.debounce(handleSearchInput, 180));

        // 清除搜尋
        els.clearBtn.addEventListener('click', () => {
          els.q.value = '';
          state.queryText = '';
          state.queryTags.clear();
          render();
          updateURLFromState(true);
        });

        // 導覽切換
        els.navTabs.forEach(tab => {
          tab.addEventListener('click', () => {
            const pg = tab.getAttribute('data-page');
            showPage(pg || 'home');
          });
        });
        // 手機選單開關
        if (els.navToggle) {
          els.navToggle.addEventListener('click', () => {
            const open = !document.body.classList.contains('nav-open');
            document.body.classList.toggle('nav-open', open);
            els.navToggle.setAttribute('aria-expanded', String(open));
          });
        }

        // 點擊頁面其他地方關閉手機選單
        document.addEventListener('click', (e) => {
          if (document.body.classList.contains('nav-open')) {
            const headerEl = document.querySelector('header');
            if (headerEl && !headerEl.contains(e.target)) {
              document.body.classList.remove('nav-open');
              if (els.navToggle) els.navToggle.setAttribute('aria-expanded', 'false');
            }
          }
        });

        // 點擊導覽後在小螢幕自動收合
        els.navTabs.forEach(t => t.addEventListener('click', () => {
          document.body.classList.remove('nav-open');
          if (els.navToggle) els.navToggle.setAttribute('aria-expanded', 'false');
        }));

        // 洗牌按鈕
        if (els.shuffleBtn) {
          els.shuffleBtn.addEventListener('click', () => {
            // 只洗牌「非最愛」音效，不影響最愛區的排列
            const nf = [];
            const idxs = [];
            state.sounds.forEach((s, i) => {
              if (!state.favSet.has(s.id)) { nf.push(s); idxs.push(i); }
            });
            shuffleInPlace(nf);
            idxs.forEach((i, k) => { state.sounds[i] = nf[k]; });
            render();
          });
        }
        // 預設順序按鈕：將非最愛區塊恢復為載入時的順序
        if (els.resetOrderBtn) {
          els.resetOrderBtn.addEventListener('click', () => {
            if (!state.defaultSoundsSnapshot || !state.defaultSoundsSnapshot.length) return;
            // 我們只恢復非最愛（rest）區段的順序，同 shuffleBtn 的行為相對應
            const snapshot = state.defaultSoundsSnapshot;
            // 建立 id->index map 以便依 snapshot 排序現有 state.sounds
            const idIndex = new Map(snapshot.map((s, i) => [s.id, i]));
            state.sounds.sort((a, b) => {
              const ia = idIndex.has(a.id) ? idIndex.get(a.id) : Number.MAX_SAFE_INTEGER;
              const ib = idIndex.has(b.id) ? idIndex.get(b.id) : Number.MAX_SAFE_INTEGER;
              return ia - ib;
            });
            render();
          });
        }
        // 分享最愛列表

        // 手動排序（檢查點A）：啟用/停用 SortableJS 僅針對最愛清單
        if (els.sortFavBtn && els.doneSortBtn) {
          els.sortFavBtn.addEventListener('click', () => {
            state.isSorting = true;
            document.body.classList.add('sorting');
            els.sortFavBtn.classList.add('hidden');
            els.doneSortBtn.classList.remove('hidden');
            // 重新渲染最愛區塊，讓卡片在排序模式下不綁定播放/選單事件
            const { terms, tags } = utils.parseQuery();
            const idToSound = new Map(state.sounds.map(s => [s.id, s]));
            const allowed = new Set(state.sounds.filter(s => utils.match(s, terms, tags)).map(s => s.id));
            const fav = state.favorites.map(id => idToSound.get(id)).filter(s => s && allowed.has(s.id));
            renderGrid(els.favGrid, fav, { inFav: true });
            // 啟用 SortableJS
            if (typeof Sortable !== 'undefined') {
              state.sortable = Sortable.create(els.favGrid, {
                dataIdAttr: 'data-id',
                animation: 150,
                delay: 150,
                delayOnTouchOnly: true,
                ghostClass: 'drag-ghost',
                chosenClass: 'drag-chosen',
                dragClass: 'dragging',
                // 允許點擊 ❤️ 按鈕（不觸發拖曳）
                filter: '.heart',
                preventOnFilter: false
              });
            } else {
              console.warn('SortableJS 未載入');
            }
          });
          els.doneSortBtn.addEventListener('click', () => {
            // 讀取目前 DOM 中的最愛順序
            const orderedIds = Array.from(els.favGrid.children)
              .map(el => el.getAttribute('data-id'))
              .filter(Boolean);
            if (orderedIds.length) {
              const rest = state.favorites.filter(id => !orderedIds.includes(id));
              state.favorites = orderedIds.concat(rest);
              state.favSet = new Set(state.favorites);
              utils.saveFav();
              if (typeof toast === 'function') toast('已儲存最愛排序');
            }
            if (state.sortable) { state.sortable.destroy(); state.sortable = null; }
            state.isSorting = false;
            document.body.classList.remove('sorting');
            els.doneSortBtn.classList.add('hidden');
            els.sortFavBtn.classList.remove('hidden');
            render();
          });
        }
        if (els.shareFavBtn) {
          els.shareFavBtn.addEventListener('click', async () => {
            const ids = [...state.favorites];
            if (ids.length === 0) { toast('沒有最愛可分享'); return; }
            const url = buildListURL(ids);
            await copyToClipboard(url);
            toast('已複製分享最愛列表連結');
          });
        }
      }

      // 入口：載入設定後初始化狀態、渲染並套用 URL 查詢
      loadConfig().then(() => {
        applyURLToState();
        renderTagList();
        ensureMixPanelReady();
        showPage(state.page);
        render();
        focusSoundFromURL();
        initEvents();
        // 點擊標題時回到主頁並清除搜尋（阻止預設的全頁導向），然後重新渲染與更新 URL
        try {
          const titleLink = document.querySelector('header h1');
          if (titleLink) {
            titleLink.addEventListener('click', (e) => {
              // 如果使用者使用 Ctrl/Cmd + click 或 想要在新分頁開啟，保留原行為
              if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;
              // 若已在主頁，則強制重新整理頁面
              if (state.page === 'home') {
                // 允許瀏覽器做完整 reload
                return location.reload();
              }
              e.preventDefault();
              // 清除搜尋狀態並回首頁
              state.queryText = '';
              state.queryTags.clear();
              if (els.q) els.q.value = '';
              showPage('home');
              render();
              updateURLFromState(true);
              // 平滑滾回頂部
              try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch (e) { }
            });
          }
        } catch (e) {/* ignore */ }
      }).catch(err => {
        console.error(err);
        els.grid.innerHTML = '<div class="empty">載入設定檔失敗，請確認 <code>config/</code> 路徑是否正確。</div>';
      });

      // ================= Concentration Game (配對記憶小遊戲) =================
      function setupConcentrationGame() {
        const gameEl = document.getElementById('concentration-game');
        const boardEl = document.getElementById('cg-board');
        const timerEl = document.getElementById('cg-timer');
        const accEl = document.getElementById('cg-accuracy');
        const resultEl = document.getElementById('cg-result');
        const restartBtn = document.getElementById('cg-restart');
        if (!gameEl) return;

        // 注意：不要在此處重新宣告 cgCleanup —— 請使用外層作用域的 cgCleanup，
        // 以便在切換頁面時（由 showPage 呼叫）能正確執行清理工作。

        // --- 遊戲狀態 ---
        let cards = [];
        let first = null, second = null;
        // scoring: correct = 正確數 (每配對 +2), wrong = 錯解數 (可 +0/+1/+2)
        let correct = 0, wrong = 0;
        // matchedPairs counts how many pairs have been solved (0..8)
        let matchedPairs = 0, tries = 0;
        let timer = 0, timerId = null, running = false;
        let allowClick = true;
        let pairs = [];
        // pending pair / timeout 用於延遲檢查配對；若使用者在等待期間點擊其他卡，會立刻結算這對。
        let pendingTimeout = null;
        let pendingPair = null; // {f, s}
        let timerStarted = false; // only start timer on first card flip

        /**
         * 從篩選過的有效音效中選出最多 8 筆作為配對來源。
         * @param {Array<{tags: string[]}>} validSounds - 已過濾、可用於遊戲的音效陣列
         * @returns {Array<Object>} chosen - 回傳最多 8 筆選中的音效物件
         */
        function selectSounds(validSounds) {
          let chosen = [];
          let r1 = 0, wh = 0, mtk = 0, bzh = 0, kit = 0, bros4 = 0, others = 0;

          for (const snd of validSounds) {
            const tags = Array.isArray(snd.tags) ? snd.tags : [];

            if (r1 < 2 && tags.includes('阿萬')) {
              r1++; chosen.push(snd);
            } else if (wh < 1 && tags.includes('瓦哈')) {
              wh++; chosen.push(snd);
            } else if (mtk < 1 && tags.includes('Matsuko')) {
              mtk++; chosen.push(snd);
            } else if (bzh < 1 && tags.includes('豹子頭')) {
              bzh++; chosen.push(snd);
            } else if (kit < 1 && tags.includes('貓下去')) {
              kit++; chosen.push(snd);
            } else if (bros4 < 1 && (tags.includes('貓下去') || tags.includes('豹子頭') || tags.includes('Matsuko') || tags.includes('豹子頭') || tags.includes('瓦哈'))) {
              bros4++; chosen.push(snd);
            } else {
              const isKnown =
                tags.includes('阿萬') ||
                tags.includes('瓦哈') ||
                tags.includes('豹子頭') ||
                tags.includes('貓下去') ||
                tags.includes('Matsuko');

              if (!isKnown && others < 2) {
                others++; chosen.push(snd);
              }
            }

            if (chosen.length >= 8) break; // 修正重點：滿 8 筆時停止選取
          }

          // 保險切到 8 筆
          return chosen.slice(0, 8);
        }



        // --- 資料篩選 ---
        function pickPairs() {
          // 輔助：從 tagList 擷取所有 streamer 的 key（並做 slug 化）以供後續比對
          const streamerKeys = state.tagList
            .filter(t => t.role === 'streamer')
            .map(t => utils.slug(t.key));

          const isStreamer = t => streamerKeys.includes(t);
          // 有效音效範圍：每個音檔必須恰好包含一個 streamer 標籤，且不包含 '髒話' 標籤
          let validSounds = state.sounds.filter(s => {
            const st = s.tags.filter(isStreamer);
            if (st.length !== 1) return false;
            if (s.tags.includes('髒話') || s.tags.includes('SUS')) return false;
            return true;
          });

          validSounds = shuffleInPlace(validSounds);
          let chosen = selectSounds(validSounds);
          chosen = shuffleInPlace(chosen);
          // 最後確保不超過 8 筆
          chosen.splice(8);

          // 映射到配對用物件（包含 id, audio, avatar, streamerName, title 等欄位）
          return chosen.map(s => {
            const streamerTag = s.tags.find(isStreamer);
            const tagObj = state.tags[utils.slug(streamerTag)];
            return {
              id: s.id,
              audio: s.src,
              streamer: streamerTag,
              avatar: tagObj?.avatar || '',
              streamerName: tagObj?.name || streamerTag,
              title: s.title
            };
          });
        }

        // --- 遊戲初始化 ---
        function startGame() {
          pairs = pickPairs();
          // 如果找不到足夠的配對音效，顯示訊息並中止遊戲啟動
          if (!pairs || pairs.length === 0) {
            resultEl.innerHTML = `<h3>無法開始遊戲</h3><p style="color:var(--muted)">目前沒有足夠的音效可供配對（需至少 1 組）。請回到主頁或稍後再試。</p>`;
            resultEl.classList.remove('hidden');
            running = false;
            state.cgRunning = false;
            return;
          }
          cards = [];
          // 清除任何先前殘留的 pending timeout/pair，避免在重新開始遊戲時觸發舊的 callback
          try { if (pendingTimeout) { clearTimeout(pendingTimeout); pendingTimeout = null; pendingPair = null; } } catch (e) { }
          pairs.forEach((p, i) => {
            // 為每個配對建立兩張相同的卡片（兩張卡片都會顯示 avatar 並播放相同音檔）
            cards.push({ type: 'card', pairId: p.id, id: `${p.id}-0`, audio: p.audio, avatar: p.avatar, streamer: p.streamer, streamerName: p.streamerName, title: p.title, matched: false, seen: false });
            cards.push({ type: 'card', pairId: p.id, id: `${p.id}-1`, audio: p.audio, avatar: p.avatar, streamer: p.streamer, streamerName: p.streamerName, title: p.title, matched: false, seen: false });
          });
          shuffleInPlace(cards);
          matchedPairs = 0; correct = 0; wrong = 0; tries = 0; timer = 0; first = null; second = null; allowClick = true;
          // 建立新回合時不自動啟動遊戲或計時器；遊戲會在玩家翻開第一張卡時開始。
          timerStarted = false;
          running = false;
          state.cgRunning = false;
          // 確保計時器的 UI 被重置，並移除正在運行的樣式
          if (timerEl) { timerEl.textContent = formatTime(timer); timerEl.classList.remove('cg-running'); }
          updateBoard();
          updateStats();
          resultEl.classList.add('hidden');
          // 提供清理函式（指定給外層的 cgCleanup，使 showPage 在離開遊戲頁時可以呼叫）
          cgCleanup = () => {
            running = false;
            state.cgRunning = false;
            stopTimer();
            stopCurrentAudio();
            if (timerEl) timerEl.classList.remove('cg-running');
            // 透過清空 board 的 innerHTML 移除所有事件處理器與 DOM 元素
            boardEl.innerHTML = '';
            // 清除任何尚未完成的 pending timeout
            try { if (pendingTimeout) { clearTimeout(pendingTimeout); pendingTimeout = null; pendingPair = null; } } catch (e) { }
          };
        }
        function updateBoard() {
          boardEl.innerHTML = '';
          cards.forEach((card, idx) => {
            const cardEl = document.createElement('div');
            cardEl.className = 'cg-card';
            cardEl.dataset.idx = idx;
            if (card.flipped || card.matched) cardEl.classList.add('flipped');
            if (card.matched) cardEl.classList.add('matched');
            // 若提供 avatar 則顯示圖片，否則以安全方式顯示名字的縮寫字母
            const backContent = card.avatar
              ? `<img src="${withV(card.avatar)}" alt="${card.streamerName}">`
              : `<div style="font-weight:700;color:var(--muted);font-size:12px">${card.streamerName}</div>`;
            cardEl.innerHTML = `
        <div class="cg-card-inner">
          <div class="cg-card-front"></div>
          <div class="cg-card-back">
            ${backContent}
            ${card.matched ? '<div class="cg-lock">✓</div>' : ''}
          </div>
        </div>
      `;
            // 保留原本的點擊行為，並在 pointerdown 時增加短暫的視覺回饋（CSS）
            cardEl.onclick = () => onCardClick(idx);
            cardEl.addEventListener('pointerdown', (ev) => {
              // 加上 'clicked' 類別以觸發 CSS 回饋，短時間後移除
              cardEl.classList.add('clicked');
              setTimeout(() => cardEl.classList.remove('clicked'), 160);
            });
            boardEl.appendChild(cardEl);
          });
        }

        let currentAudio = null;

        function stopCurrentAudio() {
          if (currentAudio) {
            try { currentAudio.pause(); currentAudio.currentTime = 0; } catch (e) { }
            currentAudio = null;
          }
        }

        function onCardClick(idx) {
          // 如果有待處理的 pendingPair，使用者此刻點擊其他卡片時應立即結算該 pendingPair
          if (typeof pendingPair !== 'undefined' && pendingPair && (pendingPair.f || pendingPair.s)) {
            // 先清除 timeout 並立刻結算
            if (pendingTimeout) { clearTimeout(pendingTimeout); pendingTimeout = null; }
            const p = pendingPair; pendingPair = null;
            checkMatchPair(p.f, p.s);
            // 重置全域 first/second，允許繼續互動
            first = null; second = null;
            allowClick = true;
          }
          if (!allowClick) return;
          const card = cards[idx];
          if (card.flipped || card.matched) return;
          // 在玩家第一次互動（翻牌）時啟用計時器
          if (!timerStarted) {
            timerStarted = true;
            // 將遊戲標記為正在進行並更新 UI
            running = true;
            state.cgRunning = true;
            if (timerEl) timerEl.classList.add('cg-running');
            startTimer();
          }
          // 執行翻牌（更新資料狀態並重新渲染板面，觸發 CSS 翻牌動畫）
          card.flipped = true;
          updateBoard();
          if (!first) {
            // 記錄這張卡牌在翻前是否已被翻看過（用於計分判定）
            card._seenBefore = !!card.seen;
            // 標記為已看過（避免後續重複計分）
            card.seen = true;
            first = card;
            // 播放該卡的音效並顯示標題；避免音訊重疊
            stopCurrentAudio();
            currentAudio = createPlayer(card.audio, { preload: 'auto' });
            if (typeof toast === 'function' && card.title) toast(card.title, 3000);
          } else if (!second) {
            // 第二張卡的處理：同樣標記是否先前看過並播放音效
            card._seenBefore = !!card.seen;
            card.seen = true;
            second = card;
            stopCurrentAudio();
            currentAudio = createPlayer(card.audio, { preload: 'auto' });
            if (typeof toast === 'function' && card.title) toast(card.title, 3000);
            tries++;
            allowClick = false;
            // 捕獲當前第一張/第二張卡的引用，避免在延遲期間被其他邏輯改寫造成 race condition。
            const fCard = first;
            const sCard = second;
            // 儲存為 pendingPair，並啟動超時（500ms）。如果使用者在此期間點擊其他卡
            // 則會在 onCardClick 開頭立刻結算這對。
            pendingPair = { f: fCard, s: sCard };
            if (pendingTimeout) { clearTimeout(pendingTimeout); pendingTimeout = null; }
            pendingTimeout = setTimeout(() => {
              pendingTimeout = null;
              const p = pendingPair; pendingPair = null;
              checkMatchPair(p.f, p.s);
              // 重置全域暫存，允許下一回合互動
              first = null;
              second = null;
              allowClick = true;
            }, 500);
          }
          updateStats();
        }

        /**
         * 檢查一對卡片是否配對，僅操作傳入的卡物件（避免 race condition）。
         * 這個函式不會去重置外層的 first/second 變數，呼叫端應負責重置與允許使用者互動。
         * @param {object|null} f 第一張卡
         * @param {object|null} s 第二張卡
         */
        function checkMatchPair(f, s) {
          if (!f || !s) return;
          if (f.pairId === s.pairId) {
            // 配對正確：增加正確計分（+2）
            f.matched = true;
            s.matched = true;
            correct += 2;
            matchedPairs += 1;
            // 保持翻面狀態並標記為已配對（不可再次點擊）
          } else {
            // 未配對：判定是否在此回合前已看過任一張卡，根據情況增加 wrong 分數
            const aSeen = !!f._seenBefore;
            const bSeen = !!s._seenBefore;
            if (aSeen && bSeen) wrong += 2;
            else if (aSeen || bSeen) wrong += 1;
            // 將兩張卡翻回（關閉翻面狀態）

            f.flipped = false;
            s.flipped = false;

          }
          // 清理暫存的 _seenBefore 標記
          delete f._seenBefore;
          delete s._seenBefore;
          // 更新 UI 與統計
          updateBoard();
          updateStats();
          if (matchedPairs === pairs.length) {
            stopCurrentAudio();
            endGame();
          }
        }

        // 向後相容的 wrapper（保留原本任何直接呼叫 checkMatch 的行為）
        function checkMatch() {
          const f = first;
          const s = second;
          checkMatchPair(f, s);
          // 呼叫端（例如延遲回呼）通常會負責重置 first/second 與 allowClick；
          // 若有直接呼叫此 wrapper，這裡也確保把 first/second 清空以避免殘留狀態。
          first = null; second = null;
        }

        function updateStats() {
          timerEl.textContent = formatTime(timer);
          const denom = correct + wrong;
          const perc = denom ? Math.round((correct / denom) * 100) : null;
          accEl.textContent = perc !== null ? `準確率：${perc}%` : '準確率：--%';
        }

        function formatTime(t) {
          const m = Math.floor(t / 60).toString().padStart(2, '0');
          const s = (t % 60).toString().padStart(2, '0');
          return `${m}:${s}`;
        }

        function startTimer() {
          if (timerId) clearInterval(timerId);
          timerId = setInterval(() => {
            // 只有當遊戲標記為進行中時才會推進計時器
            if (!state.cgRunning) return;
            timer++;
            timerEl.textContent = formatTime(timer);
          }, 1000);
        }
        function stopTimer() {
          if (timerId) clearInterval(timerId);
          timerId = null;
        }

        function endGame() {
          running = false;
          state.cgRunning = false;
          stopTimer();
          stopCurrentAudio();
          if (timerEl) timerEl.classList.remove('cg-running');
          const denom = correct + wrong;
          const perc = denom ? Math.round((correct / denom) * 100) : '--';
          resultEl.innerHTML = `
            <h3>完成！</h3>
            <div class="stats">
              <div><div class="big-num">${formatTime(timer)}</div><div class="muted">用時</div></div>
              <div><div class="big-num">${correct}</div><div class="muted">正確數</div></div>
              <div><div class="big-num">${wrong}</div><div class="muted">錯解數</div></div>
              <div><div class="big-num">${perc}%</div><div class="muted">準確率</div></div>
            </div>
            <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
              <button class="btn small-btn" id="cg-restart-2">再來一局</button>
              <button class="btn small-btn" id="cg-home">回主頁</button>
            </div>
          `;
          resultEl.classList.remove('hidden');
          // 若準確率為 100%，隨機播放一則指定 id 的獎勵音效
          try {
            if (perc >= 90) {
              // 硬編碼獎勵語音 id 清單
              const rewardIds = ['c4B1fg', 'Hv3yFA', 'JkJ9-A', '5VHtAg'];
              const reward = state.sounds && state.sounds.find(s => s.id === rewardIds[Math.floor(Math.random() * rewardIds.length)]);
              if (reward && reward.src) {
                // 停掉現有音訊並播放獎勵音效
                stopCurrentAudio();
                currentAudio = createPlayer(reward.src, { preload: 'auto' });
                if (typeof toast === 'function') toast('你是記憶猛肝', 3000);
              }
            }

          } catch (e) { /* swallow any error to avoid breaking end-game UI */ }
          // 為結果面板內的按鈕綁定本地事件處理器（例如再來一局、回主頁）
          const restart2 = document.getElementById('cg-restart-2');
          if (restart2) restart2.addEventListener('click', () => { startGame(); });
          const homeBtn = document.getElementById('cg-home');
          if (homeBtn) homeBtn.addEventListener('click', () => { showPage('home'); });
        }

        restartBtn.onclick = startGame;

        // 初始：載入頁面時顯示卡牌（不啟動計時）。按「重開一局」可重新建立一局；計時皆在第一張翻牌時啟動。
        // 這裡呼叫 startGame() 以建立並顯示卡牌（但 timerStarted=false，不會自動開始計時）
        startGame();
      }

      // 切換到小遊戲分頁時初始化/清理 Concentration Game（使用事件驅動）
      document.addEventListener('pageChange', (ev) => {
        const pg = ev && ev.detail && ev.detail.page;
        const prev = ev && ev.detail && ev.detail.prevPage;
        try {
          const phase = ev && ev.detail && ev.detail.phase;
          // 在 page 被隱藏之前（before），執行清理
          if (phase === 'before' && prev === 'game' && typeof cgCleanup === 'function') {
            try { cgCleanup(); } catch (e) { /* ignore cleanup errors */ }
          }
          // 在 page 顯示之後（after），執行初始化
          if (phase === 'after') {
            if (pg === 'game' && typeof setupConcentrationGame === 'function') setupConcentrationGame();
            if (pg === 'awards') renderawardsPage();
          }
        } catch (e) { /* swallow to avoid breaking page flow */ }
      });

    })();
  </script>
</body>

</html>