<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Soundboard — 軌道編輯器 Demo (Tone.js + Wavesurfer)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;display:flex;height:100vh}
    .sidebar{width:280px;border-right:1px solid #ddd;padding:12px;overflow:auto;min-width:180px;transition:width .18s ease,padding .18s ease}
    .sidebar.collapsed{width:0;min-width:0;padding:0;overflow:hidden}
    /* keep sidebar visible by default on small screens unless user collapses it explicitly */
    @media (max-width:700px){
      .sidebar{position:relative;z-index:2}
      .main{flex:1;min-width:0}
    }
    .main{flex:1;padding:12px;display:flex;flex-direction:column}
    .controls{display:flex;gap:8px;margin-bottom:8px}
  .timeline{flex:1;border:1px solid #ccc;border-radius:6px;padding:8px;overflow:auto;background:#fafafa;position:relative}
  .playhead{position:absolute;top:0;bottom:0;width:2px;background:rgba(255,50,50,0.95);z-index:999;pointer-events:none;display:none}
    .tracks{display:flex;flex-direction:column;gap:8px}
    .track{height:80px;background:#fff;border:1px dashed #ccc;position:relative}
    .clip{position:absolute;top:6px;height:68px;background:#6aa9ff;color:#012;display:flex;align-items:center;padding:6px;border-radius:6px;cursor:pointer;overflow:hidden}
    .sound-item{padding:8px;border:1px solid #eee;border-radius:6px;margin-bottom:6px;background:#fff;cursor:grab}
    .sound-item:active{cursor:grabbing}
    .time-ruler{height:24px;margin-bottom:8px;color:#666}
    .small{font-size:12px;color:#666}
  </style>
</head>
<body>
  <div class="sidebar">
    <h3>音效清單</h3>
    <div>
      <input id="soundSearch" placeholder="搜尋音效…" style="width:100%;padding:6px;margin-bottom:8px" />
    </div>
    <div id="soundList">載入中...</div>
    <hr/>
    <div class="small">拖曳一個音效到任意軌道即可建立片段。拖曳後可在下一次播放前移動位置（示範用）。</div>
  </div>
  <div class="main">
    <div class="controls">
      <button id="playBtn">Play</button>
      <button id="stopBtn">Stop</button>
      <button id="toggleSidebarBtn" title="切換側欄">☰</button>
      <label>px/sec <input id="scale" type="number" value="100" style="width:80px"/></label>
      <span id="status" class="small">狀態：未就緒</span>
    </div>
    <div id="progressContainer" style="height:10px;background:#eee;border-radius:6px;overflow:hidden;margin-bottom:8px">
      <div id="progressBar" style="height:100%;width:0;background:linear-gradient(90deg,#6aa9ff,#2b7cff);"></div>
    </div>
    <div class="small" id="timeDisplay">00:00 / 00:00</div>
    <div class="time-ruler" id="ruler">時間尺 (秒)</div>
    <div class="timeline">
      <div id="playhead" class="playhead"></div>
      <div class="tracks" id="tracks"></div>
    </div>
  </div>

  <!-- Tone.js & Wavesurfer.js via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
  <script src="https://unpkg.com/wavesurfer.js"></script>
  <script>
  // Simple demo: preload sounds from config/sounds.json and allow drag->drop into tracks
  const soundListEl = document.getElementById('soundList');
  const sidebarEl = document.querySelector('.sidebar');
  const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
  const soundSearchInput = document.getElementById('soundSearch');
  const tracksEl = document.getElementById('tracks');
  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');
  const statusEl = document.getElementById('status');
  const scaleInput = document.getElementById('scale');

  // Demo config
  const TRACK_COUNT = 3;
  let pxPerSec = Number(scaleInput.value) || 100;

  // Data model
  const sounds = []; // {id, file, title, src}
  const buffers = new Map(); // id -> Tone.Buffer
  const clips = []; // {id, soundId, track, start, duration, dom}

  // Create track DOMs
  for(let i=0;i<TRACK_COUNT;i++){
    const t = document.createElement('div'); t.className='track'; t.dataset.track=i;
    // allow drop
    t.addEventListener('dragover', e=>{ e.preventDefault(); t.style.background='#f0f8ff'; });
    t.addEventListener('dragleave', e=>{ t.style.background=''; });
    t.addEventListener('drop', onDropToTrack);
    tracksEl.appendChild(t);
  }

  // Load sounds.json (uses same config path as app)
  async function loadSounds(){
    try{
      const res = await fetch('config/sounds.json');
      const data = await res.json();
      soundListEl.innerHTML = '';
      // add all sounds to the model
      data.forEach(s=>{
        const id = s.id || s.file.split('/').pop();
        const src = 'sounds/' + s.file;
        sounds.push({id, file:s.file, title:s.title || id, src});
      });
      // render full list (with optional search)
      renderSoundList();
      status('載入完成，開始預載音訊...');
      await preloadAll();
      status('就緒 — 可拖曳到軌道');
      renderRuler();
    }catch(e){ soundListEl.textContent = '載入失敗：'+e.message; }
  }

  function status(t){ statusEl.textContent = '狀態：'+t; }

  async function preloadAll(){
    // Tone.Buffer handles caching and decoding
    const promises = sounds.map(s => {
      return new Promise((resolve) => {
        const b = new Tone.Buffer(s.src, ()=>{ buffers.set(s.id,b); resolve(); }, err=>{ console.warn('buf err',s.id,err); resolve(); });
      });
    });
    await Promise.all(promises);
  }

  function onDropToTrack(e){
    e.preventDefault();
    const id = e.dataTransfer.getData('text/sound-id');
    const track = Number(this.dataset.track);
    // compute start based on mouse offset in track
    const rect = this.getBoundingClientRect();
    const x = e.clientX - rect.left + this.scrollLeft;
    const startSec = Math.max(0, x / pxPerSec);
    createClip(id, track, startSec);
    this.style.background='';
    renderRuler();
  }

  function createClip(soundId, track, start){
    const snd = sounds.find(s=>s.id===soundId);
    if(!snd) return;
    const buffer = buffers.get(soundId);
    const dur = buffer ? buffer.duration : 2;
    const clip = { id: 'c'+Math.random().toString(36).slice(2,8), soundId, track, start, duration: dur };
    clips.push(clip);
    renderClipDOM(clip);
    renderRuler();
  }

  function renderRuler(){
    const ruler = document.getElementById('ruler');
    // compute total length in seconds from clips
    const end = clips.reduce((m,c)=>Math.max(m, c.start + c.duration), 10);
    // show ticks every 1s, but compute visible width
    const totalPx = Math.max(600, end * pxPerSec);
    // create a simple textual ruler showing second markers
    let html = '';
    for(let s=0;s<=Math.ceil(end);s+=1){
      const left = s * pxPerSec;
      html += `<span style="position:relative;display:inline-block;margin-left:${s===0?left: left - (s-1)*pxPerSec}px;width:1px;height:14px;background:#888;vertical-align:middle"></span><span style="margin-left:6px">${s}</span>`;
    }
    ruler.innerHTML = '時間尺 (秒) — 長度: ' + Math.ceil(end) + 's';
    // ensure timeline min width to allow scrolling
    document.querySelector('.tracks').style.minWidth = totalPx + 'px';
  }

  // render the sound list with optional filter
  function renderSoundList(filter){
    const q = (filter||'').trim().toLowerCase();
    soundListEl.innerHTML = '';
    const list = sounds.filter(s => !q || (s.title||'').toLowerCase().includes(q) || (s.file||'').toLowerCase().includes(q));
    if(list.length === 0){ soundListEl.textContent = '找不到音效'; return; }
    for(const s of list){
      const id = s.id;
      const div = document.createElement('div');
      div.className = 'sound-item'; div.draggable=true; div.dataset.id=id;
      div.textContent = s.title || s.file;
      div.addEventListener('dragstart', (ev)=>{ ev.dataTransfer.setData('text/sound-id', id); });
      soundListEl.appendChild(div);
    }
  }

  // wire search input
  soundSearchInput?.addEventListener('input', (e)=>{ renderSoundList(e.target.value); });

  function renderClipDOM(clip){
    const trackEl = tracksEl.children[clip.track];
    const el = document.createElement('div'); el.className='clip'; el.dataset.clip=clip.id;
    el.style.left = (clip.start * pxPerSec) + 'px';
    el.style.width = Math.max(40, clip.duration * pxPerSec) + 'px';
    el.textContent = sounds.find(s=>s.id===clip.soundId)?.title || clip.soundId;
    // allow dragging horizontally (simple)
    let dragStartX=0, origLeft=0, dragging=false;
    el.addEventListener('pointerdown', (ev)=>{
      dragging=true; dragStartX = ev.clientX; origLeft = parseFloat(el.style.left)||0; el.setPointerCapture(ev.pointerId);
    });
    document.addEventListener('pointermove', (ev)=>{
      if(!dragging) return; const dx = ev.clientX - dragStartX; el.style.left = (origLeft + dx) + 'px';
    });
    el.addEventListener('pointerup', (ev)=>{ if(!dragging) return; dragging=false; const left = parseFloat(el.style.left)||0; clip.start = Math.max(0, left/pxPerSec); el.releasePointerCapture(ev.pointerId); });
    // on double-click show waveform using Wavesurfer
    el.addEventListener('dblclick', async ()=>{
      const ws = WaveSurfer.create({container: el, waveColor:'#ffffff66', progressColor:'#fff', height:68, interact:false});
      const b = buffers.get(clip.soundId);
      if(b){
        // Load from url to wavesurfer (for demo), or use decode -> export PCM for wavesurfer loadBlob
        ws.load(sounds.find(s=>s.id===clip.soundId).src);
        setTimeout(()=>ws.destroy(), 4000);
      }
    });
    trackEl.appendChild(el);
    clip.dom = el;
  }

  // Playback: schedule with Tone.Transport
  let currentPlayers = [];
  let playStartTime = 0;
  let playEndTime = 0;
  let rafId = null;
  let stopTimeout = null;
  const playheadEl = document.getElementById('playhead');
  const timelineEl = document.querySelector('.timeline');

  function updateProgress(){
    const now = Tone.now();
    const elapsed = Math.max(0, now - playStartTime);
    const total = Math.max(0, playEndTime - playStartTime);
    const pct = total > 0 ? Math.min(1, elapsed / total) : 0;
    const bar = document.getElementById('progressBar');
    const timeDisplay = document.getElementById('timeDisplay');
    if(bar) bar.style.width = (pct*100) + '%';
    if(timeDisplay) timeDisplay.textContent = formatTime(elapsed) + ' / ' + formatTime(total);
    // move playhead
    if(playheadEl){
      if(pct > 0 && pct < 1){
        playheadEl.style.display = 'block';
      } else if(pct >= 1){
        playheadEl.style.display = 'none';
      } else if(pct === 0){
        playheadEl.style.display = 'block';
      }
      // compute x in px relative to timeline content (not viewport)
      const elapsedSec = elapsed;
      const x = elapsedSec * pxPerSec;
      playheadEl.style.left = x + 'px';
      // auto-scroll: keep playhead near center (or within 30% edges)
      try{
        const viewW = timelineEl.clientWidth;
        const scrollLeft = timelineEl.scrollLeft;
        const absX = x; // playhead absolute in content
        const leftEdge = scrollLeft + viewW*0.2;
        const rightEdge = scrollLeft + viewW*0.8;
        if(absX < leftEdge || absX > rightEdge){
          // scroll so playhead is centered
          const target = Math.max(0, absX - viewW/2);
          timelineEl.scrollLeft = target;
        }
      }catch(e){ console.warn('scroll err', e); }
    }
    if(pct < 1){ rafId = requestAnimationFrame(updateProgress); } else { rafId = null; }
  }

  function formatTime(t){
    // t in seconds
    if(!isFinite(t) || t <= 0) return '00:00';
    const s = Math.floor(t%60).toString().padStart(2,'0');
    const m = Math.floor(t/60).toString().padStart(2,'0');
    return m+':'+s;
  }

  function playTimeline(){
    if(Tone.context.state !== 'running') Tone.context.resume();
    // stop any existing
    stopTimeline();
    Tone.Transport.cancel();
    currentPlayers = [];
    const base = Tone.now() + 0.1;
    for(const clip of clips){
      const buf = buffers.get(clip.soundId);
      if(!buf) continue;
      const player = new Tone.Player(buf).toDestination();
      currentPlayers.push(player);
      const when = base + clip.start;
      const offset = 0;
      const dur = clip.duration;
      try{ player.start(when, offset, dur); }catch(e){ console.warn(e); }
    }
    const end = clips.reduce((m,c)=>Math.max(m, c.start + c.duration), 0);
    playStartTime = base;
    playEndTime = base + end;
  // initialize playhead position
  if(playheadEl){ playheadEl.style.display = 'block'; playheadEl.style.left = '0px'; }
    // schedule a stop to ensure cleanup
    stopTimeout = setTimeout(()=>{ stopTimeline(); status('就緒'); }, (end + 1)*1000);
    Tone.Transport.start();
    status('播放中');
    // start RAF progress
    if(rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(updateProgress);
  }

  function stopTimeline(){
    // stop players
    try{ currentPlayers.forEach(p=>{ try{ p.stop(); }catch(e){} }); }catch(e){}
    currentPlayers = [];
    if(stopTimeout){ clearTimeout(stopTimeout); stopTimeout = null; }
    try{ Tone.Transport.stop(); }catch(e){}
    status('已停止');
    if(rafId) { cancelAnimationFrame(rafId); rafId = null; }
    if(playheadEl){ playheadEl.style.display = 'none'; playheadEl.style.left = '0px'; }
    const bar = document.getElementById('progressBar'); if(bar) bar.style.width='0%';
    const timeDisplay = document.getElementById('timeDisplay'); if(timeDisplay) timeDisplay.textContent = '00:00 / 00:00';
  }

  playBtn.addEventListener('click', ()=> playTimeline());
  stopBtn.addEventListener('click', ()=> stopTimeline());
  scaleInput.addEventListener('change', ()=>{ pxPerSec = Number(scaleInput.value)||100; // reposition clips
    clips.forEach(c=>{ if(c.dom){ c.dom.style.left = (c.start*pxPerSec)+'px'; c.dom.style.width = Math.max(40, c.duration*pxPerSec)+'px'; } });
    renderRuler();
  });

  // init
  // restore sidebar state
  try{
    const collapsed = localStorage.getItem('editor.sidebar.collapsed');
    if(collapsed === '1'){ sidebarEl.classList.add('collapsed'); }
  }catch(e){}
  toggleSidebarBtn?.addEventListener('click', ()=>{
    const is = sidebarEl.classList.toggle('collapsed');
    try{ localStorage.setItem('editor.sidebar.collapsed', is? '1':'0'); }catch(e){}
  });
  loadSounds();
  </script>
</body>
</html>
